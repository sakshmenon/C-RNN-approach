<start>     { <end>
<start>  <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start>         goto do_exit ;  <end>
<start>                 sendFPRCommand ( FPR_ENROLL_START ,  newUser )  ;  <end>
<start>      <end>
<start>  <end>
<start> one_key[16] = 1 ;  <end>
<start>     char* WIFI_KEY = "624624nbnb" ;   <end>
<start>     displayLockScreen (  )  ;  <end>
<start> #include "DH/uart.h" <end>
<start>     MDB_Send ( CSH_VEND_DENIED )  ;  <end>
<start>     uint8_t a_char = 0x41 ;  <end>
<start>     0b00001001   <end>
<start>         } <end>
<start>         sign_params.temp_key = &temp_key ;  <end>
<start>     for  ( i = 4 ;  i < 15 ;  ++i )  <end>
<start>      * =================================== <end>
<start>     vmc_prices.maxPrice = 0 ;  <end>
<start> STOP_SAMPLE_LIMIT           = 2 ,      <end>
<start>     } <end>
<start> #endif  <end>
<start>     memmove ( temp+32 ,  k+32 ,  32 )  ;  <end>
<start>      <end>
<start> #define FOURTH_ROW 3 <end>
<start> #ifdef RT_I2C_DEBUG <end>
<start> #include <stdarg.h> <end>
<start>     msgs[1].buf = buffer ;  <end>
<start> { <end>
<start>     #include <xc.h> <end>
<start>      <end>
<start>         } <end>
<start> setEncryptionKey ( one_key )  ;  <end>
<start>         periph_id[i] = 0 ;  <end>
<start> if ( column != 0x0F ) { <end>
<start>                 } <end>
<start>         atca_delay_ms ( delay_ms )  ;  <end>
<start>         Log_d ( "Waiting for system time to be set...  ( %d/%d ) " ,  retry ,  retry_count )  ;  <end>
<start>     ret_code = atoi ( pvalue )  ;  <end>
<start>  <end>
<start> #if 1 <end>
<start>                 WifiStart ( CLIENT_MODE )  ;  <end>
<start> } <end>
<start>      <end>
<start>      <end>
<start> #define DEBUG_MODE 0  <end>
<start>         return -1 ;  <end>
<start> dhsettings_get_devicehive_deviceid (  ) [0] && <end>
<start>  <end>
<start>     delay_ms ( 100 )  ;   <end>
<start>         OLED_ShowString ( 65 ,  16 ,  "Security" ,  16 ,  1 )  ;  <end>
<start> xexDecryptInternal ( out ,  in ,  n ,  seq ,  nv_storage_tweak_key ,  nv_storage_encrypt_key )  ;  <end>
<start> g_return_val_if_fail ( out != NULL ,  FALSE )  ;  <end>
<start>     LED_SET ( LED_OFF )  ;  <end>
<start>  <end>
<start>     if  ( 0 == iotx_http_context->keep_alive )  { <end>
<start>      <end>
<start> void user_rf_pre_init ( void )  { <end>
<start>         else if  ( status.ledOverride >= 0 )  <end>
<start> } <end>
<start> NonVolatileReturn encryptedNonVolatileWrite ( uint8_t *data ,  NVPartitions partition ,  uint32_t address ,  uint32_t length )  <end>
<start> NOT_STARTED_AFTER_INTERVAL ,    <end>
<start> g_return_val_if_fail ( outpath ,  FALSE )  ;  <end>
<start>                 break ;  <end>
<start>      <end>
<start>  <end>
<start>                                     sendBuff[1] = 'D' ;   <end>
<start>                   iotx_http_context->p_devinfo->device_name ,  <end>
<start> fclose ( f )  ;  <end>
<start>  <end>
<start> memset ( n ,  0 ,  16 )  ;  <end>
<start>             URecv_Index = 0 ;  <end>
<start>  <end>
<start>     struct rt_i2c_device* i2c_device =  ( struct rt_i2c_device* ) i2c_dev ;  <end>
<start> #include <stdint.h>         <end>
<start> 0x0 , 0x7 , 0x83 , 0xff , 0xe0 , 0xe , 0x0 , 0x0 ,  <end>
<start> ECCRYPTO_STATUS SchnorrQ_Sign ( const unsigned char* SecretKey ,  const unsigned char* PublicKey ,  const unsigned char* Message ,  const unsigned int SizeMessage ,  unsigned char* Signature )  <end>
<start>     if  ( lastTime != rtcTicksSeconds )  <end>
<start>          <end>
<start> reportFailure (  )  ;  <end>
<start>     qrcode = QRcode_encodeString (  ( const char* ) Des ,  1 ,  QR_ECLEVEL_L ,  QR_MODE_8 ,  0 )  ;  <end>
<start>  <end>
<start> LCD_clear (  )  ;  <end>
<start>  <end>
<start>     while  ( ESP8266_Send_Answer ( at_cipmux ,  ok )  )  { <end>
<start> #include "Utils/Fifo.h" <end>
<start>                     restart = 1 ;  <end>
<start> encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start>     uint8_t sn[9] ;  <end>
<start> if ( dhsettings_get_wifi_mode (  )  == WIFI_MODE_AP && <end>
<start> /* limit decrypt size to maxsize if set */ <end>
<start>     ret = iotx_report_devinfo ( iotx_http_context )  ;  <end>
<start>     } <end>
<start>  <end>
<start> void displayLockScreen (  )  <end>
<start>                + user_funds_L  )  ;  <end>
<start> block_start = address & 0xfffffff0 ;  <end>
<start>             memset ( URecv ,  0 ,  sizeof ( URecv )  )  ;  <end>
<start>  <end>
<start>     HAL_Snprintf ( topic_path ,  sizeof ( topic_path )  ,  "/topic%s" ,  topic_name )  ;  <end>
<start>  <end>
<start>     if  ( NULL == iotx_http_context || <end>
<start>     iotx_http_context->timeout_ms = pInitParams->timeout_ms ;  <end>
<start>      <end>
<start> { <end>
<start>          <end>
<start> void genRandCode ( u8* Des )  ;  <end>
<start> NonVolatileReturn r ;  <end>
<start>         case CSH_SESSION_CANCEL_REQUEST : SessionCancelRequest (  )  ;  break ;  <end>
<start>     getRND ( temp ,  6 )  ;  <end>
<start>          <end>
<start>  <end>
<start>     return Status ;  <end>
<start> } <end>
<start> { <end>
<start> return TRUE ;  <end>
<start>     strncpy ( iotx_http_context->p_devinfo->device_secret ,  p_devinfo->device_secret ,  strlen ( p_devinfo->device_secret )  )  ;  <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>                         else { failCounter = 0 ;  } <end>
<start>                             if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  { stopCondition = STOP_BATTERY ;  break ;  } <end>
<start>             } <end>
<start> { <end>
<start>      <end>
<start> } <end>
<start>         Host: iot-as-http.cn-shanghai.aliyuncs.com <end>
<start> /* encrypt/decrypt in 4096 byte sectors */ <end>
<start>      <end>
<start> "Failed opening temporary file %s for writing: %s" ,  outpath ,  g_strerror ( err )  )  ;  <end>
<start> } <end>
<start>             turnOffLED ( 3 )  ;  <end>
<start>     AccelVerifyDeviceId (  )  ;  <end>
<start>     setenv ( "TZ" ,  "CST-8" ,  1 )  ;  <end>
<start> #include <string.h> <end>
<start>         HTTP_API_FREE ( httpc->header )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "New Card Regist" ,  16 ,  1 )  ;  <end>
<start>     return ECCRYPTO_SUCCESS ;  <end>
<start> } else if ( flagPot == 1 ) { <end>
<start> #define CYAN    0x07FF <end>
<start>     OLED_Refresh (  )  ;  <end>
<start>      <end>
<start> #define IOTX_SHA_METHOD                 "hmacsha1" <end>
<start> } <end>
<start>  <end>
<start>     { <end>
<start> char cardID[4] ;  <end>
<start>             break ;  <end>
<start>     switch ( readCmd )  <end>
<start> if  ( !res )  { <end>
<start>                     turnAllLEDOff (  )  ;  <end>
<start> return true ;  <end>
<start> { <end>
<start>                         updateFlag = TRUE ;  <end>
<start>   } <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>     printf ( "\r\nExecution completed with status %02X\r\n" ,  status )  ;  <end>
<start>  <end>
<start>     { <end>
<start>  <end>
<start>                 break ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start> LCD_display_text ( "Welcome Home  ,  " , 700 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Registing OK" ,  16 ,  0 )  ;  <end>
<start> } <end>
<start>     temp =  ( unsigned char* ) calloc ( 1 ,  SizeMessage+64 )  ;  <end>
<start>  <end>
<start> #include "fingerPrintReader.h" <end>
<start> PORTA ^= _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>         rt_mutex_release ( &bus->lock )  ;  <end>
<start>             printf ( "\nValidated public key is already in slot ,  invalidated the slot to update the new public key\r\n" )  ;  <end>
<start>                         } <end>
<start> writeQRCodeBuffer (  )  ;  <end>
<start>                     lastSampleTicks += STREAM_INTERVAL ;  <end>
<start> while  ( 1 ) { <end>
<start>     pvalue = NULL ;  <end>
<start>         USBDeviceTasks (  )  ;   <end>
<start>     iotx_http_message_param_t   msg_param ;  <end>
<start> block_offset =  ( uint8_t )  ( address & 0x0000000f )  ;  <end>
<start>     LED_OFF ;  <end>
<start> /* Allow enough space in output buffer for additional block */ <end>
<start>  <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>      <end>
<start>     msgs[1].flags = RT_I2C_RD | i2c_device->flags ;  <end>
<start> } <end>
<start>     static unsigned int LEDTimer ;  <end>
<start> } <end>
<start> { <end>
<start>              <end>
<start> if ( doorOpen == 0 ) { <end>
<start>  <end>
<start> #ifdef INFRA_MEM_STATS <end>
<start>     const char         *pub_key = NULL ;  <end>
<start>  <end>
<start>  <end>
<start> uint16_t CSH_GetUserFunds ( void )  <end>
<start> tweak_key[i] =  ( uint8_t ) value ;  <end>
<start>     http_info ( "get_http_authenticate_url is %s" ,  buf )  ;  <end>
<start>      <end>
<start>     rt_mutex_init ( &bus->lock ,  "i2c_bus_lock" ,  RT_IPC_FLAG_FIFO )  ;  <end>
<start> { <end>
<start> uint8_t tweak_value[16] ;  <end>
<start>  <end>
<start>      <end>
<start>         case CSH_END_SESSION            : EndSession (  )  ;            break ;  <end>
<start>      <end>
<start> opendoor (  )  ;  <end>
<start>  <end>
<start> else <end>
<start> static int curr_temp = 255 ;   <end>
<start>     msgs[1].len = 1 ;  <end>
<start>          <end>
<start>      <end>
<start>                           rt_uint32_t num )  <end>
<start> printf ( "test number = %u ,  address = 0x%08x ,  length = %d\n" ,  i ,   ( int ) address ,   ( int ) length )  ;  <end>
<start> os_timer_arm ( &mResetTimer ,  1000 ,  0 )  ;  <end>
<start>         MDB_Send ( malf_err[i] )  ;  <end>
<start>             status = !ATCA_SUCCESS ;  <end>
<start>         return ;  <end>
<start>      * for two uint8_t internal variables <end>
<start> printf ( "test number = %u ,  address = 0x%08x ,  length = %d\n" ,  i ,   ( int ) address ,   ( int ) length )  ;  <end>
<start>                           struct rt_i2c_msg msgs[] ,  <end>
<start> 0x0 , 0x7 , 0x87 , 0x80 , 0x0 , 0x7c , 0x0 , 0x0 ,  <end>
<start>         return ;   <end>
<start> 0x0 , 0xe , 0x1c , 0x78 , 0x3 , 0xc7 , 0x80 , 0x0 ,  <end>
<start>     } <end>
<start> #include "dhzc_web.h" <end>
<start> reportFailure (  )  ;  <end>
<start> { <end>
<start> void SessionCancelRequest ( void )  <end>
<start>         case IOTX_HTTP_AUTH_CHECK_ERROR: <end>
<start> static iotx_http_t *iotx_http_context_bak = NULL ;  <end>
<start>     uint8_t i ;  <end>
<start>  <end>
<start>      <end>
<start> void MDB_PollHandler ( void )  <end>
<start>     http_info ( "http response: \r\n\r\n%s\r\n" ,  httpc_data.response_buf )  ;  <end>
<start>                           rt_uint16_t addr ,  <end>
<start> PORTD|= ( 1<<0 )  ;   <end>
<start>   } <end>
<start>  <end>
<start>     SYS_Initialize  (  NULL  )  ;  <end>
<start>         POST /topic/${topic} HTTP/1.1 <end>
<start> plaintext[i] =  ( uint8_t ) value ;  <end>
<start>                      <end>
<start>      <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start> { <end>
<start>      <end>
<start>     msg.flags |= RT_I2C_RD ;  <end>
<start>     clear_words (  ( unsigned int* ) PublicKey ,  256/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start> { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start> { <end>
<start>  <end>
<start> 0x0 , 0xe , 0x38 , 0xe7 , 0x38 , 0x71 , 0xc0 , 0x0 ,  <end>
<start>     ESP_ERROR_CHECK ( nvs_flash_init (  )  )  ;  <end>
<start>              <end>
<start> int ever_saved ;  <end>
<start>  <end>
<start> uint8_t ciphertext[16] ;  <end>
<start>  <end>
<start>             { <end>
<start>     LED_SET ( LED_BLUE )  ;  <end>
<start> #define IOTX_HTTP_SIGN_SOURCE_LEN    ( 256 )  <end>
<start> } <end>
<start>     else <end>
<start>  <end>
<start> g_autoptr ( EVP_CIPHER_CTX )  ctx = NULL ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;   <end>
<start> } <end>
<start>     checksum += calc_checksum ( vend_data ,  4 )  ;  <end>
<start> } <end>
<start>                         delay ( 500 )  ;  <end>
<start>  <end>
<start> } <end>
<start>                                     OLED_Clear (  )  ;  <end>
<start>                 { <end>
<start> #if DEBUG_MODE == 1 <end>
<start>         case CSH_DISPLAY_REQUEST        : DisplayRequest (  )  ;        break ;   <end>
<start> reportSuccess (  )  ;  <end>
<start>         default: <end>
<start>  <end>
<start>         http_err ( "Send firmware message to server ( Http )  failed ,  ret = %d" ,  ret )  ;  <end>
<start>  <end>
<start>         if  (  ( USBGetDeviceState (  )  >= CONFIGURED_STATE )  &&  ( USBIsDeviceSuspended (  )  == FALSE )  )  <end>
<start> return ( keypad[row][2] )  ;  <end>
<start> else if  ( !strcmp ( buffer ,  "COUNT" )  )  <end>
<start>     MDB_Send ( CSH_CMD_OUT_OF_SEQUENCE | CSH_ACK )  ;  <end>
<start>         if  ( MDB_DataCount (  )  > 0 )  <end>
<start>         goto do_exit ;  <end>
<start>     inactive = 0 ;  <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start>         if  ( MDB_DataCount (  )  > 2 )  <end>
<start>      <end>
<start> { <end>
<start>         } <end>
<start>      <end>
<start> memset ( iv ,  0 ,  iv_size )  ;  <end>
<start> goto out ;  <end>
<start>                     } <end>
<start> { <end>
<start>         } <end>
<start> } <end>
<start> if ( system_get_rst_info (  ) ->reason != REASON_EXT_SYS_RST )  { <end>
<start> } <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start>     atca_nonce_in_out_t nonce_params ;  <end>
<start>     { <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "Unknow Error!" ,  16 ,  1 )  ;  <end>
<start>     int                 response_code = 0 ;  <end>
<start> _delay_ms ( 500 )  ;  <end>
<start>     } <end>
<start> xexDecrypt ( plaintext ,  ciphertext ,  n ,  1 )  ;  <end>
<start>     } <end>
<start> { <end>
<start> { <end>
<start>                                       IOTX_SHA_METHOD ,  <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_FAILURE ;  <end>
<start>                 unsigned long now = RtcTicks (  )  ;  <end>
<start> #endif <end>
<start> } <end>
<start>  <end>
<start> #include <stdbool.h>        <end>
<start>  <end>
<start>         } <end>
<start> memset ( output ,  '*' ,  sizeof ( output ) -1 )  ;  <end>
<start> } <end>
<start>  <end>
<start>      */ <end>
<start>             http_info ( "http time response: \r\n\r\n%s" ,  timestamp )  ;  <end>
<start>  <end>
<start>                 else                    { c0 = LED_OFF ;  c1 = LED_YELLOW ;  }       <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start>                     } <end>
<start>                + csh_config.scaleFactor <end>
<start>     if  ( NULL != iotx_http_context_bak )  { <end>
<start> { <end>
<start>     uint8_t vend_data[3] ;  <end>
<start>   if ( fingerprintID == 1 )  <end>
<start>                      <end>
<start> PORTC ^= _BV ( 0 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Verify OK" ,  16 ,  0 )  ;  <end>
<start> { <end>
<start> #include "qcloud_iot_export.h" <end>
<start>  <end>
<start> #include "hal/i2c/i2c_dev.h" <end>
<start> } <end>
<start>         reader_data[i] =  ( uint8_t )  ( reader_temp & 0x00FF )  ;   <end>
<start>     if  ( NULL == fmt )  { <end>
<start> } <end>
<start>         return ;  <end>
<start>     ret = 0 ;  <end>
<start>  <end>
<start>         status = public_key_rotation ( cfg )  ;  <end>
<start>     sntp_setservername ( 1 ,  "cn.pool.ntp.org" )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                 { <end>
<start> NOT_STARTED_FILE_OPEN ,         <end>
<start>  <end>
<start>     display.drawBitmap ( 30 , 35 , icon , 60 , 60 , GREEN )  ;  <end>
<start>  <end>
<start>         goto do_exit ;  <end>
<start>     if  ( httpc != NULL && httpc->header )  { <end>
<start>  <end>
<start>      <end>
<start> fgets ( buffer ,  7 ,  f )  ;  <end>
<start>     uint16_t vend_temp ;  <end>
<start> } <end>
<start> int j ;  <end>
<start> { <end>
<start>     } <end>
<start> } <end>
<start> { <end>
<start> row = SECOND_ROW ;  <end>
<start>  <end>
<start>         USBProcessIO (  )  ;  <end>
<start> /* assert expected input key and iv size */ <end>
<start>     char* at = "AT\r\n" ;  <end>
<start>      <end>
<start> cleanup: <end>
<start> if ( counter.resetCounter == RESET_NUM )  { <end>
<start>     httpc->header = HTTP_API_MALLOC ( len + 1 )  ;  <end>
<start>     } <end>
<start>  <end>
<start> } <end>
<start>                 if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  { stopCondition = NOT_STARTED_WAIT_BATTERY ;  break ;  } <end>
<start>  <end>
<start> unsigned int resetCounter ;  <end>
<start>  <end>
<start>     msg.len = count ;  <end>
<start> { <end>
<start> rt_err_t rt_i2c_bus_attach_device ( struct rt_i2c_device* device ,  <end>
<start>     response_code = atoi ( pvalue )  ;  <end>
<start>     return vend_amount ;  <end>
<start>  <end>
<start> #endif <end>
<start> Status = ECCRYPTO_ERROR_NO_MEMORY ;  <end>
<start>     if  ( status.attached > 0 )  <end>
<start> #include <stdlib.h> <end>
<start> } <end>
<start>     } <end>
<start> #include "MDB.h" <end>
<start>     } <end>
<start>                                       timestamp <end>
<start>                     delay_10ms ( 200 )  ;  <end>
<start> { <end>
<start>     if  ( Key_Scan ( GPIOB ,  GPIO_Pin_12 )  == KEY_ON )   <end>
<start>     checksum += calc_checksum ( vend_data ,  4 )  ;  <end>
<start>     MDB_Send ( vend_amount_H )  ;         <end>
<start>  <end>
<start> } <end>
<start> while  ( 1 )  <end>
<start>         csh_state = CSH_S_SESSION_IDLE ;  <end>
<start>      <end>
<start>                 for  ( i = 0 ;  i < 6 ;  i++ )  { <end>
<start> extern write_handler_t writeHandler ;  <end>
<start>  <end>
<start>  <end>
<start>     beepOneSecOn (  )  ;  <end>
<start>  <end>
<start>                 break ;  <end>
<start>                              rt_uint16_t flags ,  <end>
<start> reportFailure (  )  ;  <end>
<start> printf ( "\nFirst 16 bytes of ciphertext: " )  ;  <end>
<start>     if  ( 0 == iotx_http_context->is_authed )  { <end>
<start> dhsender_queue_init (  )  ;  <end>
<start> /* WiFi router password */ <end>
<start>             else if  ( !LoggerStart ( filename )  )  <end>
<start>  <end>
<start>      *          Scale factor      -- 100 <end>
<start> }else{ <end>
<start>     uint8_t checksum = VMC_EXPANSION + VMC_EXPANSION_DIAGNOSTICS ;  <end>
<start>  <end>
<start>  <end>
<start> #ifdef USE_GYRO <end>
<start>             MDB_Send ( CSH_ACK )  ;  <end>
<start>     user_funds = new_funds ;  <end>
<start> #include "common.h" <end>
<start>  <end>
<start> PORTD ^= _BV ( 5 )  ;  <end>
<start>  <end>
<start>     } <end>
<start>                 { <end>
<start> reportSuccess (  )  ;  <end>
<start>  <end>
<start>          <end>
<start> op1[i] |= last_bit ;  <end>
<start>                 sendFPRCommand ( FPR_IS_PRESSED ,  ZERO )  ;  <end>
<start>     } <end>
<start>      <end>
<start>     while  ( cnt++ < wait_cnt )  { <end>
<start>     ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN ;  <end>
<start> } <end>
<start>      <end>
<start>                         WifiStart ( CLIENT_MODE )  ;  <end>
<start>  <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Waiting For Card" ,  16 ,  1 )  ;  <end>
<start> { <end>
<start>  <end>
<start>          ;  <end>
<start> doorOpen = 0 ;  <end>
<start> break ;  <end>
<start>     subtract_mod_order (  ( digit_t* ) r ,  S ,  S )  ;  <end>
<start>  <end>
<start>     MDB_Send ( csh_config.decimalPlaces )  ;  <end>
<start> void ConfigInfo ( void )  <end>
<start>             tempint[i * 2] -= 6 ;  <end>
<start>         HTTP_API_FREE ( rsp_payload )  ;  <end>
<start> } <end>
<start>     ret = rt_i2c_transfer ( i2c_device->bus ,  i2c_device->slave_addr ,  msgs ,  2 )  ;  <end>
<start>     { <end>
<start>  <end>
<start> void DiagnosticResponse ( void )  <end>
<start>      <end>
<start> exit ( 1 )  ;  <end>
<start>   Serial.begin ( 9600 )  ;  <end>
<start>         for  ( i = 0 ;  i < 5 * 3 ;  i++ )  { LED_SET ( LED_MAGENTA )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_CYAN )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_YELLOW )  ;  DelayMs ( 111 )  ;  } <end>
<start> #else <end>
<start> #include "wallet.h" <end>
<start>  <end>
<start>     } <end>
<start>      <end>
<start> printf ( "Final run ,  address = 0x%08x ,  length = 128\n" ,  i )  ;  <end>
<start>  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>  <end>
<start> TCCR1B = _BV ( WGM12 )  | _BV ( WGM13 )  | _BV ( CS10 )  | _BV ( CS11 )  ;  <end>
<start>  <end>
<start>         printf ( "check_device_type_in_cfg (  )  failed with ret=0x%08X\r\n" ,  status )  ;  <end>
<start>  <end>
<start>  <end>
<start> aesDecrypt ( out ,  buffer ,  expanded_key )  ;  <end>
<start> #define ALARM_SOUND 6 <end>
<start>  <end>
<start> { <end>
<start>      */   <end>
<start>      <end>
<start> lcd_puts ( "Unesite lozinku!" )  ;  <end>
<start>         vend_data[i] =  ( uint8_t )  ( vend_temp & 0x00FF )  ;   <end>
<start>                 AccelStartup ( settings.sampleRate )  ;  <end>
<start> #include "Peripherals/Gyro.h" <end>
<start>  <end>
<start> 0x0 , 0x0 , 0xfd , 0xff , 0x81 , 0xf0 , 0x0 , 0x0 ,  <end>
<start>                                  <end>
<start>      <end>
<start> #include "http_wrapper.h" <end>
<start>          <end>
<start>  <end>
<start> { <end>
<start>  <end>
<start> } <end>
<start> return r ;  <end>
<start>     FtlStartup (  )  ;                         <end>
<start>     "{" \ <end>
<start> } <end>
<start> STOP_USB                    = 7 ,      <end>
<start>     buffer[0] = reg ;  <end>
<start>                 #define STREAM_INTERVAL  ( 0x10000UL / STREAM_RATE )  <end>
<start> ECCRYPTO_STATUS SchnorrQ_KeyGeneration ( const unsigned char* SecretKey ,  unsigned char* PublicKey )  <end>
<start>          <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_set_config ( ESP_IF_WIFI_STA ,  &wifi_config )  )  ;  <end>
<start>         device->parent.user_data = user_data ;  <end>
<start>         } <end>
<start>                       IOTX_HTTP_HEADER_KEEPALIVE_STR )  + strlen ( IOTX_HTTP_HEADER_END_STR )  ;  <end>
<start> uint8_t CSH_GetDeviceState ( void )  <end>
<start> #include "dhterminal.h" <end>
<start> } <end>
<start> u8 modeFlag = 0 ;   <end>
<start>     OLED_ShowString ( 0 ,  16 ,   ( u8* ) WIFI_SSID ,  16 ,  1 )  ;  <end>
<start>     struct tm timeinfo    = {0} ;  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 2 ,  1 )  ;  <end>
<start> LED_SET ( LED_YELLOW )  ;  DelayMs ( 50 )  ;   <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start> fclose ( outfile )  ;  <end>
<start>  <end>
<start>     #define HTTP_API_MALLOC ( size )                LITE_malloc ( size ,  MEM_MAGIC ,  "http.api" )  <end>
<start>  <end>
<start>                 OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>                             action = TIMEOUT_LOCK ;  <end>
<start>    <end>
<start>  <end>
<start>    if ( fingerprintID == 2 )  <end>
<start> { <end>
<start> ADMUX = _BV ( REFS0 )  ;  <end>
<start> for  ( i = 0 ;  i < 11 ;  i++ )  <end>
<start>  <end>
<start>      <end>
<start>         } <end>
<start> uint16_t CSH_GetItemCost ( void )  <end>
<start>     checksum =  (  CSH_READER_CONFIG_INFO <end>
<start>     uint8_t rand_out[ATCA_KEY_SIZE] ;  <end>
<start>  <end>
<start> { <end>
<start> case FLASH_SIZE_16M_MAP_1024_1024: <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start>  <end>
<start> reportFailure (  )  ;  <end>
<start>  <end>
<start>     OLED_ShowString ( 0 ,  0 ,  "Welcome!" ,  16 ,  1 )  ;  <end>
<start>         { <end>
<start>    <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>         http_err ( "token is out of size" )  ;  <end>
<start> static int flagWrongPass = 0 ;  <end>
<start> guint8 iv[16] ;  <end>
<start>  <end>
<start>      <end>
<start> } <end>
<start>     for  ( i = 0 ;  i < arr_size ;  ++i )  <end>
<start>             const char *line = _user_gets (  )  ;  <end>
<start>  <end>
<start>     Status = ecc_mul_double (  ( digit_t* )  ( Signature+32 )  ,  A ,   ( digit_t* ) h ,  A )  ;        <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_init ( &cfg )  )  ;  <end>
<start> #include <c_types.h> <end>
<start>  <end>
<start> if  (  ( address + length )  < address )  <end>
<start>  <end>
<start> if  ( is_encrypt )  <end>
<start>     #ifdef USB_INTERRUPT <end>
<start>     csh_state = new_device_state ;  <end>
<start> } <end>
<start>     msgs[0].buf = &reg ;  <end>
<start>  <end>
<start>   displayLockScreen (  )  ;   <end>
<start>                         } <end>
<start>     i2c_dbg ( "I2C bus [%s] registered\n" ,  bus_name )  ;  <end>
<start>     "}" <end>
<start>         http_err ( "Invalid argument: pInitParams or device_info = NULL" )  ;  <end>
<start>     strcat ( at_cwjap ,  "AT+CWJAP=\"" )  ;  <end>
<start> if ( doorOpen == 1 ) { <end>
<start> #ifndef CONFIG_WIFI_CONFIG_ENABLED <end>
<start> xexEncryptInternal ( & ( compare[i] )  ,  & ( plaintext[i] )  ,  tweak_value ,   ( uint8_t )  ( i >> 4 )  ,  tweak_key ,  encrypt_key )  ;  <end>
<start>  <end>
<start> int ret ;  <end>
<start>         HTTP_API_FREE ( iotx_http_context->httpc )  ;  <end>
<start>     encode ( P ,  PublicKey )  ;                 <end>
<start> const char confirm = 'A' ;  <end>
<start>     AdcSampleWait (  )  ;  <end>
<start> void TimedTasks ( void )  ;  <end>
<start>         body: ${your_data} <end>
<start> op1[0] =  ( uint8_t )  ( op1[0] ^  ( 0x87 & last_bit )  )  ;  <end>
<start>             else <end>
<start>  <end>
<start>                         codeFlag = 0 ;  <end>
<start>                        IOTX_SHA_METHOD ,  <end>
<start> if ( last_temp == 255 ||  ( curr_temp-last_temp )   )  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y ,  1 )  ;  <end>
<start> extern ATCAIfaceCfg atecc608_0_init_data ;  <end>
<start>     delay_ms ( 100 )  ;   <end>
<start> #include "event.h" <end>
<start>     char               *pvalue = NULL ;  <end>
<start>     begin_session_counter++ ;  <end>
<start> static void xexEnDecrypt ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq ,  uint8_t *tweak_key ,  uint8_t *encrypt_key ,  bool is_decrypt )  <end>
<start> reset_counter ( 0 )  ;  <end>
<start>  <end>
<start> _delay_ms ( 125 )  ;  <end>
<start>      <end>
<start>                         } <end>
<start> #include <stdlib.h> <end>
<start>     PeripheralID (  )  ;  <end>
<start> { <end>
<start>  <end>
<start> #include <string.h> <end>
<start> } <end>
<start> #include <Adafruit_GFX.h> <end>
<start> uint8_t ciphertext[16] ;  <end>
<start>         { <end>
<start> { <end>
<start> {  <end>
<start>     ATCA_STATUS status ;  <end>
<start> if  ( is_decrypt )  <end>
<start> #include "FourQ_params.h" <end>
<start>                 saveWifiInfo (  )  ;  <end>
<start>  <end>
<start>                 relay_off (  )  ;  <end>
<start>    <end>
<start>  <end>
<start>     subcomm =  ( uint8_t )  ( subcomm_temp & 0x00FF )  ;   <end>
<start>         return ret ;  <end>
<start>      ( void ) response_message ;  <end>
<start>      * VMC_VEND command  ( 0x113 )  after I answer it with a single BEGIN SESSION Poll Reply <end>
<start>  <end>
<start> NonVolatileReturn encryptedNonVolatileRead ( uint8_t *data ,  NVPartitions partition ,  uint32_t address ,  uint32_t length )  <end>
<start>      <end>
<start>     uint8_t vend_amount_L =  ( uint8_t )  ( vend_amount &  0x00FF )  ;  <end>
<start>     if  ( !pvalue )  { <end>
<start> } <end>
<start> } <end>
<start>     utils_hmac_sha1 ( p_msg ,  strlen ( p_msg )  ,  sign ,  p_device_secret ,  strlen ( p_device_secret )  )  ;  <end>
<start>     } ;  <end>
<start> } <end>
<start>  <end>
<start>     encode ( R ,  Signature )  ;                     <end>
<start>                     sendFPRCommand ( FPR_DELETE_ALL ,  ZERO )  ;  <end>
<start>      * I need this variable because my VMC doesn't want to send a <end>
<start>         HTTP_API_FREE ( iotx_http_context->p_auth_token )  ;  <end>
<start>                 static unsigned long lastSampleTicks = 0 ;  <end>
<start>                                     strcat (  ( char* ) sendBuff ,   ( char* ) cardIDChar )  ;  <end>
<start> { <end>
<start> } <end>
<start>         memset ( &nonce_params ,  0 ,  sizeof ( nonce_params )  )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>  <end>
<start>     char                timestamp[14] = {0} ;  <end>
<start>     memmove ( temp+32 ,  PublicKey ,  32 )  ;  <end>
<start>     rt_size_t ret ;  <end>
<start>     bus = rt_device_find ( bus_name )  ;  <end>
<start>  <end>
<start>         MDB_Read ( &vmc_temp )  ;  <end>
<start>   if  ( p != FINGERPRINT_OK )   return -1 ;  <end>
<start> LCD_set_Cursor ( 1 , 0 )  ;  <end>
<start> NOT_STARTED_WAIT_BATTERY    = 9 ,      <end>
<start>      * which makes calculations easier to understand. <end>
<start> { <end>
<start> LCD_set_Cursor ( 1 , 0 )  ;  <end>
<start> dhzc_dnsd_init (  )  ;  <end>
<start> return false ;  <end>
<start>  <end>
<start>         sign_params.key_config =  ( config[96 + rotating_key_slot * 2] | config[97 + rotating_key_slot * 2] << 8 )  ;  <end>
<start>                     if  ( USB_BUS_SENSE )  { stopCondition = NOT_STARTED_WAIT_USB ;  restart = 1 ;  break ;  } <end>
<start> #define PASS_LENGHT 4 <end>
<start>         if  (  ( status = atcah_sign_internal_msg ( ATECC608A ,  &sign_params )  )  != ATCA_SUCCESS )  <end>
<start> #include "FourQ_internal.h" <end>
<start> uint32_t block_start ;  <end>
<start>  <end>
<start>                         GyroSingleSample ( &gyroSample )  ;  <end>
<start> DDRD |= _BV ( 5 )  ;   <end>
<start> if  ( usb_write_length ( buffer ,  len )  < len )  <end>
<start>     char* at_cifsr = "AT+CIFSR\r\n" ;  <end>
<start> what_storage_should_be[i] =  ( uint8_t ) rand (  )  ;  <end>
<start>                 if  ( lastSampleTicks == 0 )  { lastSampleTicks = now ;  } <end>
<start> } <end>
<start>         } ;  break ;  <end>
<start> DDRD  |=  ( 1<<6 )  ;   <end>
<start>  <end>
<start> pot2 = VALUE_POT ;  <end>
<start>      <end>
<start>      <end>
<start>                 break ;  <end>
<start>             "messageId": 892687627916247040 ,  <end>
<start>     memset ( at_cwjap ,  0 ,  sizeof ( at_cwjap )  )  ;  <end>
<start> { <end>
<start>                 LoggerClear (  )  ;  <end>
<start>  <end>
<start>     /* <end>
<start>     switch  ( csh_state )  <end>
<start> uint8_t tweak_key[16] ;  <end>
<start>     } <end>
<start>     malf_err[1] = csh_error_code ;  <end>
<start> pass = keyfind (  )  ;  <end>
<start>  <end>
<start> 0x0 , 0xe , 0x38 , 0xe3 , 0x98 , 0xe3 , 0xc0 , 0x0 ,  <end>
<start>  <end>
<start> entered_password[i]=Get_Key_pressed (  )  ;  <end>
<start> static const int          CONNECTED_BIT = BIT0 ;  <end>
<start>         default : break ;  <end>
<start> #if 0 <end>
<start> #define IOTX_HTTP_AUTH_STR              "auth" <end>
<start>                 if  ( status.initialBattery != 0 && status.initialBattery < BATT_CHARGE_MID_USB )  <end>
<start>     OLED_ColorTurn ( 0 )  ;   <end>
<start>     if  ( CryptoHashFunction ( temp+32 ,  SizeMessage+32 ,  r )  != 0 )  {    <end>
<start>  <end>
<start> if (  ( PINB & _BV ( PB0 )  )  == 0 ) { <end>
<start>      <end>
<start>         iotx_http_context->auth_token_len = 0 ;  <end>
<start>  <end>
<start> printBigEndian16 ( tweak_key )  ;  <end>
<start>                + vend_amount_L  )  ;  <end>
<start> #include "Logger.h" <end>
<start>  <end>
<start>                     break ;  <end>
<start>                  <end>
<start> OLED_ShowString ( 65 ,  0 ,  "Welcome!" ,  16 ,  1 )  ;  <end>
<start>                         turnOnWifiChip ( FALSE )  ;  <end>
<start>  <end>
<start> #if defined ( __XC32__ )  <end>
<start>  <end>
<start> if  ( isHighSpeed )  { CLOCK_PLL (  )  ; } <end>
<start>     } <end>
<start>         http_err ( "Allocate HTTP rsp_payload buf failed!" )  ;  <end>
<start>     iotx_calc_sign ( iotx_http_context->p_devinfo->device_secret ,  p_msg_unsign ,  sign )  ;  <end>
<start> { <end>
<start> void CmdOutOfSequence ( void )  <end>
<start>     char               *rsp_payload = NULL ;  <end>
<start>  <end>
<start> flagPot = 1 ;  <end>
<start> { <end>
<start>                 } <end>
<start> { <end>
<start>         if  (  ( status = atcab_read_zone ( ATCA_ZONE_DATA ,  rotating_key_slot ,  0 ,  0 ,  valid_buf ,  4 )  )  != ATCA_SUCCESS )  <end>
<start>  <end>
<start> { <end>
<start>   * Use with caution  ( because of pointer arithmetics )  <end>
<start> uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set ( void )  { <end>
<start>                     SystemPwrSave ( WAKE_ON_RTC|WAKE_ON_WDT|WAKE_ON_USB|WAKE_ON_ADXL1|WAKE_ON_GYRO2|WAKE_ON_TIMER1|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE )  ;  <end>
<start>             status.batteryFull++ ;  <end>
<start> int i ;  <end>
<start> Nop (  )  ;  <end>
<start>  <end>
<start> { <end>
<start>  <end>
<start>     board_init (  )  ;  <end>
<start> u8 securityCode[7] ;  <end>
<start> void IOT_HTTP_Disconnect ( void *handle )  <end>
<start>  <end>
<start> clearEncryptionKey (  )  ;  <end>
<start>                 .password = TEST_WIFI_PASSWORD ,  <end>
<start> } <end>
<start>  <end>
<start> { <end>
<start>                     ws2812bSetAll ( RED )  ;  <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> else <end>
<start>     #elif defined ( __PIC24H__ )  <end>
<start> 0x0 , 0x7 , 0xc0 , 0x7f , 0x83 , 0x8e , 0x0 , 0x0 ,  <end>
<start>     #endif <end>
<start> } <end>
<start> if ( column != 0x0F ) { <end>
<start>                     rc++ ;  <end>
<start> dhdebug ( "Initialization completed" )  ;  <end>
<start>             break ;  <end>
<start>  <end>
<start> } <end>
<start>         { <end>
<start>             break ;  <end>
<start> 0x0 , 0x0 , 0x0 , 0x1f , 0xfc , 0x0 , 0x0 , 0x0 ,  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 2 ,  0 )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start>      <end>
<start>     httpc_data.post_content_type = "application/octet-stream" ;  <end>
<start> { <end>
<start> mSpecialMode = 1 ;  <end>
<start> lcd_clrscr (  )  ;  <end>
<start>     /* <end>
<start>     if  ( pvalue )  { <end>
<start>      <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>             { <end>
<start>         goto do_exit_pre ;  <end>
<start> exit ( 0 )  ;  <end>
<start>  <end>
<start>     return ret ;  <end>
<start>     uint8_t checksum = 0 ;  <end>
<start> STOP_DISK_FULL              = 2 ,      <end>
<start> encrypt_key[i] =  ( uint8_t ) value ;  <end>
<start>                              <end>
<start>     } <end>
<start> #include <Arduino.h>  <end>
<start>  <end>
<start>                  <end>
<start> { <end>
<start>                     } <end>
<start>  <end>
<start> #include <unistd.h> <end>
<start> LCD_display_text ( "  go away !! " , 700 )  ;  <end>
<start> } <end>
<start> static int buzzerCounter ;  <end>
<start>         #ifdef IGNORE_UNRECOGNIZED_PERIPHERALS <end>
<start>         case IOTX_HTTP_REQUEST_TOO_MANY_ERROR: <end>
<start>  <end>
<start>         if  ( status.batteryFull )  { LED_SET ( LED_GREEN )  ;  }        <end>
<start>     } <end>
<start>     MDB_Send ( user_funds_L )  ;        <end>
<start>     IOTX_HTTP_HEADER_END_STR <end>
<start>     while  ( 1 )  <end>
<start>  <end>
<start>      * Otherwise ,  CSH_VEND_DENIED <end>
<start>     ws2812bInit (  )  ;  <end>
<start> } <end>
<start>     return NULL ;  <end>
<start>     for  ( i = 0 ;  i < 2 ;  ++i )  <end>
<start>     } <end>
<start> void enter_the_door (  )  <end>
<start> #define CONFIRM_SOUND 2 <end>
<start>     uint8_t checksum = VMC_READER ;  <end>
<start>     GyroVerifyDeviceId (  )  ;  <end>
<start>     digit_t* H =  ( digit_t* ) h ;  <end>
<start>     iotx_http_t *iotx_http_context ;  <end>
<start>                     OLED_ShowString ( 0 ,  16 ,  "Opening Now!" ,  16 ,  1 )  ;  <end>
<start>         http_err ( "messageId: NULL" )  ;  <end>
<start> void RunAttached ( void )  <end>
<start> char buffer[100] ;  <end>
<start>         if  (  ( status = atcab_read_pubkey ( rotating_key_slot ,  public_key )  )  != ATCA_SUCCESS )  <end>
<start>             status.actionCountdown-- ;  <end>
<start>  <end>
<start> { <end>
<start> { <end>
<start>     if  ( RtcTimerTasks (  )  )  <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start>  <end>
<start>     0x00 ,  <end>
<start>             if  ( status.stream )  <end>
<start>         goto cleanup ;  <end>
<start> if  ( memcmp ( & ( what_storage_should_be[i] )  ,  buffer ,  128 )  )  <end>
<start> #include <os_type.h> <end>
<start>     uint8_t public_key[64] ;  <end>
<start>         http_err ( "Init twice not allowed ,  please deinit first" )  ;  <end>
<start> pot1 = POT_ZERO ;  <end>
<start> int IOT_HTTP_DeviceNameAuth ( void *handle )  <end>
<start>         extern const char *iotx_ca_crt ;  <end>
<start>                 } <end>
<start>     bool wifi_connected = false ;  <end>
<start> STOP_BATTERY ,                  <end>
<start>  <end>
<start> { <end>
<start>  <end>
<start>     } <end>
<start> g_return_val_if_fail ( inpath ,  FALSE )  ;  <end>
<start>      <end>
<start> ISR ( TIMER0_COMP_vect ) { <end>
<start>     "\"version\":\"%s\" ,  \"clientId\":\"%s\" , " \ <end>
<start>     return status ;  <end>
<start> lcd_puts ( &output[i] )  ;  <end>
<start>  <end>
<start>         return NULL ;  <end>
<start>     } while  ( 0 )  ;  <end>
<start>             iotx_http_context->is_authed = IOT_FALSE ;  <end>
<start>  <end>
<start>  <end>
<start>     { <end>
<start>   delay ( 50 )  ;  <end>
<start>                         } <end>
<start>             break ;  <end>
<start>                  <end>
<start>   display.setTextColor ( WHITE )  ;   <end>
<start>                        timestamp <end>
<start>      <end>
<start>         lastTime = rtcTicksSeconds ;  <end>
<start>  <end>
<start> if  ( validate )  <end>
<start>  <end>
<start>     csh_poll_state = new_poll_state ;  <end>
<start>         CLOCK_INTOSC (  )  ;   <end>
<start>  <end>
<start>     va_start ( args ,  fmt )  ;  <end>
<start> lcd_puts ( "Sef zatvoren!" )  ;  <end>
<start>     InitApp (  )  ;   <end>
<start> } <end>
<start> if  ( r != 0 )  <end>
<start>      <end>
<start>      <end>
<start> { <end>
<start>     uint16_t temp ;  <end>
<start> 0x0 , 0x3 , 0xf0 , 0x0 , 0x7 , 0x1c , 0x0 , 0x0 ,  <end>
<start>         goto cleanup ;  <end>
<start> if (  ( adcConversion<= ADC_PLUS && adcConversion >= ADC_MINUS )  && flagPot == 0 ) { <end>
<start>     0x02 ,   <end>
<start> static void doubleInGF ( uint8_t *op1 )  <end>
<start>     } <end>
<start>         } <end>
<start>         j = 0 ;  <end>
<start> memset ( nv_storage_encrypt_key ,  0xff ,  16 )  ;  <end>
<start> #include <Compiler.h> <end>
<start> { <end>
<start>     httpclient_data_t   httpc_data = {0} ;  <end>
<start> system_rtc_mem_read ( 64 ,  &counter ,  sizeof ( counter )  )  ;  <end>
<start>                     action = DEFAULT ;  <end>
<start> bool is_encrypt ;  <end>
<start>         } <end>
<start>     if  ( NULL != iotx_http_context->p_devinfo )  { <end>
<start>  <end>
<start> #endif <end>
<start>     iotx_http_context->auth_token_len = 0 ;  <end>
<start>                      <end>
<start>     cfg = &atecc608_0_init_data ;  <end>
<start> void __attribute__ (  ( interrupt ,  shadow ,  auto_psv )  )  _CNInterrupt ( void )  <end>
<start> #include "debug.h" <end>
<start>      <end>
<start>     msg_param.response_payload_len = 1024 ;  <end>
<start> } <end>
<start>             vmc_config.featureLevel   = vmc_data[1] ;  <end>
<start>             { <end>
<start>     esp_wifi_initialise (  )  ;  <end>
<start> int main ( void ) { <end>
<start>      * As a coin acceptor handles coins with minimum value of 1 RUB ,  <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start> #include "esp_wifi.h" <end>
<start>      <end>
<start>                                 if  ( modeFlag == 0 )  { <end>
<start>                 reqParseState = DEFAULT ;  <end>
<start>         if  ( status.actionCountdown )  <end>
<start>     OLED_Clear (  )  ;  <end>
<start>     uint8_t user_funds_L =  ( uint8_t )  ( funds &  0x00FF )  ;  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_start (  )  )  ;  <end>
<start>         begin_session_counter = 0 ;  <end>
<start>     MDB_Send ( csh_config.maxResponseTime )  ;  <end>
<start> r = nonVolatileRead ( ciphertext ,  partition ,  block_start ,  16 )  ;  <end>
<start> #include <SoftwareSerial.h> <end>
<start>         if  ( validate )  <end>
<start>  <end>
<start>                             FPRState = PARSE_FPR_MSG ;  <end>
<start> for ( int i =0  ;  i<4  ;  i++ )  <end>
<start> #define KEY_DDRDDRB <end>
<start>  <end>
<start>  <end>
<start>     OLED_Clear (  )  ;  <end>
<start>                     { <end>
<start> if ( column != 0x0F ) { <end>
<start> uint8_t i ;  <end>
<start> memcpy ( nv_storage_tweak_key ,  & ( in[16] )  ,  16 )  ;  <end>
<start> fgets ( buffer ,  6 ,  f )  ;  <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start>             { <end>
<start> guint64 iv_val ;  <end>
<start> break ;  <end>
<start>                             { <end>
<start> { <end>
<start>  <end>
<start>     RtcInterruptOn ( 0 )  ;    <end>
<start>     return Status ;  <end>
<start>     checksum =  (  CSH_BEGIN_SESSION <end>
<start>      <end>
<start>     display.fillScreen ( BLACK )  ;  <end>
<start>  <end>
<start> void Disable ( void )  <end>
<start> } <end>
<start> #define IOTX_HTTP_AUTH_DEVICENAME_STR   \ <end>
<start> KEY_PRT = 0xBF ;  <end>
<start>     MDB_Send ( CSH_SESSION_CANCEL_REQUEST | CSH_ACK )  ;   <end>
<start>         OLED_Refresh (  )  ;  <end>
<start> uint8_t encrypt_key[16] ;  <end>
<start> #include "infra_report.h" <end>
<start>     /* <end>
<start>     iotx_device_info_t *p_devinfo ;  <end>
<start> #include <stdlib.h> <end>
<start> for  ( i = 0 ;  i < 5 * 3 ;  i++ )  { LED_SET ( LED_RED )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_GREEN )  ;  DelayMs ( 111 )  ;  } <end>
<start>     return csh_state ;  <end>
<start>         goto cleanup ;                              <end>
<start> } <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>         return ;   <end>
<start>  <end>
<start>     } <end>
<start>     } <end>
<start> GQuark r_crypt_error_quark ( void )  <end>
<start>     msgs.len = 2 ;  <end>
<start> { <end>
<start>         http_err ( "httpclient_recv_response error ,  ret = %d" ,  ret )  ;  <end>
<start> 0x0 , 0x3 , 0xc7 , 0xc3 , 0xe1 , 0xc3 , 0x80 , 0x0 ,  <end>
<start>                 case ENROLL: <end>
<start> NonVolatileReturn r ;  <end>
<start>  <end>
<start>                 break ;  <end>
<start>     if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  <end>
<start>             break ;  <end>
<start> dhconnector_init (  )  ;  <end>
<start>  <end>
<start>             goto cleanup ;     <end>
<start>                 ws2812bSetAll ( RED )  ;  <end>
<start>     msgs[0].len = 1 ;  <end>
<start>  <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_SUCCESS ;  <end>
<start>         http_err ( "IOT_HTTP_SendMessage topic_path NULL!" )  ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start>         case VMC_VEND_REQUEST : VendRequest (  )  ;          break ;  <end>
<start>  <end>
<start>  <end>
<start>     #define CONFIG_HTTP_AUTH_TIMEOUT             ( 5 * 1000 )  <end>
<start>             { <end>
<start> RESET_COUNTER counter ;  <end>
<start> uint8_t expanded_key[EXPANDED_KEY_SIZE] ;  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start> } <end>
<start> static uint8_t nv_storage_encrypt_key[16] ;  <end>
<start>    <end>
<start> f = fopen ( filename ,  "r" )  ;  <end>
<start>         extern const char *iotx_ca_crt ;  <end>
<start>     unsigned int i ;  <end>
<start> return r ;  <end>
