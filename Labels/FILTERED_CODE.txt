<start>  <end>
<start>  <end>
<start> #include <Compiler.h> <end>
<start> #include <TimeDelay.h> <end>
<start> #include "HardwareProfile.h" <end>
<start> #include "Peripherals/Nand.h" <end>
<start> #include "Peripherals/Accel.h" <end>
<start> #ifdef USE_GYRO <end>
<start> #include "Peripherals/Gyro.h" <end>
<start> #endif <end>
<start> #include "Peripherals/Rtc.h" <end>
<start> #include "USB/USB.h" <end>
<start> #include "USB/usb_function_msd.h" <end>
<start> #include "USB/usb_function_cdc.h" <end>
<start> #include "MDD File System/FSIO.h" <end>
<start> #include "Usb/USB_CDC_MSD.h" <end>
<start> #include "Ftl/FsFtl.h" <end>
<start> #include "Utils/FsUtils.h" <end>
<start> #include "Utils/Fifo.h" <end>
<start> #include "Utils/Util.h" <end>
<start> #include "Peripherals/Analog.h" <end>
<start> #include "Settings.h" <end>
<start> #include "Logger.h" <end>
<start>  <end>
<start> #include "AX3 SelfTest.h" <end>
<start>  <end>
<start>  <end>
<start> void RunAttached ( void )  ;  <end>
<start> void RunLogging ( void )  ;  <end>
<start> void TimedTasks ( void )  ;  <end>
<start> void LedTasks ( void )  ;  <end>
<start> void RunTestSequence ( void )  ;  <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _DefaultInterrupt ( void )  <end>
<start> { <end>
<start>  static unsigned int INTCON1val ;  <end>
<start> LED_SET ( LED_MAGENTA )  ;  <end>
<start> INTCON1val = INTCON1 ;  <end>
<start> Nop (  )  ;  <end>
<start> Nop (  )  ;  <end>
<start> Nop (  )  ;  <end>
<start> Nop (  )  ;  <end>
<start> INTCON1 = 0 ;  <end>
<start>     Reset (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _RTCCInterrupt ( void )  <end>
<start> { <end>
<start>     RtcSwwdtIncrement (  )  ;      <end>
<start>     RtcTasks (  )  ;  <end>
<start>      <end>
<start> } <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _INT1Interrupt ( void )  <end>
<start> { <end>
<start>     LoggerAccelTasks (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _INT2Interrupt ( void )  <end>
<start> { <end>
<start>     LoggerAccelTasks (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> #ifdef USE_GYRO <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _INT3Interrupt ( void )  <end>
<start> { <end>
<start>     LoggerGyroTasks (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt , auto_psv )  )  _INT4Interrupt ( void )  <end>
<start> { <end>
<start>     LoggerGyroTasks (  )  ;  <end>
<start> } <end>
<start> #endif <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt ,  shadow ,  auto_psv )  )  _T1Interrupt ( void )  <end>
<start> { <end>
<start>     if  ( RtcTimerTasks (  )  )  <end>
<start>     { <end>
<start>          ;   <end>
<start>     } <end>
<start> } <end>
<start>  <end>
<start> void __attribute__ (  ( interrupt ,  shadow ,  auto_psv )  )  _CNInterrupt ( void )  <end>
<start> { <end>
<start> IFS1bits.CNIF = 0 ;  <end>
<start> } <end>
<start>  <end>
<start> #include <p24FJ256GB106.h> <end>
<start>  <end>
<start>  <end>
<start> static unsigned char restart = 0 ;  <end>
<start> static unsigned char inactive = 0 ;  <end>
<start> static unsigned short lastTime = 0 ;  <end>
<start>  <end>
<start>  <end>
<start>  <end>
<start> #if 0 <end>
<start> #include "Utils/Util.h" <end>
<start> extern write_handler_t writeHandler ;  <end>
<start>  <end>
<start> static void UsbWrite ( const void *buffer ,  unsigned int len )  <end>
<start> { <end>
<start> if  ( usb_write_length ( buffer ,  len )  < len )  <end>
<start> { <end>
<start> LED_SET ( LED_OFF )  ;  DelayMs ( 50 )  ;   <end>
<start> LED_SET ( LED_RED )  ;  DelayMs ( 50 )  ;   <end>
<start> LED_SET ( LED_YELLOW )  ;  DelayMs ( 50 )  ;   <end>
<start> LED_SET ( LED_OFF )  ;  <end>
<start> } <end>
<start> } <end>
<start> #endif <end>
<start>  <end>
<start>  <end>
<start> int main ( void )  <end>
<start> { <end>
<start>      <end>
<start> InitIO (  )  ;  <end>
<start> CLOCK_SOSCEN (  )  ;   <end>
<start> WaitForPrecharge (  )  ;  <end>
<start>  <end>
<start>     LED_SET ( LED_BLUE )  ;    <end>
<start> CLOCK_INTOSC (  )  ;       <end>
<start>      <end>
<start>     RtcSwwdtReset (  )  ;  <end>
<start>     RtcStartup (  )  ;  <end>
<start>     RtcInterruptOn ( 0 )  ;    <end>
<start>     LED_SET ( LED_BLUE )  ;    <end>
<start>      <end>
<start> AdcInit (  )  ;  <end>
<start>     AdcSampleWait (  )  ;      <end>
<start>  <end>
<start>      <end>
<start>     NandInitialize (  )  ;  <end>
<start>     NandVerifyDeviceId (  )  ;  <end>
<start>     AccelVerifyDeviceId (  )  ;  <end>
<start> #ifdef USE_GYRO <end>
<start>     GyroVerifyDeviceId (  )  ;  <end>
<start> #endif <end>
<start>  <end>
<start>  <end>
<start> RunTestSequence (  )  ;  <end>
<start>  <end>
<start>      <end>
<start>     if  ( !nandPresent )  <end>
<start>     { <end>
<start>         int i ;  <end>
<start>         for  ( i = 0 ;  i < 5 * 3 ;  i++ )  { LED_SET ( LED_MAGENTA )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_CYAN )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_YELLOW )  ;  DelayMs ( 111 )  ;  } <end>
<start>         #ifdef IGNORE_UNRECOGNIZED_PERIPHERALS <end>
<start>         if  ( !USB_BUS_SENSE )        <end>
<start>         #endif <end>
<start>     Reset (  )  ;                  <end>
<start>     } <end>
<start>     if  ( !accelPresent )  <end>
<start>     { <end>
<start>         int i ;  <end>
<start>         for  ( i = 0 ;  i < 5 * 3 ;  i++ )  { LED_SET ( LED_RED )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_GREEN )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_BLUE )  ;  DelayMs ( 111 )  ;  } <end>
<start>         #ifdef IGNORE_UNRECOGNIZED_PERIPHERALS <end>
<start>         if  ( !USB_BUS_SENSE )        <end>
<start>         #endif <end>
<start>     Reset (  )  ;                  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     restart = 0 ;  <end>
<start>     inactive = 0 ;  <end>
<start>     SettingsInitialize (  )  ;                 <end>
<start>  <end>
<start> LED_SET ( LED_WHITE )  ;           <end>
<start>     FtlStartup (  )  ;                         <end>
<start> if ( FSInit (  ) !=TRUE )                            <end>
<start> { <end>
<start> int i ;  <end>
<start> for  ( i = 0 ;  i < 5 * 3 ;  i++ )  { LED_SET ( LED_RED )  ;  DelayMs ( 111 )  ;  LED_SET ( LED_GREEN )  ;  DelayMs ( 111 )  ;  } <end>
<start> } <end>
<start>     SettingsReadFile ( SETTINGS_FILE )  ;      <end>
<start>      <end>
<start>     LoggerReadMetadata ( DEFAULT_FILE )  ;     <end>
<start>  <end>
<start>      <end>
<start>     if  ( USB_BUS_SENSE )  <end>
<start>     { <end>
<start>         RunAttached (  )  ;        <end>
<start>     } <end>
<start>     else <end>
<start>     { <end>
<start>         RunLogging (  )  ;         <end>
<start>     } <end>
<start>  <end>
<start> Reset (  )  ;                  <end>
<start> return 0 ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void RunAttached ( void )  <end>
<start> { <end>
<start>      <end>
<start>     LoggerClear (  )  ;  <end>
<start>  <end>
<start>      <end>
<start>     AccelStartup ( settings.sampleRate )  ;  <end>
<start>      <end>
<start> #ifdef USE_GYRO <end>
<start>     GyroStartup (  )  ;  <end>
<start>      <end>
<start> #endif <end>
<start>  <end>
<start> #if 1 <end>
<start> FtlFlush ( 0 )  ;      <end>
<start> #endif <end>
<start>     CLOCK_PLL (  )  ;  <end>
<start>     DelayMs ( 2 )  ;   <end>
<start>  <end>
<start>     fsftlUsbDiskMounted = status.diskMounted ;  <end>
<start> #if 1 <end>
<start> FSInit (  )  ;         <end>
<start> #endif <end>
<start>     MDD_MediaInitialize (  )  ;    <end>
<start>  <end>
<start>     USBInitializeSystem (  )  ;   <end>
<start>     #ifdef USB_INTERRUPT <end>
<start>     USBDeviceAttach (  )  ;  <end>
<start>     #endif <end>
<start>  <end>
<start>     while  ( USB_BUS_SENSE && restart != 1 )  <end>
<start>     { <end>
<start>         fsftlUsbDiskMounted = status.diskMounted ;  <end>
<start>  <end>
<start>          <end>
<start>         #ifndef USB_INTERRUPT <end>
<start>         USBDeviceTasks (  )  ;   <end>
<start>         #endif <end>
<start>         USBProcessIO (  )  ;  <end>
<start>         if  (  ( USBGetDeviceState (  )  >= CONFIGURED_STATE )  &&  ( USBIsDeviceSuspended (  )  == FALSE )  )  <end>
<start>         { <end>
<start>             const char *line = _user_gets (  )  ;  <end>
<start>             status.attached = 1 ;  <end>
<start>             if  ( line != NULL )  <end>
<start>             { <end>
<start>                 status.stream = 0 ;                    <end>
<start>                 SettingsCommand ( line ,  SETTINGS_USB )  ;  <end>
<start>             } <end>
<start>  <end>
<start>              <end>
<start>             if  ( status.stream )  <end>
<start>             { <end>
<start>                 #define STREAM_RATE 100 <end>
<start>                 #define STREAM_INTERVAL  ( 0x10000UL / STREAM_RATE )  <end>
<start>                 static unsigned long lastSampleTicks = 0 ;  <end>
<start>                 unsigned long now = RtcTicks (  )  ;  <end>
<start>                 if  ( lastSampleTicks == 0 )  { lastSampleTicks = now ;  } <end>
<start>                 if  ( now - lastSampleTicks > STREAM_INTERVAL )  <end>
<start>                 { <end>
<start>                     accel_t accelSample ;  <end>
<start>                     lastSampleTicks += STREAM_INTERVAL ;  <end>
<start>                     if  ( now - lastSampleTicks > 2 * STREAM_INTERVAL )  { lastSampleTicks = now ;  }  <end>
<start>  <end>
<start>                     AccelSingleSample ( &accelSample )  ;  <end>
<start> #ifdef USE_GYRO <end>
<start>                     if  ( gyroPresent )  <end>
<start>                     { <end>
<start>                         gyro_t gyroSample ;  <end>
<start>                         GyroSingleSample ( &gyroSample )  ;  <end>
<start>                         printf ( "%d , %d , %d , %d , %d , %d\r\n" ,  accelSample.x ,  accelSample.y ,  accelSample.z ,  gyroSample.x ,  gyroSample.y ,  gyroSample.z )  ;  <end>
<start>                     } <end>
<start>                     else <end>
<start> #endif <end>
<start>                     { <end>
<start>                         printf ( "%d , %d , %d\r\n" ,  accelSample.x ,  accelSample.y ,  accelSample.z )  ;  <end>
<start>                     } <end>
<start>                     USBCDCWait (  )  ;  <end>
<start>                 } <end>
<start>  <end>
<start>             } <end>
<start>         } <end>
<start>         else <end>
<start>         { <end>
<start>             status.attached = -1 ;  <end>
<start>         } <end>
<start>         LedTasks (  )  ;  <end>
<start>         TimedTasks (  )  ;  <end>
<start>  <end>
<start>  <end>
<start>          <end>
<start>         #ifdef FSFTL_READ_PREFETCH <end>
<start> FsFtlPrefetch (  )  ;  <end>
<start>         #endif <end>
<start>     } <end>
<start> #if defined ( USB_INTERRUPT )  <end>
<start>     USBDeviceDetach (  )  ;  <end>
<start> #endif <end>
<start>     status.attached = -1 ;  <end>
<start>  <end>
<start>      <end>
<start>     FtlShutdown (  )  ;  <end>
<start>     return ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void TimedTasks ( void )  <end>
<start> { <end>
<start>      <end>
<start>     if  ( lastTime != rtcTicksSeconds )  <end>
<start>     { <end>
<start>         lastTime = rtcTicksSeconds ;  <end>
<start>  <end>
<start>          <end>
<start>         inactive = FtlIncrementInactivity (  )  ;  <end>
<start>         AdcSampleNow (  )  ;  <end>
<start>         if  ( adcResult.batt > BATT_CHARGE_FULL_USB && status.batteryFull < BATT_FULL_INTERVAL )  <end>
<start>         { <end>
<start>             status.batteryFull++ ;  <end>
<start>             if  ( status.batteryFull >= BATT_FULL_INTERVAL )  <end>
<start>             { <end>
<start>                 if  ( status.initialBattery != 0 && status.initialBattery < BATT_CHARGE_MID_USB )  <end>
<start>                 { <end>
<start>                      <end>
<start>                     SettingsIncrementLogValue ( LOG_VALUE_BATTERY )  ;  <end>
<start>                 } <end>
<start>             } <end>
<start>         } <end>
<start>  <end>
<start>         if  ( inactive > 3 )  <end>
<start>         { <end>
<start>             FtlFlush ( 1 )  ;  <end>
<start>         } <end>
<start>  <end>
<start>         if  ( status.actionCountdown > 0 )  <end>
<start>         { <end>
<start>             status.actionCountdown-- ;  <end>
<start>             if  ( status.actionCountdown == 0 )  <end>
<start>             { <end>
<start>                 if  ( SettingsAction ( status.actionFlags )  )  <end>
<start>                 { <end>
<start>                     restart = 1 ;  <end>
<start>                 } <end>
<start>             } <end>
<start>         } <end>
<start>  <end>
<start>          <end>
<start>         RtcSwwdtReset (  )  ;  <end>
<start>     } <end>
<start>     return ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void LedTasks ( void )  <end>
<start> { <end>
<start>     static unsigned int LEDTimer ;  <end>
<start>     static BOOL LEDtoggle ;  <end>
<start>  <end>
<start>     if  ( ++LEDTimer == 0 )  { LEDtoggle = !LEDtoggle ;  } <end>
<start>  <end>
<start>     if  ( status.attached > 0 )  <end>
<start>     { <end>
<start>         if  ( status.actionCountdown )  <end>
<start>         { <end>
<start>             if  (  (  ( unsigned char )  ( LEDTimer )  )  <  (  ( LEDTimer )  >> 8 )  )  { LED_SET ( LEDtoggle ? LED_RED : LED_OFF )  ;  } else { LED_SET ( LEDtoggle ? LED_RED : LED_OFF )  ;  } <end>
<start>         } <end>
<start>         else if  ( status.ledOverride >= 0 )  <end>
<start>         { <end>
<start>             LED_SET ( status.ledOverride )  ;  <end>
<start>         } <end>
<start>         else <end>
<start>         { <end>
<start>             char c0 ,  c1 ;  <end>
<start>  <end>
<start>             if  ( inactive == 0 )  <end>
<start>             { <end>
<start>                 if  ( status.batteryFull >= BATT_FULL_INTERVAL )  { c0 = LED_OFF ;  c1 = LED_WHITE ;  }        <end>
<start>                 else                    { c0 = LED_OFF ;  c1 = LED_YELLOW ;  }       <end>
<start>             } <end>
<start>             else <end>
<start>             { <end>
<start>                 if  ( status.batteryFull >= BATT_FULL_INTERVAL )  { c0 = LED_RED ;  c1 = LED_WHITE ;  }        <end>
<start>                 else                    { c0 = LED_RED ;  c1 = LED_YELLOW ;  }       <end>
<start>             } <end>
<start>             if  (  (  ( unsigned char )  ( LEDTimer )  )  <  (  ( LEDTimer )  >> 8 )  )  { LED_SET ( LEDtoggle ? c1 : c0 )  ;  } else { LED_SET ( LEDtoggle ? c0 : c1 )  ;  } <end>
<start>         } <end>
<start>     } <end>
<start>     else <end>
<start>     { <end>
<start>         if  ( status.batteryFull )  { LED_SET ( LED_GREEN )  ;  }        <end>
<start>         else                    { LED_SET ( LED_YELLOW )  ;  }       <end>
<start>     } <end>
<start>     return ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> typedef enum <end>
<start> {  <end>
<start> STOP_NONE                   = 0 ,      <end>
<start> STOP_INTERVAL               = 1 ,      <end>
<start> STOP_SAMPLE_LIMIT           = 2 ,      <end>
<start> STOP_DISK_FULL              = 2 ,      <end>
<start> NOT_STARTED_NO_INTERVAL     = 3 ,      <end>
<start> NOT_STARTED_AFTER_INTERVAL  = 4 ,      <end>
<start> NOT_STARTED_SAMPLE_LIMIT    = 5 ,      <end>
<start> NOT_STARTED_DISK_FULL       = 5 ,      <end>
<start> NOT_STARTED_WAIT_USB        = 6 ,      <end>
<start> STOP_USB                    = 7 ,      <end>
<start> NOT_STARTED_INITIAL_BATTERY = 8 ,      <end>
<start> NOT_STARTED_WAIT_BATTERY    = 9 ,      <end>
<start> STOP_BATTERY                = 10 ,     <end>
<start> NOT_STARTED_FILE_OPEN       = 11 ,     <end>
<start> STOP_LOGGING_WRITE_ERR      = 12 ,     <end>
<start> STOP_LOGGING_SAMPLE_ERR     = 13 ,     <end>
<start> } StopCondition ;  <end>
<start>  <end>
<start> const char *stopConditionString[] = <end>
<start> { <end>
<start> STOP_NONE ,                     <end>
<start> STOP_INTERVAL ,                 <end>
<start> STOP_SAMPLE_LIMIT ,             <end>
<start> NOT_STARTED_NO_INTERVAL ,       <end>
<start> NOT_STARTED_AFTER_INTERVAL ,    <end>
<start> NOT_STARTED_SAMPLE_LIMIT ,      <end>
<start> NOT_STARTED_WAIT_USB ,          <end>
<start> STOP_USB ,                      <end>
<start> NOT_STARTED_INITIAL_BATTERY ,   <end>
<start> NOT_STARTED_WAIT_BATTERY ,      <end>
<start> STOP_BATTERY ,                  <end>
<start> NOT_STARTED_FILE_OPEN ,         <end>
<start> STOP_LOGGING_WRITE_ERR ,        <end>
<start> STOP_LOGGING_SAMPLE_ERR ,       <end>
<start> } ;  <end>
<start>  <end>
<start> const char stopFlashCode[] = <end>
<start> { <end>
<start>     0x00 ,  0x10 ,  0x11 ,  0x12 ,  0x13 ,  0x14 ,  0x15 ,  0x16 ,  0x40 ,  0x41 ,  0x42 ,  0x43 ,  0x44 ,  0x45 <end>
<start> } ;  <end>
<start>  <end>
<start>  <end>
<start> void RunLogging ( void )  <end>
<start> { <end>
<start>     const char *filename = DEFAULT_FILE ;  <end>
<start>     StopCondition stopCondition = 0 ;  <end>
<start>  <end>
<start>     AdcInit (  )  ;  <end>
<start>     AdcSampleWait (  )  ;  <end>
<start>  <end>
<start>     SettingsIncrementLogValue ( LOG_VALUE_RESTART )  ;     <end>
<start>  <end>
<start>     if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  <end>
<start>     { <end>
<start>          <end>
<start>         stopCondition = NOT_STARTED_INITIAL_BATTERY ;  <end>
<start>     } <end>
<start>     else if  ( settings.loggingStartTime >= settings.loggingEndTime )  <end>
<start>     { <end>
<start>          <end>
<start>         stopCondition = NOT_STARTED_NO_INTERVAL ;     <end>
<start>     } <end>
<start>     else if  ( settings.loggingEndTime > settings.loggingStartTime && RtcNow (  )  >= settings.loggingEndTime )  <end>
<start>     { <end>
<start>          <end>
<start>         stopCondition = NOT_STARTED_AFTER_INTERVAL ;     <end>
<start>     } <end>
<start>     else <end>
<start>     { <end>
<start>          <end>
<start>         if  ( settings.loggingStartTime < settings.loggingEndTime && RtcNow (  )  < settings.loggingStartTime )  <end>
<start>         { <end>
<start>              <end>
<start>             status.debugFlashCount = 5 ;  <end>
<start>             while  ( restart != 1 && !stopCondition )  <end>
<start>             { <end>
<start>                 unsigned int i ;  <end>
<start>  <end>
<start>                  <end>
<start>                 RtcSwwdtReset (  )  ;  <end>
<start>  <end>
<start>                  <end>
<start>                 for  ( i = 0 ;  i < 5 ;  i++ )  <end>
<start>                 { <end>
<start>                      <end>
<start>                     if  ( USB_BUS_SENSE )  { stopCondition = NOT_STARTED_WAIT_USB ;  restart = 1 ;  break ;  } <end>
<start>  <end>
<start>                     if  ( settings.debuggingInfo >= 1 || status.debugFlashCount > 0 )  { LED_SET ( LED_YELLOW )  ;  if  ( status.debugFlashCount > 0 )  status.debugFlashCount-- ;  Delay10us ( 5 )  ;  } <end>
<start>                     LED_SET ( LED_OFF )  ;  <end>
<start>  <end>
<start>                     SystemPwrSave ( WAKE_ON_WDT|WAKE_ON_USB|DONT_RESTORE_PERIPHERALS|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE )  ;  <end>
<start>                 } <end>
<start>                 if  ( stopCondition )  { break ;  } <end>
<start>  <end>
<start>                  <end>
<start>                 AdcInit (  )  ;  <end>
<start>                 AdcSampleNow (  )  ;  <end>
<start>  <end>
<start>                  <end>
<start>                 if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  { stopCondition = NOT_STARTED_WAIT_BATTERY ;  break ;  } <end>
<start>  <end>
<start>                  <end>
<start>                 if  ( RtcNow (  )  >= settings.loggingStartTime )  { break ;  } <end>
<start>             } <end>
<start>             LED_SET ( LED_OFF )  ;  <end>
<start>         } <end>
<start>  <end>
<start>          <end>
<start>         if  ( restart != 1 && !stopCondition )  <end>
<start>         { <end>
<start>             if  ( FSDiskFree (  )  == 0 )  <end>
<start>             { <end>
<start>             stopCondition = NOT_STARTED_DISK_FULL ;  <end>
<start>             } <end>
<start>             else if  ( !LoggerStart ( filename )  )  <end>
<start>             { <end>
<start>             stopCondition = NOT_STARTED_FILE_OPEN ;  <end>
<start>             } <end>
<start>             else <end>
<start>             { <end>
<start>                  <end>
<start>                 if  ( settings.maximumSamples != 0 && status.sampleCount >= settings.maximumSamples )  <end>
<start>                 {  <end>
<start>                 stopCondition = NOT_STARTED_SAMPLE_LIMIT ;   <end>
<start>                 } <end>
<start>                 else <end>
<start>                 { <end>
<start>                     int failCounter = 0 ;  <end>
<start>  <end>
<start> #ifdef HIGH_SPEED_USES_PLL <end>
<start> #warning "HIGH_SPEED_USES_PLL not fully tested." <end>
<start> char isHighSpeed = 0 ;  <end>
<start> if  ( ACCEL_FREQUENCY_FOR_RATE ( settings.sampleRate )  >= 1600 )  { isHighSpeed = 1 ;  } <end>
<start> if  ( isHighSpeed )  { CLOCK_PLL (  )  ; } <end>
<start> #endif <end>
<start>  <end>
<start>                  <end>
<start>                 LoggerClear (  )  ;  <end>
<start>  <end>
<start>                  <end>
<start>                 AccelStartup ( settings.sampleRate )  ;  <end>
<start>                 AccelEnableInterrupts ( ACCEL_INT_SOURCE_WATERMARK | ACCEL_INT_SOURCE_OVERRUN ,  0x00 )  ;  <end>
<start> #ifdef USE_GYRO <end>
<start>                     GyroStartupFifoInterrupts (  )  ;  <end>
<start> #endif <end>
<start>  <end>
<start>                  <end>
<start>                 while  ( restart != 1 && !stopCondition )  <end>
<start>                 { <end>
<start>                     unsigned short now ;  <end>
<start>                         short result ;  <end>
<start>  <end>
<start>                      <end>
<start>                     if  ( USB_BUS_SENSE )  { stopCondition = STOP_USB ;  restart = 1 ;  break ;  } <end>
<start>  <end>
<start>                      <end>
<start>                     now = RtcSeconds (  )  ;  <end>
<start>  <end>
<start>                      <end>
<start>                         result = LoggerWrite (  )  ;  <end>
<start>                     if  ( result )  <end>
<start>                     { <end>
<start>                              <end>
<start>                             status.lastSampledTicks = now ;  <end>
<start>  <end>
<start>                              <end>
<start>                             if  ( result > 0 )  <end>
<start>                             { <end>
<start>                                 status.lastWrittenTicks = now ;  <end>
<start>  <end>
<start>                                  <end>
<start>                                 RtcSwwdtReset (  )  ;  <end>
<start>                             } <end>
<start>  <end>
<start>                          <end>
<start>                         AdcInit (  )  ;  AdcSampleNow (  )  ;   <end>
<start>                         if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  <end>
<start>                         { <end>
<start>                              <end>
<start>                             AdcInit (  )  ;  AdcSampleNow (  )  ;  <end>
<start>                             if  ( adcResult.batt < BATT_CHARGE_MIN_SAFE )  { stopCondition = STOP_BATTERY ;  break ;  } <end>
<start>                         } <end>
<start>  <end>
<start>                          <end>
<start>                         if  ( settings.maximumSamples != 0 && status.sampleCount >= settings.maximumSamples )  { stopCondition = STOP_SAMPLE_LIMIT ;  break ;  } <end>
<start>  <end>
<start>                          <end>
<start>                         if  ( RtcNow (  )  > settings.loggingEndTime )  { stopCondition = STOP_INTERVAL ;  break ;  } <end>
<start>                     } <end>
<start>  <end>
<start>                      <end>
<start>                     if  ( status.lastSampledTicks == 0x0000 )  { status.lastSampledTicks = now ;  } <end>
<start>                     if  ( status.lastWrittenTicks == 0x0000 )  { status.lastWrittenTicks = now ;  } <end>
<start>  <end>
<start>                         if  ( now - status.lastSampledTicks > 15 )  <end>
<start>                         { <end>
<start>                              <end>
<start>                             failCounter++ ;  <end>
<start>                             if  ( failCounter > 5 )  <end>
<start>                             { <end>
<start>                                 stopCondition = STOP_LOGGING_SAMPLE_ERR ;  <end>
<start>                                 restart = 1 ;  <end>
<start>                                 break ;  <end>
<start>                             } <end>
<start>                         } <end>
<start>                         else if  ( now - status.lastWrittenTicks > 30 )  <end>
<start>                         { <end>
<start>                              <end>
<start>                             failCounter++ ;  <end>
<start>                             if  ( failCounter > 5 )  <end>
<start>                             { <end>
<start>                                  <end>
<start>                                 if  ( FSDiskFree (  )  == 0 )  <end>
<start>                                 { <end>
<start>                                 stopCondition = STOP_DISK_FULL ;  <end>
<start>                                 } <end>
<start>                                 else <end>
<start>                                 { <end>
<start>                                     stopCondition = STOP_LOGGING_WRITE_ERR ;  <end>
<start>                                     restart = 1 ;  <end>
<start>                                 } <end>
<start>                                 break ;  <end>
<start>                             } <end>
<start>                         } <end>
<start>                         else { failCounter = 0 ;  } <end>
<start>  <end>
<start> #ifdef HIGH_SPEED_USES_PLL <end>
<start> if  ( !isHighSpeed )  <end>
<start> { <end>
<start> #endif <end>
<start>  <end>
<start>                      <end>
<start> #ifdef USE_GYRO <end>
<start>                     SystemPwrSave ( WAKE_ON_RTC|WAKE_ON_WDT|WAKE_ON_USB|WAKE_ON_ADXL1|WAKE_ON_GYRO2|WAKE_ON_TIMER1|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE )  ;  <end>
<start> #else <end>
<start>                     SystemPwrSave ( WAKE_ON_RTC|WAKE_ON_WDT|WAKE_ON_USB|WAKE_ON_ADXL1|WAKE_ON_TIMER1|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE )  ;  <end>
<start> #endif <end>
<start>                      <end>
<start>                      <end>
<start> #ifdef HIGH_SPEED_USES_PLL <end>
<start> } <end>
<start> #endif <end>
<start>                      <end>
<start>                      <end>
<start>                 } <end>
<start>  <end>
<start> #ifdef HIGH_SPEED_USES_PLL <end>
<start> if  ( isHighSpeed )  { CLOCK_INTOSC (  )  ; } <end>
<start> #endif <end>
<start>  <end>
<start> } <end>
<start>  <end>
<start>                 LoggerStop (  )  ;  <end>
<start>             } <end>
<start>         } <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     LED_SET ( LED_BLUE )  ;  <end>
<start>  <end>
<start>      <end>
<start>     AccelStandby (  )  ;  <end>
<start> #ifdef USE_GYRO <end>
<start>     GyroStandby (  )  ;  <end>
<start> #endif <end>
<start>     RtcInterruptOff (  )  ;  <end>
<start>     FtlShutdown (  )  ;  <end>
<start>  <end>
<start>      <end>
<start>     SettingsAddLogEntry ( LOG_CATEGORY_STOP |  ( unsigned int ) stopCondition ,  RtcNow (  )  ,  stopConditionString[stopCondition] )  ;  <end>
<start>  <end>
<start>      <end>
<start>     LED_SET ( LED_OFF )  ;  <end>
<start>  <end>
<start>      <end>
<start>     if  ( restart != 1 )  <end>
<start>     { <end>
<start>         unsigned char led ,  countReset ,  countdown ;  <end>
<start>         led =  ( stopFlashCode[stopCondition] >> 4 )  ;  <end>
<start>         countReset = stopFlashCode[stopCondition] & 0x0f ;  <end>
<start>         countdown = countReset ;  <end>
<start>         if  ( settings.debuggingInfo == 0xff )  { led = 0 ;  } <end>
<start>         CLOCK_INTOSC (  )  ;   <end>
<start>          <end>
<start>          <end>
<start>         while  ( restart != 1 )  <end>
<start>         { <end>
<start>             if  ( USB_BUS_SENSE )  { restart = 1 ;  break ;  } <end>
<start>  <end>
<start>              <end>
<start>             RtcSwwdtReset (  )  ;  <end>
<start>  <end>
<start>             SystemPwrSave ( WAKE_ON_WDT|LOWER_PWR_SLOWER_WAKE|WAKE_ON_USB|ADC_POWER_DOWN|ACCEL_POWER_DOWN|GYRO_POWER_DOWN|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE )  ;  <end>
<start>              <end>
<start>  <end>
<start>             if  ( led )  <end>
<start>             { <end>
<start>                 LED_SET ( led )  ;  <end>
<start>                 if  ( countdown > 0 )  <end>
<start>                 { <end>
<start>                 Delay10us ( 15 )  ;  <end>
<start>                 countdown-- ;  <end>
<start>                 } <end>
<start>                 else <end>
<start>                 { <end>
<start>                     Delay10us ( 3 )  ;  <end>
<start>                     countdown = countReset ;  <end>
<start>                 } <end>
<start>                 LED_SET ( LED_OFF )  ;  <end>
<start>             } <end>
<start>         } <end>
<start>     } <end>
<start>  <end>
<start>     return ;  <end>
<start> } <end>
<start> #include "dhdebug.h" <end>
<start> #include "DH/uart.h" <end>
<start> #include "dhsender_queue.h" <end>
<start> #include "dhterminal.h" <end>
<start> #include "dhsettings.h" <end>
<start> #include "dhconnector.h" <end>
<start> #include "dhap.h" <end>
<start> #include "DH/gpio.h" <end>
<start> #include "webserver.h" <end>
<start> #include "irom.h" <end>
<start> #include "uploadable_page.h" <end>
<start> #include "dhzc_dnsd.h" <end>
<start> #include "dhzc_web.h" <end>
<start> #include "mdnsd.h" <end>
<start>  <end>
<start> #include <osapi.h> <end>
<start> #include <os_type.h> <end>
<start> #include <c_types.h> <end>
<start> #include <user_interface.h> <end>
<start> #include <gpio.h> <end>
<start> #include <ets_forward.h> <end>
<start>  <end>
<start> typedef struct { <end>
<start> unsigned int magic ;  <end>
<start> unsigned int resetCounter ;  <end>
<start> } RESET_COUNTER ;  <end>
<start> #define RESET_COUNTER_MAGIC 0x12345678 <end>
<start> #define RESET_COUNTER_RTC_ADDRESS 64 <end>
<start> #define RESET_NUM 3 <end>
<start>  <end>
<start> LOCAL os_timer_t mResetTimer ;  <end>
<start> LOCAL unsigned int mSpecialMode = 0 ;  <end>
<start>  <end>
<start> uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set ( void )  { <end>
<start> enum flash_size_map size_map = system_get_flash_size_map (  )  ;  <end>
<start> uint32 rf_cal_sec = 0 ;  <end>
<start>  <end>
<start> switch  ( size_map )  { <end>
<start> case FLASH_SIZE_4M_MAP_256_256: <end>
<start> rf_cal_sec = 128 - 8 ;  <end>
<start> break ;  <end>
<start>  <end>
<start> case FLASH_SIZE_8M_MAP_512_512: <end>
<start> rf_cal_sec = 256 - 5 ;  <end>
<start> break ;  <end>
<start>  <end>
<start> case FLASH_SIZE_16M_MAP_512_512: <end>
<start> case FLASH_SIZE_16M_MAP_1024_1024: <end>
<start> rf_cal_sec = 512 - 5 ;  <end>
<start> break ;  <end>
<start>  <end>
<start> case FLASH_SIZE_32M_MAP_512_512: <end>
<start> case FLASH_SIZE_32M_MAP_1024_1024: <end>
<start> rf_cal_sec = 1024 - 5 ;  <end>
<start> break ;  <end>
<start>  <end>
<start> default: <end>
<start> rf_cal_sec = 0 ;  <end>
<start> break ;  <end>
<start> } <end>
<start>  <end>
<start> return rf_cal_sec ;  <end>
<start> } <end>
<start>  <end>
<start> //0  )  )  { <end>
<start>  <end>
<start> LOCAL void ICACHE_FLASH_ATTR reset_counter ( void *arg )  { <end>
<start> RESET_COUNTER counter ;  <end>
<start> counter.magic = RESET_COUNTER_MAGIC ;  <end>
<start> counter.resetCounter = 0 ;  <end>
<start> system_rtc_mem_write ( RESET_COUNTER_RTC_ADDRESS ,  &counter ,  sizeof ( counter )  )  ;  <end>
<start> } <end>
<start>  <end>
<start> extern int rtc_mem_check ( int f )  ;  <end>
<start>  <end>
<start> void user_rf_pre_init ( void )  { <end>
<start> RESET_COUNTER counter ;  <end>
<start> if ( system_get_rst_info (  ) ->reason != REASON_EXT_SYS_RST )  { <end>
<start> reset_counter ( 0 )  ;  <end>
<start> } else { <end>
<start> system_rtc_mem_read ( 64 ,  &counter ,  sizeof ( counter )  )  ;  <end>
<start> if ( counter.magic == RESET_COUNTER_MAGIC && counter.resetCounter <= RESET_NUM )  { <end>
<start> counter.resetCounter++ ;  <end>
<start> if ( counter.resetCounter == RESET_NUM )  { <end>
<start> reset_counter ( 0 )  ;  <end>
<start> mSpecialMode = 1 ;  <end>
<start> } else { <end>
<start> system_rtc_mem_write ( RESET_COUNTER_RTC_ADDRESS ,  &counter ,  sizeof ( counter )  )  ;  <end>
<start> os_timer_disarm ( &mResetTimer )  ;  <end>
<start> os_timer_setfn ( &mResetTimer ,   ( os_timer_func_t * ) reset_counter ,  NULL )  ;  <end>
<start> os_timer_arm ( &mResetTimer ,  1000 ,  0 )  ;  <end>
<start> } <end>
<start> } else { <end>
<start> reset_counter ( 0 )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> system_restore (  )  ;  <end>
<start> rtc_mem_check ( 0 )  ;  <end>
<start> } <end>
<start>  <end>
<start> void ICACHE_FLASH_ATTR system_init_done ( void )  { <end>
<start> if ( dhsettings_get_wifi_mode (  )  == WIFI_MODE_AP && <end>
<start> dhsettings_get_devicehive_deviceid (  ) [0] && <end>
<start> mSpecialMode == 0 )  { <end>
<start> mdnsd_start ( dhsettings_get_devicehive_deviceid (  )  ,  dhap_get_ip_info (  ) ->ip.addr )  ;  <end>
<start> } <end>
<start> dhdebug ( "Initialization completed" )  ;  <end>
<start> } <end>
<start>  <end>
<start> void user_init ( void )  { <end>
<start> int ever_saved ;  <end>
<start> gpio_output_set ( 0 ,  0 ,  0 ,  DH_GPIO_SUITABLE_PINS )  ;  <end>
<start> dhsettings_init ( &ever_saved )  ;  <end>
<start> if ( ever_saved == 0 )  {  <end>
<start> uploadable_page_delete (  )  ;  <end>
<start> mSpecialMode = 1 ;  <end>
<start> } <end>
<start> dhdebug ( "*****************************" )  ;  <end>
<start> if ( mSpecialMode )  {  <end>
<start> dh_uart_leds ( DH_UART_LEDS_ON )  ;  <end>
<start> dhdebug ( "Wi-Fi Zero Configuration Mode" )  ;  <end>
<start> dhap_init ( WIFI_CONFIGURATION_SSID ,  NULL )  ;  <end>
<start> dhzc_dnsd_init (  )  ;  <end>
<start> dhzc_web_init (  )  ;  <end>
<start> dhdebug ( "Zero configuration server is initialized" )  ;  <end>
<start> } else { <end>
<start> if ( dhsettings_get_wifi_mode (  )  == WIFI_MODE_CLIENT )  { <end>
<start> dhsender_queue_init (  )  ;  <end>
<start> dhconnector_init (  )  ;  <end>
<start> dh_gpio_init (  )  ;  <end>
<start> } else if ( dhsettings_get_wifi_mode (  )  == WIFI_MODE_AP )  { <end>
<start> dhap_init ( dhsettings_get_wifi_ssid (  )  ,  dhsettings_get_wifi_password (  )  )  ;  <end>
<start> } <end>
<start> webserver_init (  )  ;  <end>
<start> } <end>
<start> system_init_done_cb ( system_init_done )  ;  <end>
<start> dhterminal_init (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> #include "hal/i2c/i2c.h" <end>
<start> #include "hal/i2c/i2c_bit_ops.h" <end>
<start> #include "hal/i2c/i2c_dev.h" <end>
<start> #include <firmament.h> <end>
<start>  <end>
<start> rt_err_t rt_i2c_bus_device_register ( struct rt_i2c_bus* bus ,  <end>
<start>                                     const char* bus_name )  <end>
<start> { <end>
<start>     rt_err_t res = RT_EOK ;  <end>
<start>  <end>
<start>     rt_mutex_init ( &bus->lock ,  "i2c_bus_lock" ,  RT_IPC_FLAG_FIFO )  ;  <end>
<start>  <end>
<start>     if  ( bus->timeout == 0 )  <end>
<start>         bus->timeout = RT_TICK_PER_SECOND ;  <end>
<start>  <end>
<start>     res = rt_i2c_bus_init ( bus ,  bus_name )  ;  <end>
<start>  <end>
<start>     i2c_dbg ( "I2C bus [%s] registered\n" ,  bus_name )  ;  <end>
<start>  <end>
<start>     return res ;  <end>
<start> } <end>
<start>  <end>
<start> rt_err_t rt_i2c_bus_attach_device ( struct rt_i2c_device* device ,  <end>
<start>                                   const char* name ,  <end>
<start>                                   const char* bus_name ,  <end>
<start>                                   void* user_data )  <end>
<start> { <end>
<start>     rt_err_t result ;  <end>
<start>     rt_device_t bus ;  <end>
<start>  <end>
<start>      <end>
<start>     bus = rt_device_find ( bus_name )  ;  <end>
<start>  <end>
<start>     if  ( bus != RT_NULL && bus->type == RT_Device_Class_I2CBUS )  { <end>
<start>         device->bus =  ( struct rt_i2c_bus* ) bus ;  <end>
<start>  <end>
<start>          <end>
<start>         result = rt_i2c_device_init ( device ,  name )  ;  <end>
<start>         if  ( result != RT_EOK )  <end>
<start>             return result ;  <end>
<start>  <end>
<start>         device->parent.user_data = user_data ;  <end>
<start>  <end>
<start>         return RT_EOK ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     return -RT_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> rt_size_t rt_i2c_transfer ( struct rt_i2c_bus* bus ,  <end>
<start>                           rt_uint16_t addr ,  <end>
<start>                           struct rt_i2c_msg msgs[] ,  <end>
<start>                           rt_uint32_t num )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>  <end>
<start>     if  ( bus->ops->master_xfer )  { <end>
<start> #ifdef RT_I2C_DEBUG <end>
<start>         for  ( ret = 0 ;  ret < num ;  ret++ )  { <end>
<start>             i2c_dbg ( "msgs[%d] %c ,  len=%d%s\n" ,  ret ,   ( msgs[ret].flags & RT_I2C_RD )  ? 'R' : 'W' ,  msgs[ret].len )  ;  <end>
<start>         } <end>
<start> #endif <end>
<start>         if  ( ! ( msgs[0].flags & RT_I2C_ADDR_10BIT )  )  { <end>
<start>             addr = addr << 1 ;  <end>
<start>         } <end>
<start>  <end>
<start>         rt_mutex_take ( &bus->lock ,  RT_WAITING_FOREVER )  ;  <end>
<start>         ret = bus->ops->master_xfer ( bus ,  addr ,  msgs ,  num )  ;  <end>
<start>         rt_mutex_release ( &bus->lock )  ;  <end>
<start>  <end>
<start>         return ret ;  <end>
<start>     } else { <end>
<start>         i2c_dbg ( "I2C bus operation not supported\n" )  ;  <end>
<start>  <end>
<start>         return 0 ;  <end>
<start>     } <end>
<start> } <end>
<start>  <end>
<start> rt_size_t rt_i2c_master_send ( struct rt_i2c_bus* bus ,  <end>
<start>                              rt_uint16_t addr ,  <end>
<start>                              rt_uint16_t flags ,  <end>
<start>                              const rt_uint8_t* buf ,  <end>
<start>                              rt_uint32_t count )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     struct rt_i2c_msg msg ;  <end>
<start>     RT_ASSERT ( bus != RT_NULL )  ;  <end>
<start>  <end>
<start>     msg.flags = flags & RT_I2C_ADDR_10BIT ;  <end>
<start>     msg.len = count ;  <end>
<start>     msg.buf =  ( rt_uint8_t* ) buf ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( bus ,  addr ,  &msg ,  1 )  ;  <end>
<start>  <end>
<start>     return ret == 1 ? count : 0 ;  <end>
<start> } <end>
<start>  <end>
<start> rt_size_t rt_i2c_master_recv ( struct rt_i2c_bus* bus ,  <end>
<start>                              rt_uint16_t addr ,  <end>
<start>                              rt_uint16_t flags ,  <end>
<start>                              rt_uint8_t* buf ,  <end>
<start>                              rt_uint32_t count )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     struct rt_i2c_msg msg ;  <end>
<start>     RT_ASSERT ( bus != RT_NULL )  ;  <end>
<start>  <end>
<start>     msg.flags = flags & RT_I2C_ADDR_10BIT ;  <end>
<start>     msg.flags |= RT_I2C_RD ;  <end>
<start>     msg.len = count ;  <end>
<start>     msg.buf = buf ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( bus ,  addr ,  &msg ,  1 )  ;  <end>
<start>  <end>
<start>     return ret == 1 ? count : 0 ;  <end>
<start> } <end>
<start>  <end>
<start> rt_err_t i2c_read_reg ( rt_device_t i2c_dev ,  uint8_t reg ,  uint8_t* buffer )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     struct rt_i2c_msg msgs[2] ;  <end>
<start>     struct rt_i2c_device* i2c_device =  ( struct rt_i2c_device* ) i2c_dev ;  <end>
<start>  <end>
<start>     msgs[0].flags = RT_I2C_WR | i2c_device->flags ;  <end>
<start>     msgs[0].buf = &reg ;  <end>
<start>     msgs[0].len = 1 ;  <end>
<start>  <end>
<start>     msgs[1].flags = RT_I2C_RD | i2c_device->flags ;  <end>
<start>     msgs[1].buf = buffer ;  <end>
<start>     msgs[1].len = 1 ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( i2c_device->bus ,  i2c_device->slave_addr ,  msgs ,  2 )  ;  <end>
<start>  <end>
<start>     return ret == 2 ? RT_EOK : RT_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> rt_err_t i2c_write_reg ( rt_device_t i2c_dev ,  uint8_t reg ,  uint8_t val )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     rt_uint8_t buffer[2] ;  <end>
<start>     struct rt_i2c_msg msgs ;  <end>
<start>     struct rt_i2c_device* i2c_device =  ( struct rt_i2c_device* ) i2c_dev ;  <end>
<start>  <end>
<start>     buffer[0] = reg ;  <end>
<start>     buffer[1] = val ;  <end>
<start>  <end>
<start>     msgs.flags = RT_I2C_WR | i2c_device->flags ;  <end>
<start>     msgs.buf = buffer ;  <end>
<start>     msgs.len = 2 ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( i2c_device->bus ,  i2c_device->slave_addr ,  &msgs ,  1 )  ;  <end>
<start>  <end>
<start>     return ret == 1 ? RT_EOK : RT_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> rt_err_t i2c_read_regs ( rt_device_t i2c_dev ,  uint8_t reg ,  uint8_t* buffer ,  uint16_t count )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     struct rt_i2c_msg msgs[2] ;  <end>
<start>     struct rt_i2c_device* i2c_device =  ( struct rt_i2c_device* ) i2c_dev ;  <end>
<start>  <end>
<start>     msgs[0].flags = RT_I2C_WR | i2c_device->flags ;  <end>
<start>     msgs[0].buf = &reg ;  <end>
<start>     msgs[0].len = 1 ;  <end>
<start>  <end>
<start>     msgs[1].flags = RT_I2C_RD | i2c_device->flags ;  <end>
<start>     msgs[1].buf = buffer ;  <end>
<start>     msgs[1].len = count ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( i2c_device->bus ,  i2c_device->slave_addr ,  msgs ,  2 )  ;  <end>
<start>  <end>
<start>     return ret == 2 ? RT_EOK : RT_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> rt_err_t i2c_write_regs ( rt_device_t i2c_dev ,  uint8_t reg ,  uint8_t* vals ,  uint16_t count )  <end>
<start> { <end>
<start>     rt_size_t ret ;  <end>
<start>     struct rt_i2c_msg msgs[2] ;  <end>
<start>     struct rt_i2c_device* i2c_device =  ( struct rt_i2c_device* ) i2c_dev ;  <end>
<start>  <end>
<start>     msgs[0].flags = RT_I2C_WR | i2c_device->flags ;  <end>
<start>     msgs[0].buf = &reg ;  <end>
<start>     msgs[0].len = 1 ;  <end>
<start>  <end>
<start>     msgs[1].flags = RT_I2C_WR | i2c_device->flags ;  <end>
<start>     msgs[1].buf = vals ;  <end>
<start>     msgs[1].len = count ;  <end>
<start>  <end>
<start>     ret = rt_i2c_transfer ( i2c_device->bus ,  i2c_device->slave_addr ,  msgs ,  2 )  ;  <end>
<start>  <end>
<start>     return ret == 2 ? RT_EOK : RT_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> #ifdef TEST_XEX <end>
<start> #include <stdlib.h> <end>
<start> #include <stdio.h> <end>
<start> #include <string.h> <end>
<start> #include "test_helpers.h" <end>
<start> #include "wallet.h" <end>
<start> #endif  <end>
<start>  <end>
<start> #include "common.h" <end>
<start> #include "aes.h" <end>
<start> #include "prandom.h" <end>
<start> #include "hwinterface.h" <end>
<start> #include "endian.h" <end>
<start>  <end>
<start> /** Primary encryption key. */ <end>
<start> static uint8_t nv_storage_encrypt_key[16] ;  <end>
<start> static uint8_t nv_storage_tweak_key[16] ;  <end>
<start>  <end>
<start> static void doubleInGF ( uint8_t *op1 )  <end>
<start> { <end>
<start> uint8_t i ;  <end>
<start> uint8_t last_bit ;  <end>
<start> uint8_t temp ;  <end>
<start>  <end>
<start> last_bit = 0 ;  <end>
<start> for  ( i = 0 ;  i < 16 ;  i++ )  <end>
<start> { <end>
<start> temp =  ( uint8_t )  ( op1[i] & 0x80 )  ;  <end>
<start> op1[i] =  ( uint8_t )  ( op1[i] << 1 )  ;  <end>
<start> op1[i] |= last_bit ;  <end>
<start> last_bit =  ( uint8_t )  ( temp >> 7 )  ;  <end>
<start> } <end>
<start> last_bit =  ( uint8_t )  ( - ( int ) last_bit )  ;  <end>
<start> op1[0] =  ( uint8_t )  ( op1[0] ^  ( 0x87 & last_bit )  )  ;  <end>
<start> } <end>
<start>  <end>
<start> static void xexEnDecrypt ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq ,  uint8_t *tweak_key ,  uint8_t *encrypt_key ,  bool is_decrypt )  <end>
<start> { <end>
<start> uint8_t expanded_key[EXPANDED_KEY_SIZE] ;  <end>
<start> uint8_t delta[16] ;  <end>
<start> uint8_t buffer[16] ;  <end>
<start> uint8_t i ;  <end>
<start>  <end>
<start> aesExpandKey ( expanded_key ,  tweak_key )  ;  <end>
<start> aesEncrypt ( delta ,  n ,  expanded_key )  ;  <end>
<start> for  ( i = 0 ;  i < seq ;  i++ )  <end>
<start> { <end>
<start> doubleInGF ( delta )  ;  <end>
<start> } <end>
<start> memcpy ( buffer ,  in ,  16 )  ;  <end>
<start> xor16Bytes ( buffer ,  delta )  ;  <end>
<start> aesExpandKey ( expanded_key ,  encrypt_key )  ;  <end>
<start> if  ( is_decrypt )  <end>
<start> { <end>
<start> aesDecrypt ( out ,  buffer ,  expanded_key )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> aesEncrypt ( out ,  buffer ,  expanded_key )  ;  <end>
<start> } <end>
<start> xor16Bytes ( out ,  delta )  ;  <end>
<start> } <end>
<start>  <end>
<start> static void xexEncryptInternal ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq ,  uint8_t *tweak_key ,  uint8_t *encrypt_key )  <end>
<start> { <end>
<start> xexEnDecrypt ( out ,  in ,  n ,  seq ,  tweak_key ,  encrypt_key ,  false )  ;  <end>
<start> } <end>
<start>  <end>
<start> static void xexDecryptInternal ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq ,  uint8_t *tweak_key ,  uint8_t *encrypt_key )  <end>
<start> { <end>
<start> xexEnDecrypt ( out ,  in ,  n ,  seq ,  tweak_key ,  encrypt_key ,  true )  ;  <end>
<start> } <end>
<start>  <end>
<start> void xexEncrypt ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq )  <end>
<start> { <end>
<start> xexEncryptInternal ( out ,  in ,  n ,  seq ,  nv_storage_tweak_key ,  nv_storage_encrypt_key )  ;  <end>
<start> } <end>
<start>  <end>
<start> void xexDecrypt ( uint8_t *out ,  uint8_t *in ,  uint8_t *n ,  uint8_t seq )  <end>
<start> { <end>
<start> xexDecryptInternal ( out ,  in ,  n ,  seq ,  nv_storage_tweak_key ,  nv_storage_encrypt_key )  ;  <end>
<start> } <end>
<start>  <end>
<start> void setEncryptionKey ( const uint8_t *in )  <end>
<start> { <end>
<start> memcpy ( nv_storage_encrypt_key ,  in ,  16 )  ;  <end>
<start> memcpy ( nv_storage_tweak_key ,  & ( in[16] )  ,  16 )  ;  <end>
<start> } <end>
<start>  <end>
<start> void getEncryptionKey ( uint8_t *out )  <end>
<start> { <end>
<start> memcpy ( out ,  nv_storage_encrypt_key ,  16 )  ;  <end>
<start> memcpy ( & ( out[16] )  ,  nv_storage_tweak_key ,  16 )  ;  <end>
<start> } <end>
<start>  <end>
<start> bool isEncryptionKeyNonZero ( void )  <end>
<start> { <end>
<start> uint8_t r ;  <end>
<start> uint8_t i ;  <end>
<start>  <end>
<start> r = 0 ;  <end>
<start> for  ( i = 0 ;  i < 16 ;  i++ )  <end>
<start> { <end>
<start> r |= nv_storage_encrypt_key[i] ;  <end>
<start> r |= nv_storage_tweak_key[i] ;  <end>
<start> } <end>
<start> if  ( r != 0 )  <end>
<start> { <end>
<start> return true ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> return false ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> void clearEncryptionKey ( void )  <end>
<start> { <end>
<start> memset ( nv_storage_tweak_key ,  0xff ,  16 )  ;  <end>
<start> memset ( nv_storage_encrypt_key ,  0xff ,  16 )  ;  <end>
<start> memset ( nv_storage_tweak_key ,  0 ,  16 )  ;  <end>
<start> memset ( nv_storage_encrypt_key ,  0 ,  16 )  ;  <end>
<start> } <end>
<start>  <end>
<start> NonVolatileReturn encryptedNonVolatileWrite ( uint8_t *data ,  NVPartitions partition ,  uint32_t address ,  uint32_t length )  <end>
<start> { <end>
<start> uint32_t block_start ;  <end>
<start> uint32_t block_end ;  <end>
<start> uint8_t block_offset ;  <end>
<start> uint8_t ciphertext[16] ;  <end>
<start> uint8_t plaintext[16] ;  <end>
<start> uint8_t n[16] ;  <end>
<start> NonVolatileReturn r ;  <end>
<start>  <end>
<start> block_start = address & 0xfffffff0 ;  <end>
<start> block_offset =  ( uint8_t )  ( address & 0x0000000f )  ;  <end>
<start> block_end =  ( address + length - 1 )  & 0xfffffff0 ;  <end>
<start> if  (  ( address + length )  < address )  <end>
<start> { <end>
<start> return NV_INVALID_ADDRESS ;  <end>
<start> } <end>
<start>  <end>
<start> memset ( n ,  0 ,  16 )  ;  <end>
<start> for  (  ;  block_start <= block_end ;  block_start += 16 )  <end>
<start> { <end>
<start> r = nonVolatileRead ( ciphertext ,  partition ,  block_start ,  16 )  ;  <end>
<start> if  ( r != NV_NO_ERROR )  <end>
<start> { <end>
<start> return r ;  <end>
<start> } <end>
<start> writeU32LittleEndian ( n ,  block_start )  ;  <end>
<start> xexDecrypt ( plaintext ,  ciphertext ,  n ,  1 )  ;  <end>
<start> while  ( length && block_offset < 16 )  <end>
<start> { <end>
<start> plaintext[block_offset++] = *data++ ;  <end>
<start> length-- ;  <end>
<start> } <end>
<start> block_offset = 0 ;  <end>
<start> xexEncrypt ( ciphertext ,  plaintext ,  n ,  1 )  ;  <end>
<start> r = nonVolatileWrite ( ciphertext ,  partition ,  block_start ,  16 )  ;  <end>
<start> if  ( r != NV_NO_ERROR )  <end>
<start> { <end>
<start> return r ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> return NV_NO_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> NonVolatileReturn encryptedNonVolatileRead ( uint8_t *data ,  NVPartitions partition ,  uint32_t address ,  uint32_t length )  <end>
<start> { <end>
<start> uint32_t block_start ;  <end>
<start> uint32_t block_end ;  <end>
<start> uint8_t block_offset ;  <end>
<start> uint8_t ciphertext[16] ;  <end>
<start> uint8_t plaintext[16] ;  <end>
<start> uint8_t n[16] ;  <end>
<start> NonVolatileReturn r ;  <end>
<start>  <end>
<start> block_start = address & 0xfffffff0 ;  <end>
<start> block_offset =  ( uint8_t )  ( address & 0x0000000f )  ;  <end>
<start> block_end =  ( address + length - 1 )  & 0xfffffff0 ;  <end>
<start> if  (  ( address + length )  < address )  <end>
<start> { <end>
<start> return NV_INVALID_ADDRESS ;  <end>
<start> } <end>
<start>  <end>
<start> memset ( n ,  0 ,  16 )  ;  <end>
<start> for  (  ;  block_start <= block_end ;  block_start += 16 )  <end>
<start> { <end>
<start> r = nonVolatileRead ( ciphertext ,  partition ,  block_start ,  16 )  ;  <end>
<start> if  ( r != NV_NO_ERROR )  <end>
<start> { <end>
<start> return r ;  <end>
<start> } <end>
<start> writeU32LittleEndian ( n ,  block_start )  ;  <end>
<start> xexDecrypt ( plaintext ,  ciphertext ,  n ,  1 )  ;  <end>
<start> while  ( length && block_offset < 16 )  <end>
<start> { <end>
<start> *data++ = plaintext[block_offset++] ;  <end>
<start> length-- ;  <end>
<start> } <end>
<start> block_offset = 0 ;  <end>
<start> } <end>
<start>  <end>
<start> return NV_NO_ERROR ;  <end>
<start> } <end>
<start>  <end>
<start> #ifdef TEST_XEX <end>
<start>  <end>
<start> static void scanTestVectors ( char *filename ,  int is_data_unit_seq_number )  <end>
<start> { <end>
<start> FILE *f ;  <end>
<start> int test_number ;  <end>
<start> unsigned int data_unit_length ;  <end>
<start> bool is_encrypt ;  <end>
<start> unsigned int i ;  <end>
<start> int j ;  <end>
<start> int value ;  <end>
<start> bool seen_count ;  <end>
<start> bool test_failed ;  <end>
<start> char buffer[100] ;  <end>
<start> uint8_t tweak_key[16] ;  <end>
<start> uint8_t encrypt_key[16] ;  <end>
<start> uint8_t tweak_value[16] ;  <end>
<start> uint8_t *plaintext ;  <end>
<start> uint8_t *ciphertext ;  <end>
<start> uint8_t *compare ;  <end>
<start>  <end>
<start> f = fopen ( filename ,  "r" )  ;  <end>
<start> if  ( f == NULL )  <end>
<start> { <end>
<start> printf ( "Could not open %s ,  please get it \ <end>
<start>  ( \"AES Known Answer Test  ( KAT )  Vectors\" )  \ <end>
<start> from http: <end>
<start> printf ( "There should be two versions: one with 128 bit hex strings as the tweak\n" )  ;  <end>
<start> printf ( "value ,  and one with a \"data unit sequence number\" as the tweak value.\n" )  ;  <end>
<start> printf ( "Rename the one with 128 bit hex string tweak values \"XTSGenAES128i.rsp\"\n" )  ;  <end>
<start> printf ( "and rename the one with data unit sequence numbers \"XTSGenAES128d.rsp\".\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start>  <end>
<start> test_number = 1 ;  <end>
<start> for  ( i = 0 ;  i < 11 ;  i++ )  <end>
<start> { <end>
<start> skipLine ( f )  ;  <end>
<start> } <end>
<start> is_encrypt = true ;  <end>
<start> while  ( !feof ( f )  )  <end>
<start> { <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start> seen_count = false ;  <end>
<start> while  ( !seen_count )  <end>
<start> { <end>
<start> fgets ( buffer ,  6 ,  f )  ;  <end>
<start> skipLine ( f )  ;  <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start> if  ( !strcmp ( buffer ,  "[DECR" )  )  <end>
<start> { <end>
<start> is_encrypt = false ;  <end>
<start> } <end>
<start> else if  ( !strcmp ( buffer ,  "COUNT" )  )  <end>
<start> { <end>
<start> seen_count = true ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> printf ( "Expected \"COUNT\" or \"[DECR\"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> fgets ( buffer ,  15 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "DataUnitLen = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"DataUnitLen = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> fscanf ( f ,  "%u" ,  &data_unit_length )  ;  <end>
<start> if  (  ( data_unit_length <= 0 )  ||  ( data_unit_length > 10000000 )  )  <end>
<start> { <end>
<start> printf ( "Error: got absurd data unit length %u\n" ,  data_unit_length )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start>  <end>
<start> if  (  ( data_unit_length & 0x7f )  != 0 )  <end>
<start> { <end>
<start> for  ( i = 0 ;  i < 6 ;  i++ )  <end>
<start> { <end>
<start> skipLine ( f )  ;  <end>
<start> } <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> data_unit_length >>= 3 ;   <end>
<start>  <end>
<start> fgets ( buffer ,  7 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "Key = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"Key = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < 16 ;  i++ )  <end>
<start> { <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start> encrypt_key[i] =  ( uint8_t ) value ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < 16 ;  i++ )  <end>
<start> { <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start> tweak_key[i] =  ( uint8_t ) value ;  <end>
<start> } <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start>  <end>
<start> if  ( is_data_unit_seq_number )  <end>
<start> { <end>
<start> int n ;  <end>
<start>  <end>
<start> fgets ( buffer ,  21 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "DataUnitSeqNumber = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"DataUnitSeqNumber = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> fscanf ( f ,  "%d" ,  &n )  ;  <end>
<start> memset ( tweak_value ,  0 ,  16 )  ;  <end>
<start> tweak_value[0] =  ( uint8_t ) n ;  <end>
<start> tweak_value[1] =  ( uint8_t )  ( n >> 8 )  ;  <end>
<start> tweak_value[2] =  ( uint8_t )  ( n >> 16 )  ;  <end>
<start> tweak_value[3] =  ( uint8_t )  ( n >> 24 )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> fgets ( buffer ,  5 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "i = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"i = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < 16 ;  i++ )  <end>
<start> { <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start> tweak_value[i] =  ( uint8_t ) value ;  <end>
<start> } <end>
<start> } <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start>  <end>
<start> plaintext = malloc ( data_unit_length )  ;  <end>
<start> ciphertext = malloc ( data_unit_length )  ;  <end>
<start> compare = malloc ( data_unit_length )  ;  <end>
<start>  <end>
<start> for  ( j = 0 ;  j < 2 ;  j++ )  <end>
<start> { <end>
<start> if  (  (  ( is_encrypt )  &&  ( j == 0 )  )  <end>
<start> ||  (  ( !is_encrypt )  &&  ( j != 0 )  )  )  <end>
<start> { <end>
<start> fgets ( buffer ,  6 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "PT = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"PT = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < data_unit_length ;  i++ )  <end>
<start> { <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start> plaintext[i] =  ( uint8_t ) value ;  <end>
<start> } <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> fgets ( buffer ,  6 ,  f )  ;  <end>
<start> if  ( strcmp ( buffer ,  "CT = " )  )  <end>
<start> { <end>
<start> printf ( "Parse error ;  expected \"CT = \"\n" )  ;  <end>
<start> exit ( 1 )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < data_unit_length ;  i++ )  <end>
<start> { <end>
<start> fscanf ( f ,  "%02x" ,  &value )  ;  <end>
<start> ciphertext[i] =  ( uint8_t ) value ;  <end>
<start> } <end>
<start> } <end>
<start> skipWhiteSpace ( f )  ;  <end>
<start> }  <end>
<start>  <end>
<start> test_failed = false ;  <end>
<start> if  ( is_encrypt )  <end>
<start> { <end>
<start> for  ( i = 0 ;  i < data_unit_length ;  i += 16 )  <end>
<start> { <end>
<start> xexEncryptInternal ( & ( compare[i] )  ,  & ( plaintext[i] )  ,  tweak_value ,   ( uint8_t )  ( i >> 4 )  ,  tweak_key ,  encrypt_key )  ;  <end>
<start> if  ( memcmp ( & ( compare[i] )  ,  & ( ciphertext[i] )  ,  16 )  )  <end>
<start> { <end>
<start> test_failed = true ;  <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> for  ( i = 0 ;  i < data_unit_length ;  i += 16 )  <end>
<start> { <end>
<start> xexDecryptInternal ( & ( compare[i] )  ,  & ( ciphertext[i] )  ,  tweak_value ,   ( uint8_t )  ( i >> 4 )  ,  tweak_key ,  encrypt_key )  ;  <end>
<start> if  ( memcmp ( & ( compare[i] )  ,  & ( plaintext[i] )  ,  16 )  )  <end>
<start> { <end>
<start> test_failed = true ;  <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> if  ( !test_failed )  <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> printf ( "Test %d failed\n" ,  test_number )  ;  <end>
<start> printf ( "Key: " )  ;  <end>
<start> printBigEndian16 ( encrypt_key )  ;  <end>
<start> printBigEndian16 ( tweak_key )  ;  <end>
<start> printf ( "\nFirst 16 bytes of plaintext: " )  ;  <end>
<start> printBigEndian16 ( plaintext )  ;  <end>
<start> printf ( "\nFirst 16 bytes of ciphertext: " )  ;  <end>
<start> printBigEndian16 ( ciphertext )  ;  <end>
<start> printf ( "\n" )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> test_number++ ;  <end>
<start> free ( plaintext )  ;  <end>
<start> free ( ciphertext )  ;  <end>
<start> free ( compare )  ;  <end>
<start> } <end>
<start> } <end>
<start> fclose ( f )  ;  <end>
<start> } <end>
<start>  <end>
<start> #define MAX_ADDRESS 1024 <end>
<start> /** Number of read/write tests to do. */ <end>
<start> #define NUM_RW_TESTS 100000 <end>
<start>  <end>
<start> int main ( void )  <end>
<start> { <end>
<start> uint8_t what_storage_should_be[MAX_ADDRESS] ;  <end>
<start> uint8_t buffer[512] ;  <end>
<start> uint8_t one_key[32] ;  <end>
<start> unsigned int i ;  <end>
<start> unsigned int j ;  <end>
<start>  <end>
<start> initTests ( __FILE__ )  ;  <end>
<start>  <end>
<start> initWalletTest (  )  ;  <end>
<start> clearEncryptionKey (  )  ;  <end>
<start>  <end>
<start> scanTestVectors ( "XTSGenAES128i.rsp" ,  0 )  ;  <end>
<start> scanTestVectors ( "XTSGenAES128d.rsp" ,  1 )  ;  <end>
<start>  <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i++ )  <end>
<start> { <end>
<start> what_storage_should_be[i] =  ( uint8_t ) rand (  )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start> { <end>
<start> encryptedNonVolatileWrite ( & ( what_storage_should_be[i] )  ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start> } <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start> { <end>
<start> encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start> if  ( memcmp ( & ( what_storage_should_be[i] )  ,  buffer ,  128 )  )  <end>
<start> { <end>
<start> printf ( "Storage mismatch in encryptedNonVolatileRead (  ) \n" )  ;  <end>
<start> printf ( "Initial fill ,  address = 0x%08x ,  length = 128\n" ,  i )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> for  ( i = 0 ;  i < NUM_RW_TESTS ;  i++ )  <end>
<start> { <end>
<start> uint32_t address ;  <end>
<start> uint32_t length ;  <end>
<start>  <end>
<start> do <end>
<start> { <end>
<start> address =  ( uint32_t )  ( rand (  )  &  ( MAX_ADDRESS - 1 )  )  ;  <end>
<start> length = rand (  )  % sizeof ( buffer )  ;  <end>
<start> } while  (  ( address + length )  > MAX_ADDRESS )  ;  <end>
<start> if  ( rand (  )  & 1 )  <end>
<start> { <end>
<start> for  ( j = 0 ;  j < length ;  j++ )  <end>
<start> { <end>
<start> buffer[j] =  ( uint8_t ) rand (  )  ;  <end>
<start> } <end>
<start> memcpy ( & ( what_storage_should_be[address] )  ,  buffer ,  length )  ;  <end>
<start> if  ( encryptedNonVolatileWrite ( buffer ,  PARTITION_ACCOUNTS ,  address ,  length )  != NV_NO_ERROR )  <end>
<start> { <end>
<start> printf ( "encryptedNonVolatileWrite (  )  failed\n" )  ;  <end>
<start> printf ( "test number = %u ,  address = 0x%08x ,  length = %d\n" ,  i ,   ( int ) address ,   ( int ) length )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> if  ( encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  address ,  length )  != NV_NO_ERROR )  <end>
<start> { <end>
<start> printf ( "encryptedNonVolatileRead (  )  failed\n" )  ;  <end>
<start> printf ( "test number = %u ,  address = 0x%08x ,  length = %d\n" ,  i ,   ( int ) address ,   ( int ) length )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> if  ( memcmp ( & ( what_storage_should_be[address] )  ,  buffer ,  length )  )  <end>
<start> { <end>
<start> printf ( "Storage mismatch in encryptedNonVolatileRead (  ) \n" )  ;  <end>
<start> printf ( "test number = %u ,  address = 0x%08x ,  length = %d\n" ,  i ,   ( int ) address ,   ( int ) length )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> memset ( one_key ,  0 ,  32 )  ;  <end>
<start> one_key[16] = 1 ;  <end>
<start> setEncryptionKey ( one_key )  ;  <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start> { <end>
<start> encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start> if  ( memcmp ( & ( what_storage_should_be[i] )  ,  buffer ,  128 )  )  <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> printf ( "Storage match in encryptedNonVolatileRead (  )  when using different tweak key\n" )  ;  <end>
<start> printf ( "Final run ,  address = 0x%08x ,  length = 128\n" ,  i )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> memset ( one_key ,  0 ,  32 )  ;  <end>
<start> one_key[0] = 1 ;  <end>
<start> setEncryptionKey ( one_key )  ;  <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start> { <end>
<start> encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start> if  ( memcmp ( & ( what_storage_should_be[i] )  ,  buffer ,  128 )  )  <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> printf ( "Storage match in encryptedNonVolatileRead (  )  when using different primary encryption key\n" )  ;  <end>
<start> printf ( "Final run ,  address = 0x%08x ,  length = 128\n" ,  i )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> clearEncryptionKey (  )  ;  <end>
<start> for  ( i = 0 ;  i < MAX_ADDRESS ;  i += 128 )  <end>
<start> { <end>
<start> encryptedNonVolatileRead ( buffer ,  PARTITION_ACCOUNTS ,  i ,  128 )  ;  <end>
<start> if  ( memcmp ( & ( what_storage_should_be[i] )  ,  buffer ,  128 )  )  <end>
<start> { <end>
<start> printf ( "Storage mismatch in encryptedNonVolatileRead (  )  when keys are okay\n" )  ;  <end>
<start> printf ( "Final run ,  address = 0x%08x ,  length = 128\n" ,  i )  ;  <end>
<start> reportFailure (  )  ;  <end>
<start> } <end>
<start> else <end>
<start> { <end>
<start> reportSuccess (  )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> finishTests (  )  ;  <end>
<start> exit ( 0 )  ;  <end>
<start> } <end>
<start>  <end>
<start> #endif  <end>
<start>  <end>
<start> #include <stdlib.h> <end>
<start> #include <stdio.h> <end>
<start> #include <stdarg.h> <end>
<start> #include <string.h> <end>
<start>  <end>
<start> #include "infra_httpc.h" <end>
<start> #include "infra_json_parser.h" <end>
<start> #include "infra_timer.h" <end>
<start> #include "infra_sha1.h" <end>
<start> #include "infra_report.h" <end>
<start> #include "http_debug.h" <end>
<start> #include "http_api.h" <end>
<start> #include "http_wrapper.h" <end>
<start>  <end>
<start>  <end>
<start>  <end>
<start> #ifdef INFRA_MEM_STATS <end>
<start>     #include "infra_mem_stats.h" <end>
<start>     #define HTTP_API_MALLOC ( size )                LITE_malloc ( size ,  MEM_MAGIC ,  "http.api" )  <end>
<start>     #define HTTP_API_FREE ( ptr )                   LITE_free ( ptr )  <end>
<start> #else <end>
<start>     #define HTTP_API_MALLOC ( size )                HAL_Malloc ( size )  <end>
<start>     #define HTTP_API_FREE ( ptr )                   {HAL_Free (  ( void * ) ptr )  ; ptr = NULL ; } <end>
<start> #endif <end>
<start>  <end>
<start> #define HTTP_LITE_JSON_VALUE_OF ( key ,  src )        LITE_json_value_of ( key ,  src ,  0x1234 ,  "http.api" )  <end>
<start>  <end>
<start> #ifndef CONFIG_MID_HTTP_TIMEOUT <end>
<start>     #define CONFIG_MID_HTTP_TIMEOUT              ( 5 * 1000 )  <end>
<start> #endif <end>
<start>  <end>
<start> #ifndef CONFIG_HTTP_AUTH_TIMEOUT <end>
<start>     #define CONFIG_HTTP_AUTH_TIMEOUT             ( 5 * 1000 )  <end>
<start> #endif <end>
<start>  <end>
<start> #define IOTX_HTTP_SIGN_LENGTH        ( 41 )  <end>
<start> #define IOTX_HTTP_SIGN_SOURCE_LEN    ( 256 )  <end>
<start> #define IOTX_HTTP_AUTH_TOKEN_LEN     ( 192+1 )  <end>
<start> #define IOTX_HTTP_URL_LEN_MAX        ( 135 )  <end>
<start>  <end>
<start> #ifdef IOTX_HTTP_TIMESTAMP_OPTIONAL_ENABLE <end>
<start> #define IOTX_HTTP_SIGN_SRC_STR          "clientId%sdeviceName%sproductKey%stimestamp%s" <end>
<start> #define IOTX_HTTP_AUTH_DEVICENAME_STR   \ <end>
<start>     "{" \ <end>
<start>     "\"version\":\"%s\" ,  \"clientId\":\"%s\" , " \ <end>
<start>     "\"signmethod\":\"%s\" , \"sign\":\"%s\" , " \ <end>
<start>     "\"productKey\":\"%s\" , \"deviceName\":\"%s\" , " \ <end>
<start>     "\"timestamp\":\"%s\"" \ <end>
<start>     "}" <end>
<start> #else <end>
<start> #define IOTX_HTTP_SIGN_SRC_STR          "clientId%sdeviceName%sproductKey%s" <end>
<start> #define IOTX_HTTP_AUTH_DEVICENAME_STR   \ <end>
<start>     "{" \ <end>
<start>     "\"version\":\"%s\" ,  \"clientId\":\"%s\" , " \ <end>
<start>     "\"signmethod\":\"%s\" , \"sign\":\"%s\" , " \ <end>
<start>     "\"productKey\":\"%s\" , \"deviceName\":\"%s\"" \ <end>
<start>     "}" <end>
<start> #endif <end>
<start>  <end>
<start> #define IOTX_HTTP_AUTH_STR              "auth" <end>
<start> #define IOTX_HTTP_ONLINE_SERVER_URL     "https: <end>
<start> #define IOTX_HTTP_ONLINE_SERVER_PORT    443 <end>
<start>  <end>
<start> #define IOTX_SHA_METHOD                 "hmacsha1" <end>
<start>  <end>
<start> #define IOTX_HTTP_HEADER_KEEPALIVE_STR  "Connection: Keep-Alive\r\n" <end>
<start> #define IOTX_HTTP_HEADER_PASSWORD_STR   "password:" <end>
<start> #define IOTX_HTTP_UPSTREAM_HEADER_STR   \ <end>
<start>     IOTX_HTTP_HEADER_KEEPALIVE_STR \ <end>
<start>     IOTX_HTTP_HEADER_PASSWORD_STR \ <end>
<start>     "%s" \ <end>
<start>     IOTX_HTTP_HEADER_END_STR <end>
<start> #define IOTX_HTTP_HEADER_END_STR "\r\n" <end>
<start>  <end>
<start> #define HTTP_AUTH_RESP_MAX_LEN       ( 256 )  <end>
<start>  <end>
<start> static iotx_http_t *iotx_http_context_bak = NULL ;  <end>
<start>  <end>
<start>  <end>
<start>  <end>
<start> static int iotx_calc_sign ( const char *p_device_secret ,  const char *p_msg ,  char *sign )  <end>
<start> { <end>
<start>     http_info ( "| method: %s" ,  IOTX_SHA_METHOD )  ;  <end>
<start>     utils_hmac_sha1 ( p_msg ,  strlen ( p_msg )  ,  sign ,  p_device_secret ,  strlen ( p_device_secret )  )  ;  <end>
<start>     return SUCCESS_RETURN ;  <end>
<start> } <end>
<start>  <end>
<start> static int calc_snprintf_string_length ( char *fmt ,  ... )  <end>
<start> { <end>
<start>     va_list args ;  <end>
<start>     int     rc = 0 ;  <end>
<start>     char *p = NULL ;  <end>
<start>     char *sval = NULL ;  <end>
<start>  <end>
<start>     if  ( NULL == fmt )  { <end>
<start>         return -1 ;  <end>
<start>     } <end>
<start>  <end>
<start>     va_start ( args ,  fmt )  ;  <end>
<start>  <end>
<start>     for  ( p = fmt ;  *p ;  p++ )  { <end>
<start>         if  ( *p != '%' )  { <end>
<start>             rc++ ;  <end>
<start>             continue ;  <end>
<start>         } <end>
<start>         switch  ( *++p )  { <end>
<start>             case 's': <end>
<start>                 for  ( sval = va_arg ( args ,  char * )  ;  *sval ;  sval++ )  { <end>
<start>                     rc++ ;  <end>
<start>                 } <end>
<start>                 break ;  <end>
<start>             default: <end>
<start>                 rc++ ;  <end>
<start>                 break ;  <end>
<start>         } <end>
<start>     } <end>
<start>  <end>
<start>     va_end ( args )  ;  <end>
<start>  <end>
<start>     return rc ;  <end>
<start> } <end>
<start>  <end>
<start> static int construct_full_http_authenticate_url ( char *buf )  <end>
<start> { <end>
<start>     LITE_snprintf ( buf ,  IOTX_HTTP_URL_LEN_MAX ,  <end>
<start>                   "%s/%s" ,  IOTX_HTTP_ONLINE_SERVER_URL ,  IOTX_HTTP_AUTH_STR )  ;  <end>
<start>     http_info ( "get_http_authenticate_url is %s" ,  buf )  ;  <end>
<start>     return 0 ;  <end>
<start> } <end>
<start>  <end>
<start> static int construct_full_http_upstream_url ( char *buf ,  const char *topic_path )  <end>
<start> { <end>
<start>     LITE_snprintf ( buf ,  IOTX_HTTP_URL_LEN_MAX ,  <end>
<start>                   "%s%s" ,  IOTX_HTTP_ONLINE_SERVER_URL ,  topic_path )  ;  <end>
<start>     http_info ( "construct_full_http_upstream_url is %s" ,  buf )  ;  <end>
<start>     return 0 ;  <end>
<start> } <end>
<start>  <end>
<start> static int http_report_func ( void *handle ,  const char *topic_name ,  int req_ack ,  void *data ,  int len )  <end>
<start> { <end>
<start>     iotx_http_message_param_t   msg_param ;  <end>
<start>     char                        request_buf[1024] ;  <end>
<start>     char                        topic_path[100] ;  <end>
<start>  <end>
<start>     if  ( handle == NULL || topic_name == NULL || data == NULL )  { <end>
<start>         http_err ( "params err" )  ;  <end>
<start>         return -1 ;  <end>
<start>     } <end>
<start>  <end>
<start>     HAL_Snprintf ( topic_path ,  sizeof ( topic_path )  ,  "/topic%s" ,  topic_name )  ;  <end>
<start>  <end>
<start>     memset ( &msg_param ,  0 ,  sizeof ( iotx_http_message_param_t )  )  ;  <end>
<start>     msg_param.request_payload =  ( char * ) data ;  <end>
<start>     msg_param.response_payload = request_buf ;  <end>
<start>     msg_param.timeout_ms = CONFIG_MID_HTTP_TIMEOUT ;  <end>
<start>     msg_param.request_payload_len = len ;  <end>
<start>     msg_param.response_payload_len = 1024 ;  <end>
<start>     msg_param.topic_path = topic_path ;  <end>
<start>  <end>
<start>     return IOT_HTTP_SendMessage ( handle ,  &msg_param )  ;  <end>
<start> } <end>
<start>  <end>
<start> static void *verify_iotx_http_context ( void *handle )  <end>
<start> { <end>
<start>     iotx_http_t *iotx_http_context =  ( iotx_http_t * ) handle ;  <end>
<start>  <end>
<start>     if  ( NULL == iotx_http_context || <end>
<start>         NULL == iotx_http_context_bak || <end>
<start>         iotx_http_context_bak != iotx_http_context )  { <end>
<start>         http_err ( "iotx_http_context not valid pointer!" )  ;  <end>
<start>  <end>
<start>         iotx_http_context =  NULL ;  <end>
<start>     } <end>
<start>  <end>
<start>     return iotx_http_context ;  <end>
<start> } <end>
<start>  <end>
<start> void *IOT_HTTP_Init ( iotx_http_param_t *pInitParams )  <end>
<start> { <end>
<start>     iotx_device_info_t *p_devinfo ;  <end>
<start>     iotx_http_t        *iotx_http_context ;  <end>
<start>  <end>
<start>      <end>
<start>     if  ( NULL != iotx_http_context_bak )  { <end>
<start>         http_err ( "Init twice not allowed ,  please deinit first" )  ;  <end>
<start>         return NULL ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL == pInitParams || NULL == pInitParams->device_info )  { <end>
<start>         http_err ( "Invalid argument: pInitParams or device_info = NULL" )  ;  <end>
<start>         return NULL ;  <end>
<start>     } <end>
<start>  <end>
<start>     p_devinfo = pInitParams->device_info ;  <end>
<start>  <end>
<start>  <end>
<start>     iotx_http_context =  ( iotx_http_t * ) HTTP_API_MALLOC ( sizeof ( iotx_http_t )  )  ;  <end>
<start>  <end>
<start>     if  ( NULL == iotx_http_context )  { <end>
<start>         http_err ( "Allocate memory for iotx_http_context failed" )  ;  <end>
<start>         return NULL ;  <end>
<start>     } <end>
<start>  <end>
<start>     memset ( iotx_http_context ,  0x00 ,  sizeof ( iotx_http_t )  )  ;  <end>
<start>  <end>
<start>     iotx_http_context->keep_alive = pInitParams->keep_alive ;  <end>
<start>     iotx_http_context->timeout_ms = pInitParams->timeout_ms ;  <end>
<start>     iotx_http_context->p_auth_token = HTTP_API_MALLOC ( IOTX_HTTP_AUTH_TOKEN_LEN )  ;  <end>
<start>     if  ( NULL == iotx_http_context->p_auth_token )  { <end>
<start>         http_err ( "Allocate memory for auth token failed" )  ;  <end>
<start>         goto err ;  <end>
<start>     } <end>
<start>     memset ( iotx_http_context->p_auth_token ,  0x00 ,  IOTX_HTTP_AUTH_TOKEN_LEN )  ;  <end>
<start>     iotx_http_context->is_authed = 0 ;  <end>
<start>     iotx_http_context->auth_token_len = IOTX_HTTP_AUTH_TOKEN_LEN ;  <end>
<start>  <end>
<start>      <end>
<start>     iotx_http_context->p_devinfo =  ( iotx_device_info_t * ) HTTP_API_MALLOC ( sizeof ( iotx_device_info_t )  )  ;  <end>
<start>     if  ( NULL == iotx_http_context->p_devinfo )  { <end>
<start>         http_err ( "Allocate memory for iotx_http_context->p_devinfo failed" )  ;  <end>
<start>         goto err ;  <end>
<start>     } <end>
<start>     memset ( iotx_http_context->p_devinfo ,  0x00 ,  sizeof ( iotx_device_info_t )  )  ;  <end>
<start>  <end>
<start>      <end>
<start>     memset ( iotx_http_context->p_devinfo ,  0x00 ,  sizeof ( iotx_device_info_t )  )  ;  <end>
<start>     strncpy ( iotx_http_context->p_devinfo->device_id ,      p_devinfo->device_id ,      strlen ( p_devinfo->device_id )  )  ;  <end>
<start>     strncpy ( iotx_http_context->p_devinfo->product_key ,    p_devinfo->product_key ,    strlen ( p_devinfo->product_key )  )  ;  <end>
<start>     strncpy ( iotx_http_context->p_devinfo->device_secret ,  p_devinfo->device_secret ,  strlen ( p_devinfo->device_secret )  )  ;  <end>
<start>     strncpy ( iotx_http_context->p_devinfo->device_name ,    p_devinfo->device_name ,    strlen ( p_devinfo->device_name )  )  ;  <end>
<start>  <end>
<start>     iotx_http_context->httpc = HTTP_API_MALLOC ( sizeof ( httpclient_t )  )  ;  <end>
<start>     if  ( NULL == iotx_http_context->httpc )  { <end>
<start>         http_err ( "Allocate memory for iotx_http_context->httpc failed" )  ;  <end>
<start>         goto err ;  <end>
<start>     } <end>
<start>     memset ( iotx_http_context->httpc ,  0x00 ,  sizeof ( httpclient_t )  )  ;  <end>
<start>  <end>
<start>     iotx_http_context_bak = iotx_http_context ;  <end>
<start>  <end>
<start>     return iotx_http_context ;  <end>
<start> err: <end>
<start>      <end>
<start>     if  ( NULL != iotx_http_context )  { <end>
<start>         if  ( NULL != iotx_http_context->p_devinfo )  { <end>
<start>             HTTP_API_FREE ( iotx_http_context->p_devinfo )  ;  <end>
<start>         } <end>
<start>         if  ( NULL != iotx_http_context->p_auth_token )  { <end>
<start>             HTTP_API_FREE ( iotx_http_context->p_auth_token )  ;  <end>
<start>         } <end>
<start>  <end>
<start>         iotx_http_context->auth_token_len = 0 ;  <end>
<start>         HTTP_API_FREE ( iotx_http_context )  ;  <end>
<start>     } <end>
<start>     return NULL ;  <end>
<start> } <end>
<start>  <end>
<start> void IOT_HTTP_DeInit ( void **handle )  <end>
<start> { <end>
<start>     iotx_http_t *iotx_http_context ;  <end>
<start>     if  ( NULL == handle )  { <end>
<start>         http_err ( "handle is NULL pointer" )  ;  <end>
<start>         return ;  <end>
<start>     } <end>
<start>     if  ( NULL ==  ( iotx_http_context = verify_iotx_http_context ( *handle )  )  )  { <end>
<start>         return ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL != iotx_http_context->p_devinfo )  { <end>
<start>         HTTP_API_FREE ( iotx_http_context->p_devinfo )  ;  <end>
<start>     } <end>
<start>     if  ( NULL != iotx_http_context->p_auth_token )  { <end>
<start>         HTTP_API_FREE ( iotx_http_context->p_auth_token )  ;  <end>
<start>     } <end>
<start>     if  ( NULL != iotx_http_context->httpc )  { <end>
<start>         HTTP_API_FREE ( iotx_http_context->httpc )  ;  <end>
<start>     } <end>
<start>  <end>
<start>     iotx_http_context->auth_token_len = 0 ;  <end>
<start>     HTTP_API_FREE ( iotx_http_context )  ;  <end>
<start>     iotx_http_context_bak = NULL ;  <end>
<start> } <end>
<start>  <end>
<start> int IOT_HTTP_DeviceNameAuth ( void *handle )  <end>
<start> { <end>
<start>     int                 ret = -1 ;  <end>
<start>     int                 ret_code = 0 ;  <end>
<start>     char               *pvalue = NULL ;  <end>
<start>     char               *response_message = NULL ;  <end>
<start>     char                sign[IOTX_HTTP_SIGN_LENGTH]   = {0} ;  <end>
<start>     char                http_url[IOTX_HTTP_URL_LEN_MAX] = {0} ;  <end>
<start>     char                timestamp[14] = {0} ;  <end>
<start>     httpclient_t       *httpc ;  <end>
<start>     httpclient_data_t   httpc_data = {0} ;  <end>
<start>     char               *req_payload = NULL ;  <end>
<start>     char               *rsp_payload = NULL ;  <end>
<start>     int                 len = 0 ;  <end>
<start>     char                p_msg_unsign[IOTX_HTTP_SIGN_SOURCE_LEN] = {0} ;  <end>
<start>     iotx_time_t         timer ;  <end>
<start>     iotx_http_t        *iotx_http_context ;  <end>
<start>     const char          *pub_key = NULL ;  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>     if  ( NULL ==  ( iotx_http_context = verify_iotx_http_context ( handle )  )  )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>     iotx_http_context->is_authed = 0 ;  <end>
<start>  <end>
<start>      <end>
<start>     /* <end>
<start>     if ( !utils_get_epoch_time_from_ntp ( timestamp ,  sizeof ( timestamp )  )  )  <end>
<start>     { <end>
<start>             http_info ( "http time response: \r\n\r\n%s" ,  timestamp )  ;  <end>
<start>             goto do_exit ;  <end>
<start>     } <end>
<start>     */ <end>
<start>  <end>
<start>      <end>
<start>     LITE_snprintf ( p_msg_unsign ,  IOTX_HTTP_SIGN_SOURCE_LEN ,  <end>
<start>                   IOTX_HTTP_SIGN_SRC_STR ,  <end>
<start>                   iotx_http_context->p_devinfo->device_id ,  <end>
<start>                   iotx_http_context->p_devinfo->device_name ,  <end>
<start>                   iotx_http_context->p_devinfo->product_key <end>
<start> #ifdef IOTX_HTTP_TIMESTAMP_OPTIONAL_ENABLE <end>
<start>                    ,  timestamp <end>
<start> #endif <end>
<start>                   )  ;  <end>
<start>  <end>
<start>     iotx_calc_sign ( iotx_http_context->p_devinfo->device_secret ,  p_msg_unsign ,  sign )  ;  <end>
<start>  <end>
<start>      <end>
<start>     len = calc_snprintf_string_length ( IOTX_HTTP_AUTH_DEVICENAME_STR ,  <end>
<start>                                       "default" ,  <end>
<start>                                       iotx_http_context->p_devinfo->device_id ,  <end>
<start>                                       IOTX_SHA_METHOD ,  <end>
<start>                                       sign ,  <end>
<start>                                       iotx_http_context->p_devinfo->product_key ,  <end>
<start>                                       iotx_http_context->p_devinfo->device_name ,  <end>
<start>                                       timestamp <end>
<start>                                       )  ;  <end>
<start>  <end>
<start>     if  ( len < 0 )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     req_payload =  ( char * ) HTTP_API_MALLOC ( len + 1 )  ;  <end>
<start>     memset ( req_payload ,  0 ,  len + 1 )  ;  <end>
<start>  <end>
<start>     http_debug ( "allocate req_payload: len = %d" ,  len )  ;  <end>
<start>  <end>
<start>     len = HAL_Snprintf ( req_payload ,  len + 1 ,  <end>
<start>                        IOTX_HTTP_AUTH_DEVICENAME_STR ,  <end>
<start>                        "default" ,  <end>
<start>                        iotx_http_context->p_devinfo->device_id ,  <end>
<start>                        IOTX_SHA_METHOD ,  <end>
<start>                        sign ,  <end>
<start>                        iotx_http_context->p_devinfo->product_key ,  <end>
<start>                        iotx_http_context->p_devinfo->device_name ,  <end>
<start>                        timestamp <end>
<start>                        )  ;  <end>
<start>     http_debug ( "len = %d ,  req_payload: \r\n%s" ,  len ,  req_payload )  ;  <end>
<start>  <end>
<start>      <end>
<start>     rsp_payload =  ( char * ) HTTP_API_MALLOC ( HTTP_AUTH_RESP_MAX_LEN )  ;  <end>
<start>     if  ( NULL == rsp_payload )  { <end>
<start>         http_err ( "Allocate HTTP rsp_payload buf failed!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>     memset ( rsp_payload ,  0 ,  HTTP_AUTH_RESP_MAX_LEN )  ;  <end>
<start>  <end>
<start>      <end>
<start>     construct_full_http_authenticate_url ( http_url )  ;  <end>
<start>  <end>
<start>      <end>
<start>     httpc =  ( httpclient_t * ) iotx_http_context->httpc ;  <end>
<start>  <end>
<start>     httpc_data.post_content_type = "application/json" ;  <end>
<start>     httpc_data.post_buf = req_payload ;  <end>
<start>     httpc_data.post_buf_len = len ;  <end>
<start>     httpc_data.response_buf = rsp_payload ;  <end>
<start>     httpc_data.response_buf_len = HTTP_AUTH_RESP_MAX_LEN ;  <end>
<start>  <end>
<start>     httpc->header = "Connection: Keep-Alive\r\n" ;  <end>
<start>  <end>
<start>     /* <end>
<start>     Test Code <end>
<start>     iotx_http_context->p_auth_token = "eyJ0eXBlIjoiSldUIiwiYWxnIjoiaG1hY3NoYTEifQ.eyJleHBpcmUiOjE1MDQ3ODE4MzQ5MDAsInRva2VuIjoiM2EyZTRmYzMyNjk5NDE0Y2E3MDFjNzIzNzI1YjIyNDgifQ.e87AFhkvNKiqF5xdgm1P47f9DwY" ;  <end>
<start>     iotx_http_context->is_authed = 1 ;  <end>
<start>     ret = 0 ;  <end>
<start>     goto do_exit ;  <end>
<start>     Test Code <end>
<start>     */ <end>
<start>  <end>
<start>     { <end>
<start>         extern const char *iotx_ca_crt ;  <end>
<start>         pub_key = iotx_ca_crt ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     if  ( 0 != iotx_post ( httpc ,  <end>
<start>                        http_url ,  <end>
<start>                        IOTX_HTTP_ONLINE_SERVER_PORT ,  <end>
<start>                        pub_key ,  <end>
<start>                        &httpc_data )  )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     iotx_time_init ( &timer )  ;  <end>
<start>     utils_time_countdown_ms ( &timer ,  CONFIG_HTTP_AUTH_TIMEOUT )  ;  <end>
<start>  <end>
<start>  <end>
<start>     ret = httpclient_recv_response ( httpc ,  iotx_time_left ( &timer )  ,  &httpc_data )  ;  <end>
<start>     if  ( ret < 0 )  { <end>
<start>         http_err ( "httpclient_recv_response error ,  ret = %d" ,  ret )  ;  <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>         return ret ;  <end>
<start>     } <end>
<start>     if  ( 0 == iotx_http_context->keep_alive )  { <end>
<start>         http_info ( "http not keepalive" )  ;  <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>     } <end>
<start>     /* <end>
<start>     body: <end>
<start>     { <end>
<start>       "code": 0 ,  <end>
<start>       "message": "success" ,  <end>
<start>       "info": { <end>
<start>         "token": "eyJ0eXBlIjoiSldUIiwiYWxnIjoiaG1hY3NoYTEifQ.eyJleHBpcmUiOjE1MDI1MzE1MDc0NzcsInRva2VuIjoiODA0ZmFjYTBiZTE3NGUxNjliZjY0ODVlNWNiNDg3MTkifQ.OjMwu29F0CY2YR_6oOyiOLXz0c8" <end>
<start>       } <end>
<start>     } <end>
<start>     */ <end>
<start>     http_info ( "http response: \r\n\r\n%s\r\n" ,  httpc_data.response_buf )  ;  <end>
<start>  <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "code" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( !pvalue )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>     ret_code = atoi ( pvalue )  ;  <end>
<start>     http_info ( "ret_code = %d" ,  ret_code )  ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "message" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( NULL == pvalue )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>     response_message = pvalue ;  <end>
<start>     http_info ( "response_message: %s" ,  response_message )  ;  <end>
<start>      ( void ) response_message ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>     switch  ( ret_code )  { <end>
<start>         case IOTX_HTTP_SUCCESS: <end>
<start>             break ;  <end>
<start>         case IOTX_HTTP_COMMON_ERROR: <end>
<start>         case IOTX_HTTP_PARAM_ERROR: <end>
<start>         case IOTX_HTTP_AUTH_CHECK_ERROR: <end>
<start>         case IOTX_HTTP_UPDATE_SESSION_ERROR: <end>
<start>         case IOTX_HTTP_REQUEST_TOO_MANY_ERROR: <end>
<start>         default: <end>
<start>             ret = FAIL_RETURN ;  <end>
<start>             goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "info.token" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( NULL == pvalue )  { <end>
<start>         http_err ( "can't get token from json ,  Abort!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if ( strlen ( pvalue )  > IOTX_HTTP_AUTH_TOKEN_LEN - 1 )  { <end>
<start>         http_err ( "token is out of size" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     strcpy ( iotx_http_context->p_auth_token ,  pvalue )  ;  <end>
<start>     iotx_http_context->is_authed = 1 ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>  <end>
<start>     iotx_set_report_func ( http_report_func )  ;  <end>
<start>      <end>
<start>     ret = iotx_report_mid ( iotx_http_context )  ;  <end>
<start>     if  ( SUCCESS_RETURN != ret )  { <end>
<start>         http_err ( "Send ModuleId message to server ( Http )  failed ,  ret = %d" ,  ret )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>      <end>
<start>     ret = iotx_report_devinfo ( iotx_http_context )  ;  <end>
<start>     if  ( SUCCESS_RETURN != ret )  { <end>
<start>         http_err ( "Send devinfo message to server ( Http )  failed ,  ret = %d" ,  ret )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>      <end>
<start>     ret = iotx_report_firmware_version ( iotx_http_context )  ;  <end>
<start>     if  ( SUCCESS_RETURN != ret )  { <end>
<start>         http_err ( "Send firmware message to server ( Http )  failed ,  ret = %d" ,  ret )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     ret = 0 ;  <end>
<start>  <end>
<start> do_exit: <end>
<start>     if  ( pvalue )  { <end>
<start>         HTTP_API_FREE ( pvalue )  ;  <end>
<start>         pvalue = NULL ;  <end>
<start>     } <end>
<start>     if  ( req_payload )  { <end>
<start>         HTTP_API_FREE ( req_payload )  ;  <end>
<start>         req_payload = NULL ;  <end>
<start>     } <end>
<start>     if  ( rsp_payload )  { <end>
<start>         HTTP_API_FREE ( rsp_payload )  ;  <end>
<start>         rsp_payload = NULL ;  <end>
<start>     } <end>
<start>  <end>
<start>     return ret ;  <end>
<start> } <end>
<start>  <end>
<start> int IOT_HTTP_SendMessage ( void *handle ,  iotx_http_message_param_t *msg_param )  <end>
<start> { <end>
<start>     int                 ret = -1 ;  <end>
<start>     int                 response_code = 0 ;  <end>
<start>     char               *pvalue = NULL ;  <end>
<start>     char                http_url[IOTX_HTTP_URL_LEN_MAX] = {0} ;  <end>
<start>     httpclient_t       *httpc = NULL ;  <end>
<start>     httpclient_data_t   httpc_data = {0} ;  <end>
<start>     char               *messageId = NULL ;  <end>
<start>     char               *user_data = NULL ;  <end>
<start>     int                 len = 0 ;  <end>
<start>     uint32_t            payload_len = 0 ;  <end>
<start>     iotx_time_t         timer ;  <end>
<start>     iotx_http_t        *iotx_http_context ;  <end>
<start>     const char         *pub_key = NULL ;  <end>
<start>     /* <end>
<start>         POST /topic/${topic} HTTP/1.1 <end>
<start>         Host: iot-as-http.cn-shanghai.aliyuncs.com <end>
<start>         password:${token} <end>
<start>         Content-Type: application/octet-stream <end>
<start>         body: ${your_data} <end>
<start>     */ <end>
<start>     if  ( NULL ==  ( iotx_http_context = verify_iotx_http_context ( handle )  )  )  { <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL == msg_param )  { <end>
<start>         http_err ( "iotx_http_context or msg_param NULL pointer!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     httpc =  ( httpclient_t * ) iotx_http_context->httpc ;  <end>
<start>  <end>
<start>     if  ( NULL == httpc )  { <end>
<start>         http_err ( "httpc null pointer" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( 0 == iotx_http_context->is_authed )  { <end>
<start>         http_err ( "Device is not authed" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL == msg_param->request_payload )  { <end>
<start>         http_err ( "IOT_HTTP_SendMessage request_payload NULL!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL == msg_param->response_payload )  { <end>
<start>         http_err ( "IOT_HTTP_SendMessage response_payload NULL!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( NULL == msg_param->topic_path )  { <end>
<start>         http_err ( "IOT_HTTP_SendMessage topic_path NULL!" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>  <end>
<start>     payload_len = strlen ( msg_param->request_payload )  + 1 ;  <end>
<start>     msg_param->request_payload_len = msg_param->request_payload_len > payload_len \ <end>
<start>                                      ? payload_len : msg_param->request_payload_len ;  <end>
<start>  <end>
<start>      <end>
<start>     construct_full_http_upstream_url ( http_url ,  msg_param->topic_path )  ;  <end>
<start>  <end>
<start>     len = strlen ( IOTX_HTTP_HEADER_PASSWORD_STR )  + strlen ( iotx_http_context->p_auth_token )  + strlen (  <end>
<start>                       IOTX_HTTP_HEADER_KEEPALIVE_STR )  + strlen ( IOTX_HTTP_HEADER_END_STR )  ;  <end>
<start>     httpc->header = HTTP_API_MALLOC ( len + 1 )  ;  <end>
<start>     if  ( NULL == httpc->header )  { <end>
<start>         http_err ( "Allocate memory for httpc->header failed" )  ;  <end>
<start>         goto do_exit ;  <end>
<start>     } <end>
<start>     LITE_snprintf ( httpc->header ,  len + 1 ,  <end>
<start>                   IOTX_HTTP_UPSTREAM_HEADER_STR ,  iotx_http_context->p_auth_token )  ;  <end>
<start>     http_info ( "httpc->header = %s" ,  httpc->header )  ;  <end>
<start>  <end>
<start>     httpc_data.post_content_type = "application/octet-stream" ;  <end>
<start>     httpc_data.post_buf = msg_param->request_payload ;  <end>
<start>     httpc_data.post_buf_len = msg_param->request_payload_len ;  <end>
<start>     httpc_data.response_buf = msg_param->response_payload ;  <end>
<start>     httpc_data.response_buf_len = msg_param->response_payload_len ;  <end>
<start>  <end>
<start>     http_info ( "request_payload: \r\n\r\n%s\r\n" ,  httpc_data.post_buf )  ;  <end>
<start>  <end>
<start>     { <end>
<start>         extern const char *iotx_ca_crt ;  <end>
<start>         pub_key = iotx_ca_crt ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     if  ( iotx_post ( httpc ,  <end>
<start>                   http_url ,  <end>
<start>                   IOTX_HTTP_ONLINE_SERVER_PORT ,  <end>
<start>                   pub_key ,  <end>
<start>                   &httpc_data )  )  { <end>
<start>         goto do_exit_pre ;  <end>
<start>     } <end>
<start>     iotx_time_init ( &timer )  ;  <end>
<start>     utils_time_countdown_ms ( &timer ,  msg_param->timeout_ms )  ;  <end>
<start>  <end>
<start>     ret = httpclient_recv_response ( httpc ,  iotx_time_left ( &timer )  ,  &httpc_data )  ;  <end>
<start>     if  ( ret < 0 )  { <end>
<start>         http_err ( "httpclient_recv_response error ,  ret = %d" ,  ret )  ;  <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>         goto do_exit_pre ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( 0 == iotx_http_context->keep_alive )  { <end>
<start>         httpclient_close ( httpc )  ;  <end>
<start>     } <end>
<start>  <end>
<start>     /* <end>
<start>         body: <end>
<start>         { <end>
<start>           "code": 0 ,  <end>
<start>           "message": "success" ,  <end>
<start>           "info": { <end>
<start>             "messageId": 892687627916247040 ,  <end>
<start>             "data": byte[] <end>
<start>           } <end>
<start>         } <end>
<start>     */ <end>
<start>     http_info ( "http response: \r\n\r\n%s\r\n" ,  httpc_data.response_buf )  ;  <end>
<start>  <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "code" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( !pvalue )  { <end>
<start>         goto do_exit_pre ;  <end>
<start>     } <end>
<start>  <end>
<start>     response_code = atoi ( pvalue )  ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>     http_info ( "response code: %d" ,  response_code )  ;  <end>
<start>  <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "message" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( NULL == pvalue )  { <end>
<start>         goto do_exit_pre ;  <end>
<start>     } <end>
<start>     http_info ( "response_message: %s" ,  pvalue )  ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>     switch  ( response_code )  { <end>
<start>         case IOTX_HTTP_SUCCESS: <end>
<start>             break ;  <end>
<start>         case IOTX_HTTP_TOKEN_EXPIRED_ERROR: <end>
<start>             iotx_http_context->is_authed = IOT_FALSE ;  <end>
<start>             IOT_HTTP_DeviceNameAuth (  ( iotx_http_t * ) iotx_http_context )  ;  <end>
<start>         case IOTX_HTTP_COMMON_ERROR: <end>
<start>         case IOTX_HTTP_PARAM_ERROR: <end>
<start>         case IOTX_HTTP_AUTH_CHECK_ERROR: <end>
<start>         case IOTX_HTTP_TOKEN_NULL_ERROR: <end>
<start>         case IOTX_HTTP_TOKEN_CHECK_ERROR: <end>
<start>         case IOTX_HTTP_UPDATE_SESSION_ERROR: <end>
<start>         case IOTX_HTTP_PUBLISH_MESSAGE_ERROR: <end>
<start>         case IOTX_HTTP_REQUEST_TOO_MANY_ERROR: <end>
<start>         default: <end>
<start>             goto do_exit_pre ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "info.messageId" ,  httpc_data.response_buf )  ;  <end>
<start>     if  ( NULL == pvalue )  { <end>
<start>         http_err ( "messageId: NULL" )  ;  <end>
<start>         goto do_exit_pre ;  <end>
<start>     } <end>
<start>     messageId = pvalue ;  <end>
<start>     http_info ( "messageId: %s" ,  messageId )  ;  <end>
<start>      ( void ) messageId ;  <end>
<start>     HTTP_API_FREE ( pvalue )  ;  <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>      <end>
<start>     pvalue = HTTP_LITE_JSON_VALUE_OF ( "info.data" ,  httpc_data.response_buf )  ;  <end>
<start>     user_data = pvalue ;  <end>
<start>  <end>
<start>      <end>
<start>     if  ( user_data )  { <end>
<start>         http_info ( "user_data: %s" ,  user_data )  ;  <end>
<start>     } else { <end>
<start>         http_info ( "user_data: %p" ,  user_data )  ;  <end>
<start>     } <end>
<start>     if  ( NULL != pvalue )  { <end>
<start>         HTTP_API_FREE ( pvalue )  ;  <end>
<start>     } <end>
<start>     pvalue = NULL ;  <end>
<start>  <end>
<start>     ret = 0 ;  <end>
<start>  <end>
<start> do_exit_pre: <end>
<start>  <end>
<start>     if  ( pvalue )  { <end>
<start>         HTTP_API_FREE ( pvalue )  ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  ( httpc != NULL && httpc->header )  { <end>
<start>         HTTP_API_FREE ( httpc->header )  ;  <end>
<start>     } <end>
<start>  <end>
<start> do_exit: <end>
<start>  <end>
<start>     return ret ;  <end>
<start> } <end>
<start>  <end>
<start> void IOT_HTTP_Disconnect ( void *handle )  <end>
<start> { <end>
<start>     iotx_http_t *iotx_http_context ;  <end>
<start>     if  ( NULL !=  ( iotx_http_context = verify_iotx_http_context ( handle )  )  )  { <end>
<start>         httpclient_close ( iotx_http_context->httpc )  ;  <end>
<start>     } <end>
<start> } <end>
<start>  <end>
<start> #include <SPI.h> <end>
<start> #include <Adafruit_GFX.h> <end>
<start> #include <TFT_ILI9163C.h> <end>
<start> #include <Adafruit_Fingerprint.h> <end>
<start> #include <SoftwareSerial.h> <end>
<start>  <end>
<start> #define BLACK   0x0000 <end>
<start> #define BLUE    0x001F <end>
<start> #define RED     0xF800 <end>
<start> #define GREEN   0x07E0 <end>
<start> #define CYAN    0x07FF <end>
<start> #define MAGENTA 0xF81F <end>
<start> #define YELLOW  0xFFE0   <end>
<start> #define WHITE   0xFFFF <end>
<start>  <end>
<start> #define __CS 10 <end>
<start> #define __DC 9 <end>
<start> static const uint8_t icon [] PROGMEM = { <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x3f , 0xc0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x3 , 0xff , 0xf8 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x7 , 0xff , 0xfe , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x1f , 0xc0 , 0x7f , 0x80 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x3e , 0x0 , 0x7 , 0xc0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x7c , 0x0 , 0x3 , 0xe0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0xfd , 0xff , 0x81 , 0xf0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0xff , 0xff , 0xe0 , 0xf0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x1 , 0xff , 0xff , 0xf8 , 0x78 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x1 , 0xff , 0x80 , 0x7c , 0x38 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xfc , 0x0 , 0xe , 0x3c , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xf0 , 0x0 , 0x7 , 0x1c , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0xc0 , 0x7f , 0x83 , 0x8e , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x83 , 0xff , 0xe0 , 0xe , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0xf , 0xff , 0xf8 , 0xf , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x6 , 0x1f , 0x80 , 0xfc , 0x7 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x4 , 0x7e , 0x0 , 0x3f , 0x7 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0xf8 , 0x0 , 0xf , 0x7 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0xf0 , 0x3e , 0x7 , 0x87 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x1 , 0xe1 , 0xff , 0x83 , 0x83 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xc3 , 0xff , 0xc3 , 0xc3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xc7 , 0xc3 , 0xe1 , 0xc3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0x8f , 0x0 , 0xf1 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x1e , 0x0 , 0x78 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x1e , 0x3c , 0x38 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x1c , 0x7e , 0x38 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0xf , 0x1c , 0x7f , 0x38 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x3c , 0xf7 , 0x38 , 0x71 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x38 , 0xe7 , 0x38 , 0x71 , 0xc0 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x38 , 0xe7 , 0x38 , 0x71 , 0xc0 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x38 , 0xe7 , 0x38 , 0x73 , 0xc0 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x38 , 0xe3 , 0x98 , 0xe3 , 0xc0 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x38 , 0xe3 , 0xb8 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x38 , 0xe3 , 0xf8 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x38 , 0xe3 , 0xf8 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x3c , 0xf1 , 0xf1 , 0xe3 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0x6 , 0x1c , 0x70 , 0x1 , 0xc7 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0xe , 0x1c , 0x78 , 0x3 , 0xc7 , 0x80 , 0x0 ,  <end>
<start> 0x0 , 0xf , 0x1c , 0x3e , 0x7 , 0x87 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0xf , 0x1e , 0x3f , 0xff , 0x8f , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0xf , 0x1e , 0x1f , 0xff , 0x1f , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0xf , 0xf , 0x7 , 0xfc , 0x3e , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x87 , 0x80 , 0x0 , 0x7c , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x7 , 0x87 , 0xe0 , 0x0 , 0xfc , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xc3 , 0xf8 , 0x7 , 0xf8 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x3 , 0xe1 , 0xff , 0xff , 0xe1 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x1 , 0xe0 , 0x7f , 0xff , 0x83 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x1 , 0xf8 , 0xf , 0xfe , 0x7 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0xfc , 0x0 , 0x0 , 0xe , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x3f , 0x0 , 0x0 , 0x3c , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x1f , 0xe0 , 0x1 , 0xf8 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x7 , 0xff , 0xff , 0xf0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x1 , 0xff , 0xff , 0xc0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x1f , 0xfc , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ,  <end>
<start> 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 <end>
<start> } ;  <end>
<start>  <end>
<start>  <end>
<start> TFT_ILI9163C display = TFT_ILI9163C ( __CS , 8 ,  __DC )  ;  <end>
<start> SoftwareSerial mySerial ( 2 ,  3 )  ;  <end>
<start> Adafruit_Fingerprint finger = Adafruit_Fingerprint ( &mySerial )  ;  <end>
<start> int fingerprintID = 0 ;  <end>
<start>  <end>
<start> void setup ( void )  { <end>
<start>  <end>
<start>   startFingerprintSensor (  )  ;  <end>
<start>   display.begin (  )  ;  <end>
<start>   displayLockScreen (  )  ;   <end>
<start> } <end>
<start>  <end>
<start> void loop (  )  { <end>
<start>  <end>
<start>   fingerprintID = getFingerprintID (  )  ;  <end>
<start>   delay ( 50 )  ;  <end>
<start>   if ( fingerprintID == 1 )  <end>
<start>   { <end>
<start>     display.drawBitmap ( 30 , 35 , icon , 60 , 60 , GREEN )  ;  <end>
<start>     delay ( 2000 )  ;  <end>
<start>     displayUnlockedScreen (  )  ;  <end>
<start>     displayIoanna (  )  ;  <end>
<start>     delay ( 5000 )  ;  <end>
<start>     display.fillScreen ( BLACK )  ;  <end>
<start>     displayLockScreen (  )  ;  <end>
<start>   } <end>
<start>  <end>
<start>    if ( fingerprintID == 2 )  <end>
<start>   { <end>
<start>     display.drawBitmap ( 30 , 35 , icon , 60 , 60 , GREEN )  ;  <end>
<start>     delay ( 2000 )  ;  <end>
<start>     displayUnlockedScreen (  )  ;  <end>
<start>     displayNick (  )  ;  <end>
<start>     delay ( 5000 )  ;  <end>
<start>     display.fillScreen ( BLACK )  ;  <end>
<start>     displayLockScreen (  )  ;  <end>
<start>   } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void displayUnlockedScreen (  )  <end>
<start> { <end>
<start>    display.fillScreen ( BLACK )  ;  <end>
<start>    display.drawRect ( 0 , 0 , 128 , 128 , WHITE )  ;  <end>
<start>    display.setCursor ( 18 , 10 )  ;  <end>
<start>    display.setTextColor ( GREEN )  ;   <end>
<start>    display.setTextSize ( 2 )  ;  <end>
<start>    display.print ( "UNLOCKED" )  ;  <end>
<start>  <end>
<start>    display.setCursor ( 20 , 50 )  ;  <end>
<start>    display.setTextColor ( WHITE )  ;   <end>
<start>    display.setTextSize ( 2 )  ;  <end>
<start>    display.print ( "WELCOME" )  ;  <end>
<start> } <end>
<start> void displayNick (  )  <end>
<start> { <end>
<start>   display.setCursor ( 35 , 75 )  ;  <end>
<start>   display.setTextColor ( WHITE )  ;   <end>
<start>   display.setTextSize ( 2 )  ;  <end>
<start>   display.print ( "NICK!" )  ;  <end>
<start> } <end>
<start>  <end>
<start> void displayIoanna (  )  <end>
<start> { <end>
<start>   display.setCursor ( 25 , 75 )  ;  <end>
<start>   display.setTextColor ( WHITE )  ;   <end>
<start>   display.setTextSize ( 2 )  ;  <end>
<start>   display.print ( "IOANNA!" )  ;  <end>
<start> } <end>
<start>  <end>
<start> void displayLockScreen (  )  <end>
<start> { <end>
<start>   display.drawRect ( 0 , 0 , 128 , 128 , WHITE )  ;  <end>
<start>   display.setCursor ( 30 , 10 )  ;  <end>
<start>   display.setTextColor ( RED )  ;   <end>
<start>   display.setTextSize ( 2 )  ;  <end>
<start>   display.print ( "LOCKED" )  ;  <end>
<start>  <end>
<start>   display.setCursor ( 10 , 100 )  ;  <end>
<start>   display.setTextColor ( WHITE )  ;   <end>
<start>   display.setTextSize ( 1 )  ;  <end>
<start>   display.print ( "Waiting for valid \n    fingerprint." )  ;  <end>
<start>  <end>
<start>   display.drawBitmap ( 30 , 35 , icon , 60 , 60 , WHITE )  ;  <end>
<start> } <end>
<start> void startFingerprintSensor (  )  <end>
<start> { <end>
<start>   Serial.begin ( 9600 )  ;  <end>
<start>   finger.begin ( 57600 )  ;  <end>
<start>    <end>
<start>   if  ( finger.verifyPassword (  )  )  { <end>
<start>     Serial.println ( "Found fingerprint sensor!" )  ;  <end>
<start>   } else { <end>
<start>     Serial.println ( "Did not find fingerprint sensor" )  ;  <end>
<start>   } <end>
<start>   Serial.println ( "Waiting for valid finger..." )  ;  <end>
<start> } <end>
<start>  <end>
<start> int getFingerprintID (  )  { <end>
<start>   uint8_t p = finger.getImage (  )  ;  <end>
<start>   if  ( p != FINGERPRINT_OK )   return -1 ;  <end>
<start>  <end>
<start>   p = finger.image2Tz (  )  ;  <end>
<start>   if  ( p != FINGERPRINT_OK )   return -1 ;  <end>
<start>  <end>
<start>   p = finger.fingerFastSearch (  )  ;  <end>
<start>   if  ( p != FINGERPRINT_OK )   return -1 ;  <end>
<start>    <end>
<start>    <end>
<start>   Serial.print ( "Found ID #" )  ;  Serial.print ( finger.fingerID )  ;   <end>
<start>   Serial.print ( " with confidence of " )  ;  Serial.println ( finger.confidence )  ;  <end>
<start>   return finger.fingerID ;   <end>
<start> } <end>
<start>  <end>
<start> #include "MDB.h" <end>
<start> #include "USART.h" <end>
<start> #include <Arduino.h>  <end>
<start>  <end>
<start> VMC_Config_t vmc_config = {0 ,  0 ,  0 ,  0} ;  <end>
<start> VMC_Prices_t vmc_prices = {0 ,  0} ;  <end>
<start>  <end>
<start>   <end>
<start> uint16_t user_funds  = 0x0000 ;  <end>
<start> uint16_t item_cost   = 0x0000 ;  <end>
<start> uint16_t vend_amount = 0x0000 ;  <end>
<start> uint8_t csh_error_code = 0 ;  <end>
<start> uint16_t csh_poll_state = CSH_JUST_RESET ;  <end>
<start> uint8_t csh_state = CSH_S_INACTIVE ;  <end>
<start> CSH_Config_t csh_config = { <end>
<start>     0x01 ,   <end>
<start>     /* <end>
<start>      * Russia's country code is 810 or 643 ,  <end>
<start>      * which translates into 0x18 ,  0x10 <end>
<start>      *                    or 0x16 ,  0x43 <end>
<start>      */   <end>
<start>      <end>
<start>      <end>
<start>     0x00 ,  <end>
<start>     0x00 ,  <end>
<start>     /* <end>
<start>      * The VMC I work with accepts only 2 decimal places ,  <end>
<start>      * which is reasonable ,  considering 1 RUB = 100 Kopecks. <end>
<start>      * But actually there are no kopecks <end>
<start>      * in any item prices ,  rubles only. <end>
<start>      * As a coin acceptor handles coins with minimum value of 1 RUB ,  <end>
<start>      * I chose scaling factor 0d100  ( 0x64 )  ,  <end>
<start>      * which makes calculations easier to understand. <end>
<start>      * Example: Funds available   -- 1600.00 RUB <end>
<start>      *          Scale factor      -- 100 <end>
<start>      *          Decimal places    -- 2 <end>
<start>      * This makes internal funds value 1600 ,  or 0x0640 in HEX <end>
<start>      * which divides into 0x06 and 0x40 <end>
<start>      * for two uint8_t internal variables <end>
<start>      */ <end>
<start>     0x64 ,   <end>
<start>     0x02 ,   <end>
<start>     FUNDS_TIMEOUT ,   <end>
<start>     0b00001001   <end>
<start> } ;  <end>
<start>  <end>
<start>  <end>
<start> void MDB_Init ( void )  <end>
<start> { <end>
<start>     USART_Init ( 9600 )  ;  <end>
<start> } <end>
<start> void MDB_CommandHandler ( void )  <end>
<start> { <end>
<start>     uint16_t command = 0 ;  <end>
<start>      <end>
<start>      <end>
<start>     do { <end>
<start>         MDB_Read ( &command )  ;  <end>
<start>     } while  (  ( command < VMC_RESET )  ||  ( command > VMC_EXPANSION )  )  ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>     switch  ( command )  <end>
<start>     {         <end>
<start>         case VMC_RESET     :  MDB_ResetHandler (  )  ;      break ;  <end>
<start>         case VMC_SETUP     :  MDB_SetupHandler (  )  ;      break ;  <end>
<start>         case VMC_POLL      :  MDB_PollHandler (  )  ;       break ;  <end>
<start>         case VMC_VEND      :  MDB_VendHandler (  )  ;       break ;  <end>
<start>         case VMC_READER    :  MDB_ReaderHandler (  )  ;     break ;  <end>
<start>         case VMC_EXPANSION :  MDB_ExpansionHandler (  )  ;  break ;  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start>     switch  ( csh_state )  <end>
<start>     { <end>
<start>         case CSH_S_INACTIVE :  break ;  <end>
<start>         case CSH_S_DISABLED :  break ;  <end>
<start>         case CSH_S_ENABLED  : PORTC = 0 ;  PORTC |=  ( 1 << 2 )  ;  break ;  <end>
<start>         case CSH_S_SESSION_IDLE : PORTC = 0 ;  PORTC |=  ( 1 << 3 )  ;  break ;  <end>
<start>         case CSH_S_VEND     : PORTC = 0 ;  PORTC |=  ( 1 << 4 )  ;  break ;  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>                  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start> void MDB_ResetHandler ( void )  <end>
<start> { <end>
<start>     Reset (  )  ;  <end>
<start> } <end>
<start> void MDB_SetupHandler ( void )  <end>
<start> { <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = VMC_SETUP ;  <end>
<start>     uint16_t vmc_temp ;  <end>
<start>     uint8_t vmc_data[6] ;  <end>
<start>     /* <end>
<start>      * wait for the whole frame <end>
<start>      * frame structure: <end>
<start>      * 1 subcommand + 4 vmc_config fields + 1 Checksum byte <end>
<start>      * 6 elements total <end>
<start>      */ <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 5 )  <end>
<start>             break ;  <end>
<start>      <end>
<start>     for  ( i = 0 ;  i < 6 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &vmc_temp )  ;  <end>
<start>         vmc_data[i] =  ( uint8_t )  ( vmc_temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>      <end>
<start>      <end>
<start>     checksum += calc_checksum ( vmc_data ,  5 )  ;  <end>
<start>      <end>
<start>     if  ( checksum != vmc_data[5] )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>      <end>
<start>     switch ( vmc_data[0] )  <end>
<start>     { <end>
<start>         case VMC_CONFIG_DATA : {             <end>
<start>              <end>
<start>             vmc_config.featureLevel   = vmc_data[1] ;  <end>
<start>             vmc_config.displayColumns = vmc_data[2] ;  <end>
<start>             vmc_config.displayRows    = vmc_data[3] ;  <end>
<start>             vmc_config.displayInfo    = vmc_data[4] ;  <end>
<start>             ConfigInfo (  )  ;  <end>
<start>         } ;  break ;  <end>
<start>  <end>
<start>         case VMC_MAX_MIN_PRICES : { <end>
<start>              <end>
<start>             vmc_prices.maxPrice =  (  ( uint16_t ) vmc_data[1] << 8 )  | vmc_data[2] ;  <end>
<start>             vmc_prices.minPrice =  (  ( uint16_t ) vmc_data[3] << 8 )  | vmc_data[4] ;  <end>
<start>              <end>
<start>             MDB_Send ( CSH_ACK )  ;  <end>
<start>              <end>
<start>             csh_state = CSH_S_DISABLED ;  <end>
<start>         } ;  break ;  <end>
<start>  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start> } <end>
<start> void MDB_PollHandler ( void )  <end>
<start> { <end>
<start>     switch ( csh_poll_state )  <end>
<start>     { <end>
<start>         case CSH_ACK                    : MDB_Send ( CSH_ACK )  ;       break ;   <end>
<start>         case CSH_SILENCE                :                         break ;  <end>
<start>         case CSH_JUST_RESET             : JustReset (  )  ;             break ;  <end>
<start>         case CSH_READER_CONFIG_INFO     : ConfigInfo (  )  ;            break ;  <end>
<start>         case CSH_DISPLAY_REQUEST        : DisplayRequest (  )  ;        break ;   <end>
<start>         case CSH_BEGIN_SESSION          : BeginSession (  )  ;          break ;   <end>
<start>         case CSH_SESSION_CANCEL_REQUEST : SessionCancelRequest (  )  ;  break ;  <end>
<start>         case CSH_VEND_APPROVED          : VendApproved (  )  ;          break ;  <end>
<start>         case CSH_VEND_DENIED            : VendDenied (  )  ;            break ;  <end>
<start>         case CSH_END_SESSION            : EndSession (  )  ;            break ;  <end>
<start>         case CSH_CANCELLED              : Cancelled (  )  ;             break ;  <end>
<start>         case CSH_PERIPHERAL_ID          : PeripheralID (  )  ;          break ;  <end>
<start>         case CSH_MALFUNCTION_ERROR      : MalfunctionError (  )  ;      break ;  <end>
<start>         case CSH_CMD_OUT_OF_SEQUENCE    : CmdOutOfSequence (  )  ;      break ;  <end>
<start>         case CSH_DIAGNOSTIC_RESPONSE    : DiagnosticResponse (  )  ;    break ;  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start> } <end>
<start> void MDB_VendHandler ( void )  <end>
<start> { <end>
<start>     uint16_t subcomm_temp ;  <end>
<start>     uint8_t subcomm ;  <end>
<start>  <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 0 )  <end>
<start>             break ;  <end>
<start>      <end>
<start>     MDB_Read ( &subcomm_temp )  ;  <end>
<start>     subcomm =  ( uint8_t )  ( subcomm_temp & 0x00FF )  ;   <end>
<start>      <end>
<start>     switch ( subcomm )  <end>
<start>     { <end>
<start>         case VMC_VEND_REQUEST : VendRequest (  )  ;          break ;  <end>
<start>         case VMC_VEND_CANCEL  : VendDenied (  )  ;           break ;  <end>
<start>         case VMC_VEND_SUCCESS : VendSuccessHandler (  )  ;   break ;  <end>
<start>         case VMC_VEND_FAILURE : VendFailureHandler (  )  ;   break ;  <end>
<start>         case VMC_VEND_SESSION_COMPLETE : VendSessionComplete (  )  ;  break ;  <end>
<start>         case VMC_VEND_CASH_SALE : VendCashSale (  )  ;       break ;  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start> } <end>
<start> void MDB_ReaderHandler ( void )  <end>
<start> { <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = VMC_READER ;  <end>
<start>     uint16_t reader_temp ;  <end>
<start>     uint8_t reader_data[2] ;  <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 1 )  <end>
<start>             break ;  <end>
<start>      <end>
<start>     for  ( i = 0 ;  i < 2 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &reader_temp )  ;  <end>
<start>         reader_data[i] =  ( uint8_t )  ( reader_temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>      <end>
<start>     checksum += calc_checksum ( reader_data ,  1 )  ;  <end>
<start>      <end>
<start>     if  ( checksum != reader_data[1] )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>      <end>
<start>     switch ( reader_data[0] )  <end>
<start>     { <end>
<start>         case VMC_READER_DISABLE : Disable (  )  ;    break ;  <end>
<start>         case VMC_READER_ENABLE  : Enable (  )  ;     break ;  <end>
<start>         case VMC_READER_CANCEL  : Cancelled (  )  ;  break ;  <end>
<start>         default : break ;  <end>
<start>     } <end>
<start> } <end>
<start> void MDB_ExpansionHandler ( void )  <end>
<start> { <end>
<start>     uint16_t readCmd ;  <end>
<start>  <end>
<start>     MDB_Read ( &readCmd )  ;  <end>
<start>     switch ( readCmd )  <end>
<start>     { <end>
<start>         case VMC_EXPANSION_REQUEST_ID  : ExpansionRequestID (  )  ;  break ;  <end>
<start>         case VMC_EXPANSION_DIAGNOSTICS : ExpansionDiagnostics (  )  ;  break ;  <end>
<start>          <end>
<start>         default : break ;  <end>
<start>     } <end>
<start>      <end>
<start> } <end>
<start> void MDB_Send ( uint16_t data )  <end>
<start> { <end>
<start>     USART_TXBuf_Write ( data )  ;  <end>
<start> } <end>
<start> void MDB_Read ( uint16_t *data )  <end>
<start> { <end>
<start>     USART_RXBuf_Read ( data )  ;  <end>
<start> } <end>
<start> void MDB_Peek ( uint16_t *data )  <end>
<start> { <end>
<start>     USART_RXBuf_Peek ( data )  ;  <end>
<start> } <end>
<start>  <end>
<start> uint8_t MDB_DataCount  ( void )  <end>
<start> { <end>
<start>     return USART_RXBuf_Count (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> void Reset ( void )  <end>
<start> { <end>
<start>      <end>
<start>     vmc_config.featureLevel   = 0 ;  <end>
<start>     vmc_config.displayColumns = 0 ;  <end>
<start>     vmc_config.displayRows    = 0 ;  <end>
<start>     vmc_config.displayInfo    = 0 ;  <end>
<start>  <end>
<start>     vmc_prices.maxPrice = 0 ;  <end>
<start>     vmc_prices.minPrice = 0 ;  <end>
<start>  <end>
<start>     csh_error_code = 0 ;  <end>
<start>      <end>
<start>     csh_state = CSH_S_INACTIVE ;  <end>
<start>     csh_poll_state = CSH_JUST_RESET ;  <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void JustReset ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_JUST_RESET )  ;  <end>
<start>     Reset (  )  ;  <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void ConfigInfo ( void )  <end>
<start> { <end>
<start>     uint8_t checksum = 0 ;  <end>
<start>      <end>
<start>     checksum =  (  CSH_READER_CONFIG_INFO <end>
<start>                + csh_config.featureLevel <end>
<start>                + csh_config.countryCodeH <end>
<start>                + csh_config.countryCodeL <end>
<start>                + csh_config.scaleFactor <end>
<start>                + csh_config.decimalPlaces <end>
<start>                + csh_config.maxResponseTime <end>
<start>                + csh_config.miscOptions  )  ;  <end>
<start>     MDB_Send ( CSH_READER_CONFIG_INFO )  ;  <end>
<start>     MDB_Send ( csh_config.featureLevel )  ;  <end>
<start>     MDB_Send ( csh_config.countryCodeH )  ;  <end>
<start>     MDB_Send ( csh_config.countryCodeL )  ;  <end>
<start>     MDB_Send ( csh_config.scaleFactor )  ;  <end>
<start>     MDB_Send ( csh_config.decimalPlaces )  ;  <end>
<start>     MDB_Send ( csh_config.maxResponseTime )  ;  <end>
<start>     MDB_Send ( csh_config.miscOptions )  ;  <end>
<start>     MDB_Send ( checksum | CSH_ACK )  ;  <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void DisplayRequest ( void )  <end>
<start> { <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>     //  /* Here you need to copy the message into allocated memory <end>
<start>       <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start>  <end>
<start> void BeginSession ( void )   <end>
<start> { <end>
<start>     /* <end>
<start>      * I need this variable because my VMC doesn't want to send a <end>
<start>      * VMC_VEND command  ( 0x113 )  after I answer it with a single BEGIN SESSION Poll Reply <end>
<start>      * So I decided to try it several times ,  that is what this counter for <end>
<start>      */ <end>
<start>     static uint8_t begin_session_counter = 0 ;  <end>
<start>      <end>
<start>     uint8_t checksum = 0 ;  <end>
<start>     uint16_t funds = CSH_GetUserFunds (  )  ;  <end>
<start>     uint8_t user_funds_H =  ( uint8_t )  ( funds >> 8 )  ;  <end>
<start>     uint8_t user_funds_L =  ( uint8_t )  ( funds &  0x00FF )  ;  <end>
<start>  <end>
<start>      <end>
<start>     begin_session_counter++ ;  <end>
<start>     if  ( begin_session_counter >= 50 )  <end>
<start>     { <end>
<start>         csh_poll_state = CSH_ACK ;  <end>
<start>         csh_state = CSH_S_SESSION_IDLE ;  <end>
<start>         begin_session_counter = 0 ;  <end>
<start>         return ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     checksum =  (  CSH_BEGIN_SESSION <end>
<start>                + user_funds_H <end>
<start>                + user_funds_L  )  ;  <end>
<start>      <end>
<start>     MDB_Send ( CSH_BEGIN_SESSION )  ;  <end>
<start>     MDB_Send ( user_funds_H )  ;        <end>
<start>     MDB_Send ( user_funds_L )  ;        <end>
<start>     MDB_Send ( checksum | CSH_ACK )  ;     <end>
<start>      <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start>          <end>
<start>          <end>
<start>          <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start>  <end>
<start> void SessionCancelRequest ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_SESSION_CANCEL_REQUEST )  ;  <end>
<start>     MDB_Send ( CSH_SESSION_CANCEL_REQUEST | CSH_ACK )  ;   <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void VendApproved ( void )  <end>
<start> { <end>
<start>     static uint8_t vend_approved_counter = 0 ;  <end>
<start>     uint8_t checksum = 0 ;  <end>
<start>     uint8_t vend_amount_H =  ( uint8_t )  ( vend_amount >> 8 )  ;  <end>
<start>     uint8_t vend_amount_L =  ( uint8_t )  ( vend_amount &  0x00FF )  ;  <end>
<start>      <end>
<start>     vend_approved_counter++ ;  <end>
<start>     if  ( vend_approved_counter >= 50 )  <end>
<start>     { <end>
<start>         csh_poll_state = CSH_END_SESSION ;  <end>
<start>         vend_approved_counter = 0 ;  <end>
<start>         return ;  <end>
<start>     } <end>
<start>      <end>
<start>     checksum =  (  CSH_VEND_APPROVED <end>
<start>                + vend_amount_H <end>
<start>                + vend_amount_L  )  ;  <end>
<start>     MDB_Send ( CSH_VEND_APPROVED )  ;  <end>
<start>     MDB_Send ( vend_amount_H )  ;         <end>
<start>     MDB_Send ( vend_amount_L )  ;         <end>
<start>     MDB_Send ( checksum | CSH_ACK )  ;    <end>
<start>       <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void VendDenied ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_VEND_DENIED )  ;  <end>
<start>     MDB_Send ( CSH_VEND_DENIED | CSH_ACK )  ;   <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start>     csh_poll_state = CSH_END_SESSION ;  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start>  <end>
<start> void EndSession ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_END_SESSION )  ;  <end>
<start>     MDB_Send ( CSH_END_SESSION | CSH_ACK )  ;   <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>     CSH_SetUserFunds ( 0 )  ;  <end>
<start>     CSH_SetItemCost ( 0 )  ;  <end>
<start>     CSH_SetVendAmount ( 0 )  ;     <end>
<start>     CSH_SetPollState ( CSH_JUST_RESET )  ;  <end>
<start>     CSH_SetDeviceState ( CSH_S_ENABLED )  ;   <end>
<start> } <end>
<start>  <end>
<start> void Cancelled ( void )  <end>
<start> { <end>
<start>     if  ( csh_state != CSH_S_ENABLED )  <end>
<start>         return ;  <end>
<start>     MDB_Send ( CSH_CANCELLED )  ;  <end>
<start>     MDB_Send ( CSH_CANCELLED | CSH_ACK )  ;   <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void PeripheralID ( void )  <end>
<start> { <end>
<start>      <end>
<start>      <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = 0 ;  <end>
<start>     uint8_t periph_id[31] ;  <end>
<start>     uint8_t a_char = 0x41 ;  <end>
<start>     periph_id[0] = CSH_PERIPHERAL_ID ;  <end>
<start>     periph_id[1] = 'U' ;  periph_id[2] = 'N' ;  periph_id[3] = 'I' ;   <end>
<start>      <end>
<start>      <end>
<start>     for  ( i = 4 ;  i < 15 ;  ++i )  <end>
<start>         periph_id[i] = 0 ;  <end>
<start>  <end>
<start>     periph_id[15] = 1 ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>     for  ( i = 16 ;  i < 28 ;  ++i )  <end>
<start>         periph_id[i] = a_char + i ;  <end>
<start>      <end>
<start>     periph_id[28] = 1 ;  <end>
<start>     periph_id[29] = 0 ;  <end>
<start>     periph_id[30] = calc_checksum ( periph_id ,  29 )  ;  <end>
<start>      <end>
<start>     for  ( i = 0 ;  i < 30 ;  ++i )  <end>
<start>         MDB_Send ( periph_id[i] )  ;  <end>
<start>  <end>
<start>     MDB_Send ( periph_id[30] | CSH_ACK )  ;  <end>
<start>  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void MalfunctionError ( void )  <end>
<start> { <end>
<start>     uint8_t i ;  <end>
<start>     uint8_t malf_err[2] ;  <end>
<start>     malf_err[0] = CSH_MALFUNCTION_ERROR ;  <end>
<start>     malf_err[1] = csh_error_code ;  <end>
<start>      <end>
<start>     malf_err[2] = calc_checksum ( malf_err ,  2 )  | CSH_ACK ;  <end>
<start>     for  ( i = 0 ;  i < 3 ;  ++i )  <end>
<start>         MDB_Send ( malf_err[i] )  ;  <end>
<start> } <end>
<start>  <end>
<start> void CmdOutOfSequence ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_CMD_OUT_OF_SEQUENCE )  ;  <end>
<start>     MDB_Send ( CSH_CMD_OUT_OF_SEQUENCE | CSH_ACK )  ;  <end>
<start> } <end>
<start>  <end>
<start> void DiagnosticResponse ( void )  <end>
<start> { <end>
<start>  <end>
<start> } <end>
<start>  <end>
<start> void VendRequest ( void )  <end>
<start> { <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_REQUEST ;  <end>
<start>     uint8_t vend_data[5] ;  <end>
<start>     uint16_t vend_temp ;  <end>
<start>      <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 4 )  <end>
<start>             break ;  <end>
<start>      <end>
<start>     for  ( i = 0 ;  i < 5 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &vend_temp )  ;  <end>
<start>         vend_data[i] =  ( uint8_t )  ( vend_temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>      <end>
<start>     checksum += calc_checksum ( vend_data ,  4 )  ;  <end>
<start>      <end>
<start>     if  ( checksum != vend_data[4] )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>     CSH_SetItemCost (  ( vend_data[0] << 8 )  | vend_data[1] )  ;  <end>
<start>     CSH_SetVendAmount (  ( vend_data[2] << 8 )  | vend_data[3] )  ;  <end>
<start>      <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start>      <end>
<start>     csh_state = CSH_S_VEND ;  <end>
<start>     /* <end>
<start>      * =================================== <end>
<start>      * HERE GOES THE CODE FOR RFID/HTTP Handlers <end>
<start>      * if enough payment media ,  tell server to subtract sum <end>
<start>      * wait for server reply ,  then CSH_VEND_APPROVED <end>
<start>      * Otherwise ,  CSH_VEND_DENIED <end>
<start>      * =================================== <end>
<start>     */ <end>
<start> } <end>
<start>  <end>
<start> void VendSuccessHandler ( void )  <end>
<start> { <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_SUCCESS ;  <end>
<start>     uint8_t vend_data[3] ;  <end>
<start>     uint16_t vend_temp ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 2 )  <end>
<start>             break ;  <end>
<start>  <end>
<start>     for  ( i = 0 ;  i < 3 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &vend_temp )  ;  <end>
<start>         vend_data[i] =  ( uint8_t )  ( vend_temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>      <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start>  <end>
<start>      <end>
<start>     csh_state = CSH_S_SESSION_IDLE ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start>  <end>
<start> void VendFailureHandler ( void )  <end>
<start> { <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_FAILURE ;  <end>
<start>     uint8_t incoming_checksum ;  <end>
<start>     uint16_t temp ;  <end>
<start>      <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 0 )  <end>
<start>             break ;  <end>
<start>     MDB_Read ( &temp )  ;  <end>
<start>     incoming_checksum =  ( uint8_t )  ( temp & 0x00FF )  ;   <end>
<start>     if  ( checksum != incoming_checksum )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>      <end>
<start>  <end>
<start>     MDB_Send ( CSH_ACK )  ;   <end>
<start>      <end>
<start>      <end>
<start>     csh_state = CSH_S_SESSION_IDLE ;  <end>
<start> } <end>
<start>  <end>
<start> void VendSessionComplete ( void )  <end>
<start> { <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start>     CSH_SetPollState ( CSH_END_SESSION )  ;  <end>
<start> } <end>
<start>  <end>
<start> void VendCashSale ( void )  <end>
<start> { <end>
<start>     uint8_t i ;   <end>
<start>     uint8_t checksum = VMC_VEND + VMC_VEND_CASH_SALE ;  <end>
<start>     uint8_t vend_data[5] ;  <end>
<start>     uint16_t vend_temp ;  <end>
<start>      <end>
<start>      <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 4 )  <end>
<start>             break ;  <end>
<start>     for  ( i = 0 ;  i < 5 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &vend_temp )  ;  <end>
<start>         vend_data[i] =  ( uint8_t )  ( vend_temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>     checksum += calc_checksum ( vend_data ,  4 )  ;  <end>
<start>     if  ( checksum != vend_data[4] )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start> } <end>
<start> void Disable ( void )  <end>
<start> { <end>
<start>     csh_state = CSH_S_DISABLED ;  <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start> } <end>
<start>  <end>
<start> void Enable ( void )  <end>
<start> { <end>
<start>     if  ( csh_state != CSH_S_DISABLED )  <end>
<start>         return ;  <end>
<start>     csh_state = CSH_S_ENABLED ;  <end>
<start>     csh_poll_state = CSH_ACK ;  <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start> } <end>
<start> void ExpansionRequestID ( void )  <end>
<start> { <end>
<start>     uint16_t i ;   <end>
<start>     uint8_t checksum = VMC_EXPANSION + VMC_EXPANSION_REQUEST_ID ;  <end>
<start>     uint16_t temp ;  <end>
<start>     uint8_t data[30] ;  <end>
<start>     /* <end>
<start>      * Wait for incoming 29 data elements + 1 checksum  ( 30 total )  <end>
<start>      * Store the data by the following indexes: <end>
<start>      *  0 ,   1 ,   2 -- Manufacturer Code  ( 3 elements )  <end>
<start>      *  3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,  10 ,  11 ,  12 ,  13 ,  14 -- Serial Number  ( 12 elements )  <end>
<start>      * 15 ,  16 ,  17 ,  18 ,  19 ,  20 ,  21 ,  22 ,  23 ,  24 ,  25 ,  26 -- Model  Number  ( 12 elements )  <end>
<start>      * 27 ,  28 -- Software Version  ( 2 elements )  <end>
<start>      * 29 -- Checksum  ( 1 element )  <end>
<start>      */ <end>
<start>     while  ( 1 )  <end>
<start>         if  ( MDB_DataCount (  )  > 29 )  <end>
<start>             break ;  <end>
<start>      <end>
<start>     for  ( i = 0 ;  i < 30 ;  ++i )  <end>
<start>     { <end>
<start>         MDB_Read ( &temp )  ;  <end>
<start>         data[i] =  ( uint8_t )  ( temp & 0x00FF )  ;   <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     checksum += calc_checksum ( data ,  29 )  ;  <end>
<start>      <end>
<start>     if  ( checksum != data[29] )  <end>
<start>     { <end>
<start>         MDB_Send ( CSH_NAK )  ;  <end>
<start>         return ;   <end>
<start>     } <end>
<start>      <end>
<start>     PeripheralID (  )  ;  <end>
<start>     while  (  !  ( USART_TXBuf_IsEmpty (  )  )   )  <end>
<start>          ;  <end>
<start> } <end>
<start>  <end>
<start> void ExpansionDiagnostics ( void )  <end>
<start> { <end>
<start>     uint8_t checksum = VMC_EXPANSION + VMC_EXPANSION_DIAGNOSTICS ;  <end>
<start>     MDB_Send ( CSH_ACK )  ;  <end>
<start>      <end>
<start>      <end>
<start> } <end>
<start> uint8_t CSH_GetPollState ( void )  <end>
<start> { <end>
<start>     return csh_poll_state ;  <end>
<start> } <end>
<start> uint8_t CSH_GetDeviceState ( void )  <end>
<start> { <end>
<start>     return csh_state ;  <end>
<start> } <end>
<start> uint16_t CSH_GetUserFunds ( void )  <end>
<start> { <end>
<start>     return user_funds ;  <end>
<start> } <end>
<start> uint16_t CSH_GetItemCost ( void )  <end>
<start> { <end>
<start>     return item_cost ;  <end>
<start> } <end>
<start> uint16_t CSH_GetVendAmount ( void )  <end>
<start> { <end>
<start>     return vend_amount ;  <end>
<start> } <end>
<start> void CSH_SetPollState ( uint8_t new_poll_state )  <end>
<start> { <end>
<start>     csh_poll_state = new_poll_state ;  <end>
<start> } <end>
<start> void CSH_SetDeviceState ( uint8_t new_device_state )  <end>
<start> { <end>
<start>     csh_state = new_device_state ;  <end>
<start> } <end>
<start> void CSH_SetUserFunds ( uint16_t new_funds )  <end>
<start> { <end>
<start>     user_funds = new_funds ;  <end>
<start> } <end>
<start> void CSH_SetItemCost ( uint16_t new_item_cost )  <end>
<start> { <end>
<start>     item_cost = new_item_cost ;  <end>
<start> } <end>
<start> void CSH_SetVendAmount ( uint16_t new_vend_amount )  <end>
<start> { <end>
<start>     vend_amount = new_vend_amount ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start>  /* <end>
<start>   * calc_checksum (  )  <end>
<start>   * Calculates checksum of *array from 0 to arr_size <end>
<start>   * Use with caution  ( because of pointer arithmetics )  <end>
<start>   */ <end>
<start> uint8_t calc_checksum ( uint8_t *array ,  uint8_t arr_size )  <end>
<start> { <end>
<start>     uint8_t ret_val = 0x00 ;  <end>
<start>     uint8_t i ;  <end>
<start>     for  ( i = 0 ;  i < arr_size ;  ++i )  <end>
<start>         ret_val += * ( array + i )  ;  <end>
<start>     return ret_val ;  <end>
<start> } <end>
<start>  <end>
<start> #include "main.h" <end>
<start>  <end>
<start> static unsigned char password[4]="0000" ;  <end>
<start> static int curr_temp = 255 ;   <end>
<start> static int last_temp = 255 ;   <end>
<start> uint8_t get_temp (  )  ;  <end>
<start> void Button_Led_initialize (  )  <end>
<start> {DDRD  |=  ( 1<<0 )  ;   <end>
<start> DDRD  |=  ( 1<<6 )  ;   <end>
<start> DDRD  |=  ( 1<<2 )  ;   <end>
<start> DDRA  |=  ( 1<<2 )  ;   <end>
<start> MCUCR |=  ( 1 << ISC01 )  ;  <end>
<start> GICR  |=  ( 1 << INT0 )  ;  <end>
<start> } <end>
<start>  <end>
<start> void enter_the_door (  )  <end>
<start> { <end>
<start> PORTD |=   ( 1<<2 )  ;  <end>
<start> PORTD &= ~ ( 1<<2 )  ;  <end>
<start> } <end>
<start>  <end>
<start> int main ( void )  <end>
<start> { <end>
<start> LCD_initialize (  )  ;  <end>
<start> PIR_initialize (  )  ;  <end>
<start> Temp_initialize (  )  ;  <end>
<start> buzzer_initialize (  )  ;  <end>
<start> Button_Led_initialize (  )  ;  <end>
<start> sei (  )  ;  <end>
<start> uint8_t requierd_temp=28 ;  <end>
<start>  <end>
<start> LCD_display_text ( "Welcome Home  ,  " , 700 )  ;  <end>
<start> _delay_ms ( 200 )  ;  <end>
<start> LCD_set_Cursor ( 1 , 0 )  ;  <end>
<start> LCD_display_text ( "Mr. abdelrhman" , 700 )  ;  <end>
<start>  <end>
<start> enter_the_door (  )  ;   <end>
<start> _delay_ms ( 500 )  ;  <end>
<start>  <end>
<start>  <end>
<start> while  ( 1 )  <end>
<start>   { <end>
<start> PIR_DETECT_MOTION (  )  ;   <end>
<start> last_temp = curr_temp ;  <end>
<start> curr_temp = Temp_GetInput (  )  ;  <end>
<start> Temp_warning ( curr_temp  ,  ( int ) requierd_temp )  ;  <end>
<start> if ( last_temp == 255 ||  ( curr_temp-last_temp )   )  <end>
<start> {  <end>
<start> Temp_display ( curr_temp )  ;  <end>
<start> } <end>
<start>  <end>
<start>   } <end>
<start>  } <end>
<start>  <end>
<start> ISR ( INT0_vect )  <end>
<start> { <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> unsigned int  counter = 0 ;  <end>
<start> unsigned char entered_password[4]={' '} ;  <end>
<start>  <end>
<start> while (  1  )  <end>
<start> { <end>
<start> LCD_clear (  )  ;  <end>
<start> LCD_display_text ( "enter password:" , 700 )  ;  <end>
<start> LCD_set_Cursor ( 1 , 0 )  ;  <end>
<start> for ( int i =0  ;  i<4  ;  i++ )  <end>
<start> { <end>
<start> entered_password[i]=Get_Key_pressed (  )  ;  <end>
<start> LCD_display_char ( entered_password[i] )  ;   <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> } <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> if (   ( memcmp ( entered_password ,  password ,  sizeof ( entered_password )  )  != 0 )   )  <end>
<start> { <end>
<start> counter++ ;  <end>
<start> PORTD|= ( 1<<0 )  ;   <end>
<start> LCD_clear (  )  ;  <end>
<start> LCD_display_text ( "Wrong password" , 700 )  ;  <end>
<start> LCD_set_Cursor ( 1 , 0 )  ;  <end>
<start> LCD_display_text ( "You have " , 700 )  ;  <end>
<start> LCD_display_char (  3-counter+'0'  )  ;  <end>
<start> LCD_display_text ( " left" , 700 )  ;  <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> PORTD&=~ ( 1<<0 )  ;   <end>
<start>  <end>
<start> if ( counter == 3 )  <end>
<start> { <end>
<start> LCD_clear (  )  ;  <end>
<start> LCD_set_Cursor ( 1 , 3 )  ;  <end>
<start> LCD_display_text ( "a Thief !! " , 700 )  ;  <end>
<start> LCD_set_Cursor ( 1 , 2 )  ;  <end>
<start> LCD_display_text ( "  go away !! " , 700 )  ;  <end>
<start> buzzer_turn_on ( 10000 )  ;   <end>
<start> counter = 0 ;   <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> else <end>
<start> { <end>
<start> LCD_clear (  )  ;  <end>
<start> PORTA  |=   ( 1<<2 )  ;  <end>
<start> opendoor (  )  ;  <end>
<start> _delay_ms ( 500 )  ;  <end>
<start> PORTA  &= ~ ( 1<<2 )  ;    <end>
<start> counter = 0 ;  <end>
<start> last_temp = 255 ;  <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> #include "FourQ_internal.h" <end>
<start> #include "FourQ_params.h" <end>
<start> #include "random/random.h"  <end>
<start> #include "blake2b/blake.h"  <end>
<start> #include <stdlib.h> <end>
<start> #include <string.h> <end>
<start>  <end>
<start>  <end>
<start> ECCRYPTO_STATUS SchnorrQ_KeyGeneration ( const unsigned char* SecretKey ,  unsigned char* PublicKey )  <end>
<start> {  <end>
<start>    <end>
<start>    <end>
<start>    <end>
<start>    <end>
<start>     point_t P ;  <end>
<start>     unsigned char k[64] ;  <end>
<start>     ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN ;  <end>
<start>    <end>
<start>     if  ( CryptoHashFunction ( SecretKey ,  32 ,  k )  != 0 )  {    <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>      <end>
<start>     ecc_mul_fixed (  ( digit_t* ) k ,  P )  ;            <end>
<start>     encode ( P ,  PublicKey )  ;                 <end>
<start>  <end>
<start>     return ECCRYPTO_SUCCESS ;  <end>
<start>  <end>
<start> cleanup: <end>
<start>     clear_words (  ( unsigned int* ) k ,  512/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>     clear_words (  ( unsigned int* ) PublicKey ,  256/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>  <end>
<start>     return Status ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> ECCRYPTO_STATUS SchnorrQ_FullKeyGeneration ( unsigned char* SecretKey ,  unsigned char* PublicKey )  <end>
<start> {  <end>
<start>    <end>
<start>    <end>
<start>    <end>
<start>     ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN ;  <end>
<start>  <end>
<start>     Status = RandomBytesFunction ( SecretKey ,  32 )  ;  <end>
<start>     if  ( Status != ECCRYPTO_SUCCESS )  { <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>    <end>
<start>     Status = SchnorrQ_KeyGeneration ( SecretKey ,  PublicKey )  ;     <end>
<start>     if  ( Status != ECCRYPTO_SUCCESS )  { <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>  <end>
<start>     return ECCRYPTO_SUCCESS ;  <end>
<start>  <end>
<start> cleanup: <end>
<start>     clear_words (  ( unsigned int* ) SecretKey ,  256/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>     clear_words (  ( unsigned int* ) PublicKey ,  256/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>  <end>
<start>     return Status ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> ECCRYPTO_STATUS SchnorrQ_Sign ( const unsigned char* SecretKey ,  const unsigned char* PublicKey ,  const unsigned char* Message ,  const unsigned int SizeMessage ,  unsigned char* Signature )  <end>
<start> {  <end>
<start>    <end>
<start>    <end>
<start>    <end>
<start>     point_t R ;  <end>
<start>     unsigned char k[64] ,  r[64] ,  h[64] ,  *temp = NULL ;  <end>
<start>     digit_t* H =  ( digit_t* ) h ;  <end>
<start>     digit_t* S =  ( digit_t* )  ( Signature+32 )  ;  <end>
<start>     ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN ;  <end>
<start>        <end>
<start>     if  ( CryptoHashFunction ( SecretKey ,  32 ,  k )  != 0 )  {    <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>      <end>
<start>     temp =  ( unsigned char* ) calloc ( 1 ,  SizeMessage+64 )  ;  <end>
<start>     if  ( temp == NULL )  { <end>
<start> Status = ECCRYPTO_ERROR_NO_MEMORY ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>      <end>
<start>     memmove ( temp+32 ,  k+32 ,  32 )  ;  <end>
<start>     memmove ( temp+64 ,  Message ,  SizeMessage )  ;  <end>
<start>    <end>
<start>     if  ( CryptoHashFunction ( temp+32 ,  SizeMessage+32 ,  r )  != 0 )  {    <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>      <end>
<start>     ecc_mul_fixed (  ( digit_t* ) r ,  R )  ;   <end>
<start>     encode ( R ,  Signature )  ;                     <end>
<start>     memmove ( temp ,  Signature ,  32 )  ;  <end>
<start>     memmove ( temp+32 ,  PublicKey ,  32 )  ;  <end>
<start>    <end>
<start>     if  ( CryptoHashFunction ( temp ,  SizeMessage+64 ,  h )  != 0 )  {    <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>  <end>
<start>     modulo_order (  ( digit_t* ) r ,   ( digit_t* ) r )  ;  <end>
<start>     modulo_order ( H ,  H )  ;  <end>
<start>     to_Montgomery (  ( digit_t* ) k ,  S )  ;            <end>
<start>     to_Montgomery ( H ,  H )  ;                      <end>
<start>     Montgomery_multiply_mod_order ( S ,  H ,  S )  ;  <end>
<start>     from_Montgomery ( S ,  S )  ;                    <end>
<start>     subtract_mod_order (  ( digit_t* ) r ,  S ,  S )  ;  <end>
<start>     Status = ECCRYPTO_SUCCESS ;  <end>
<start>      <end>
<start> cleanup: <end>
<start>     if  ( temp != NULL )  <end>
<start>         free ( temp )  ;  <end>
<start>     clear_words (  ( unsigned int* ) k ,  512/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>     clear_words (  ( unsigned int* ) r ,  512/ ( sizeof ( unsigned int ) *8 )  )  ;  <end>
<start>      <end>
<start>     return Status ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> ECCRYPTO_STATUS SchnorrQ_Verify ( const unsigned char* PublicKey ,  const unsigned char* Message ,  const unsigned int SizeMessage ,  const unsigned char* Signature ,  unsigned int* valid )  <end>
<start> {  <end>
<start>    <end>
<start>    <end>
<start>    <end>
<start>     point_t A ;  <end>
<start>     unsigned char *temp ,  h[64] ;  <end>
<start>     unsigned int i ;  <end>
<start>     ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN ;    <end>
<start>  <end>
<start>     *valid = false ;  <end>
<start>  <end>
<start>     temp =  ( unsigned char* ) calloc ( 1 ,  SizeMessage+64 )  ;  <end>
<start>     if  ( temp == NULL )  { <end>
<start>         Status = ECCRYPTO_ERROR_NO_MEMORY ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>  <end>
<start>     if  (  (  ( PublicKey[15] & 0x80 )  != 0 )  ||  (  ( Signature[15] & 0x80 )  != 0 )  ||  ( Signature[63] != 0 )  ||  (  ( Signature[62] & 0xC0 )  != 0 )  )  {   <end>
<start>         Status = ECCRYPTO_ERROR_INVALID_PARAMETER ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>      <end>
<start>     Status = decode ( PublicKey ,  A )  ;      <end>
<start>     if  ( Status != ECCRYPTO_SUCCESS )  { <end>
<start>         goto cleanup ;                              <end>
<start>     } <end>
<start>  <end>
<start>     memmove ( temp ,  Signature ,  32 )  ;  <end>
<start>     memmove ( temp+32 ,  PublicKey ,  32 )  ;  <end>
<start>     memmove ( temp+64 ,  Message ,  SizeMessage )  ;  <end>
<start>    <end>
<start>     if  ( CryptoHashFunction ( temp ,  SizeMessage+64 ,  h )  != 0 )  {    <end>
<start>         Status = ECCRYPTO_ERROR ;  <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>  <end>
<start>     Status = ecc_mul_double (  ( digit_t* )  ( Signature+32 )  ,  A ,   ( digit_t* ) h ,  A )  ;        <end>
<start>     if  ( Status != ECCRYPTO_SUCCESS )  {                                                 <end>
<start>         goto cleanup ;  <end>
<start>     } <end>
<start>  <end>
<start>     encode ( A ,   ( unsigned char* ) A )  ;  <end>
<start>  <end>
<start>     for  ( i = 0 ;  i < NWORDS_ORDER ;  i++ )  { <end>
<start>         if  (  (  ( digit_t* ) A ) [i] !=  (  ( digit_t* ) Signature ) [i] )  { <end>
<start>             goto cleanup ;     <end>
<start>         } <end>
<start>     } <end>
<start>     *valid = true ;  <end>
<start>  <end>
<start> cleanup: <end>
<start>     if  ( temp != NULL )  <end>
<start>         free ( temp )  ;  <end>
<start>      <end>
<start>     return Status ;  <end>
<start> } <end>
<start> #include <errno.h> <end>
<start> #include <glib.h> <end>
<start> #include <glib/gstdio.h> <end>
<start> #include <openssl/evp.h> <end>
<start>  <end>
<start> #include "crypt.h" <end>
<start> #include "utils.h" <end>
<start>  <end>
<start> #define ENC_SEC_SIZE4096 <end>
<start>  <end>
<start> GQuark r_crypt_error_quark ( void )  <end>
<start> { <end>
<start> return g_quark_from_static_string ( "r_crypt_error_quark" )  ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> static void iv_plain64 ( guint8 *iv ,  guint iv_size ,  guint64 sector )  <end>
<start> { <end>
<start> guint64 iv_val ;  <end>
<start> g_return_if_fail ( iv )  ;  <end>
<start>  <end>
<start> memset ( iv ,  0 ,  iv_size )  ;  <end>
<start> iv_val = GUINT64_TO_LE ( sector * ENC_SEC_SIZE / 512 )  ;  <end>
<start> memcpy ( iv ,  &iv_val ,  sizeof ( guint64 )  )  ;  <end>
<start> } <end>
<start>  <end>
<start> static gboolean encrypt_or_decrypt ( FILE *fd ,  FILE *out ,  const uint8_t *key ,  gboolean encrypt ,  goffset maxsize ,  GError **error )  <end>
<start> { <end>
<start> /* Allow enough space in output buffer for additional block */ <end>
<start> unsigned char inbuf[ENC_SEC_SIZE] ,  outbuf[ENC_SEC_SIZE] ;  <end>
<start> g_autoptr ( EVP_CIPHER_CTX )  ;  <end>
<start> ctx = NULL ;  <end>
<start> int ret ;  <end>
<start> const EVP_CIPHER *cipher = EVP_aes_256_cbc (  )  ;  <end>
<start> guint64 sector_count = 0 ;  <end>
<start> guint8 iv[16] ;  <end>
<start> goffset donesize = 0 ;  <end>
<start>  <end>
<start> g_return_val_if_fail ( fd != NULL ,  FALSE )  ;  <end>
<start> g_return_val_if_fail ( out != NULL ,  FALSE )  ;  <end>
<start>  <end>
<start> /* Don't set key or IV right away ;  we want to check lengths */ <end>
<start> ctx = EVP_CIPHER_CTX_new (  )  ;  <end>
<start> ret = EVP_CipherInit_ex ( ctx ,  cipher ,  NULL ,  NULL ,  NULL ,  encrypt ? 1 : 0 )  ;  <end>
<start> if  ( !ret )  <end>
<start> g_error ( "Error setting cipher" )  ;  <end>
<start>  <end>
<start> /* disable padding as we expect to have only matching blocks*/ <end>
<start> EVP_CIPHER_CTX_set_padding ( ctx ,  0 )  ;  <end>
<start>  <end>
<start> /* assert expected input key and iv size */ <end>
<start> g_assert ( EVP_CIPHER_CTX_key_length ( ctx )  == 32 )  ;  <end>
<start> g_assert ( EVP_CIPHER_CTX_iv_length ( ctx )  == 16 )  ;  <end>
<start>  <end>
<start> /* encrypt/decrypt in 4096 byte sectors */ <end>
<start> for  (  ;  ;  )  {  <end>
<start> int inlen ,  outlen ;  <end>
<start>  <end>
<start> /* plain64 iv mode */ <end>
<start> iv_plain64 ( iv ,  16 ,  sector_count++ )  ;  <end>
<start>  <end>
<start> /* set up with key and iv for encryption/decryption */ <end>
<start> ret = EVP_CipherInit_ex ( ctx ,  NULL ,  NULL ,  key ,  iv ,  encrypt ? 1 : 0 )  ;  <end>
<start> if  ( !ret )  <end>
<start> g_error ( "Error setting key and iv" )  ;  <end>
<start>  <end>
<start> inlen = fread ( inbuf ,  1 ,  ENC_SEC_SIZE ,  fd )  ;  <end>
<start> donesize += inlen ;  <end>
<start> /* image size must be multiple of 4096 */ <end>
<start> if  ( inlen <= 0 )  <end>
<start> break ;  <end>
<start> if  ( inlen < ENC_SEC_SIZE )  { <end>
<start> g_set_error ( error ,  R_CRYPT_ERROR ,  R_CRYPT_ERROR_FAILED ,  "Incomplete read: Input size must be multiple of %d  ( got only %d bytes ) " ,  ENC_SEC_SIZE ,  inlen )  ;  <end>
<start> return FALSE ;  <end>
<start> } <end>
<start>  <end>
<start> /* limit decrypt size to maxsize if set */ <end>
<start> if  ( maxsize && donesize > maxsize )  { <end>
<start> return TRUE ;  <end>
<start> } <end>
<start>  <end>
<start> if  ( !EVP_CipherUpdate ( ctx ,  outbuf ,  &outlen ,  inbuf ,  ENC_SEC_SIZE )  )  { <end>
<start> g_set_error ( error ,  R_CRYPT_ERROR ,  R_CRYPT_ERROR_FAILED ,  "EVP_CipherUpdate (  )  failed" )  ;  <end>
<start> return FALSE ;  <end>
<start> } <end>
<start>  <end>
<start> fwrite ( outbuf ,  1 ,  outlen ,  out )  ;  <end>
<start>  <end>
<start> if  ( !EVP_CipherFinal_ex ( ctx ,  outbuf ,  &outlen )  )  { <end>
<start> g_set_error ( error ,  R_CRYPT_ERROR ,  R_CRYPT_ERROR_FAILED ,  "EVP_CipherFinal_ex (  )  failed" )  ;  <end>
<start> return FALSE ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> return TRUE ;  <end>
<start> } <end>
<start>  <end>
<start> static gboolean r_crypt_encrypt_or_decrypt ( const gchar *inpath ,  const gchar *outpath ,  const uint8_t *key ,  gboolean encrypt ,  goffset maxsize ,  GError **error )  <end>
<start> { <end>
<start> FILE *infile = NULL ,  *outfile = NULL ;  <end>
<start> GError *ierror = NULL ;  <end>
<start> gboolean res = FALSE ;  <end>
<start>  <end>
<start> g_return_val_if_fail ( inpath ,  FALSE )  ;  <end>
<start> g_return_val_if_fail ( outpath ,  FALSE )  ;  <end>
<start> g_return_val_if_fail ( key ,  FALSE )  ;  <end>
<start> g_return_val_if_fail ( error == NULL || *error == NULL ,  FALSE )  ;  <end>
<start>  <end>
<start> infile = g_fopen ( inpath ,  "r" )  ;  <end>
<start> if  ( !infile )  { <end>
<start> int err = errno ;  <end>
<start> g_set_error ( error ,  G_FILE_ERROR ,  g_file_error_from_errno ( err )  ,  <end>
<start> "Failed opening %s for reading: %s" ,  inpath ,  g_strerror ( err )  )  ;  <end>
<start> res = FALSE ;  <end>
<start> goto out ;  <end>
<start> } <end>
<start>  <end>
<start> outfile = g_fopen ( outpath ,  "w" )  ;  <end>
<start> if  ( !outfile )  { <end>
<start> int err = errno ;  <end>
<start> g_set_error ( error ,  G_FILE_ERROR ,  g_file_error_from_errno ( err )  ,  <end>
<start> "Failed opening temporary file %s for writing: %s" ,  outpath ,  g_strerror ( err )  )  ;  <end>
<start> res = FALSE ;  <end>
<start> goto out ;  <end>
<start> } <end>
<start>  <end>
<start> res = encrypt_or_decrypt ( infile ,  outfile ,  key ,  encrypt ,  maxsize ,  &ierror )  ;  <end>
<start> if  ( !res )  { <end>
<start> g_propagate_prefixed_error ( error ,  ierror ,  <end>
<start> "Failed to %s image: " ,  encrypt ? "encrypt" : "decrypt" )  ;  <end>
<start> goto out ;  <end>
<start> } <end>
<start>  <end>
<start> res = TRUE ;  <end>
<start> out: <end>
<start> if  ( infile )  <end>
<start> fclose ( infile )  ;  <end>
<start> if  ( outfile )  <end>
<start> fclose ( outfile )  ;  <end>
<start> return res ;  <end>
<start> } <end>
<start>  <end>
<start> gboolean r_crypt_encrypt ( const gchar *in ,  const gchar *out ,  const guint8 *key ,  GError **error )  <end>
<start> { <end>
<start> return r_crypt_encrypt_or_decrypt ( in ,  out ,  key ,  TRUE ,  0 ,  error )  ;  <end>
<start> } <end>
<start>  <end>
<start> gboolean r_crypt_decrypt ( const gchar *in ,  const gchar *out ,  const guint8 *key ,  goffset maxsize ,  GError **error )  <end>
<start> { <end>
<start> return r_crypt_encrypt_or_decrypt ( in ,  out ,  key ,  FALSE ,  maxsize ,  error )  ;  <end>
<start> } <end>
<start> #define F_CPU 7372800UL <end>
<start> #include <avr/io.h> <end>
<start> #include <stdlib.h> <end>
<start> #include <util/delay.h> <end>
<start> #include <stdio.h> <end>
<start> #include <string.h> <end>
<start> #include <avr/interrupt.h> <end>
<start>  <end>
<start> #include "lcd.h" <end>
<start>  <end>
<start> #define KEY_PRTPORTB <end>
<start> #define KEY_DDRDDRB <end>
<start> #define KEY_PINPINB <end>
<start>  <end>
<start> #define VALUE_POT 50 <end>
<start> #define POT_ZERO 0 <end>
<start> #define CONFIRM_SOUND 2 <end>
<start> #define ALARM_SOUND 6 <end>
<start> #define WRONG_PASS 3 <end>
<start> #define ADC_PLUS 51 <end>
<start> #define ADC_MINUS 49 <end>
<start> #define PASS_LENGHT 4 <end>
<start> #define FIRST_ROW 0 <end>
<start> #define SECOND_ROW 1 <end>
<start> #define THIRD_ROW 2 <end>
<start> #define FOURTH_ROW 3 <end>
<start> #define MIDDLE_POSITION 5 <end>
<start>  <end>
<start> unsigned char keypad[4][4] = {{'1' , '4' , '7' , '*'} , {'2' , '5' , '8' , '0'} , {'3' , '6' , '9' , '#'} , {'A' , 'B' , 'C' , 'D'}} ;  <end>
<start> static char output[5] = {'*' , '*' , '*' , '*'} ;  <end>
<start> static int buzzerCounter ;  <end>
<start> static int doorOpen = 0 ;  <end>
<start> static int flagPot = 0 ;  <end>
<start> static int pot1 ;  <end>
<start> static int pot2 ;  <end>
<start> static char potChar[16] ;  <end>
<start> static int flagWrongPass = 0 ;  <end>
<start> static int wrongPassCounter = 3 ;  <end>
<start> const char *passwordCheck = "1598" ;  <end>
<start> const char *passwordLock = "####" ;  <end>
<start> const char confirm = 'A' ;  <end>
<start> unsigned char column ,  row ;  <end>
<start>  <end>
<start>  <end>
<start> char keyfind (  ) { <end>
<start> while ( 1 ) { <end>
<start> KEY_DDR = 0xF0 ;            <end>
<start> KEY_PRT = 0xFF ;  <end>
<start>  <end>
<start> do{ <end>
<start> KEY_PRT &= 0x0F ;       <end>
<start> asm ( "NOP" )  ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;   <end>
<start> }while ( column != 0x0F )  ;  <end>
<start>  <end>
<start> do{ <end>
<start> do{ <end>
<start> _delay_ms ( 20 )  ;               <end>
<start> column =  ( KEY_PIN & 0x0F )  ;   <end>
<start> }while ( column == 0x0F )  ;         <end>
<start>  <end>
<start> _delay_ms  ( 40 )  ;              <end>
<start> column =  ( KEY_PIN & 0x0F )  ;  <end>
<start> }while ( column == 0x0F )  ;  <end>
<start>  <end>
<start> KEY_PRT = 0xEF ;             <end>
<start> asm ( "NOP" )  ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;  <end>
<start>  <end>
<start> if ( column != 0x0F ) { <end>
<start> row = FIRST_ROW ;  <end>
<start> break ;  <end>
<start> } <end>
<start>  <end>
<start> KEY_PRT = 0xDF ;  <end>
<start> asm ( "NOP" )  ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;  <end>
<start>  <end>
<start> if ( column != 0x0F ) { <end>
<start> row = SECOND_ROW ;  <end>
<start> break ;  <end>
<start> } <end>
<start>  <end>
<start> KEY_PRT = 0xBF ;  <end>
<start> asm ( "NOP" )  ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;  <end>
<start>  <end>
<start> if ( column != 0x0F ) { <end>
<start> row = THIRD_ROW ;  <end>
<start> break ;  <end>
<start> } <end>
<start>  <end>
<start> KEY_PRT = 0x7F ;  <end>
<start> asm ( "NOP" )  ;  <end>
<start> column =  ( KEY_PIN & 0x0F )  ;  <end>
<start>  <end>
<start> if ( column != 0x0F ) { <end>
<start> row = FOURTH_ROW ;  <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start> if ( column == 0x0E ) { <end>
<start> return ( keypad[row][0] )  ;  <end>
<start> }else if ( column == 0x0D ) { <end>
<start> return ( keypad[row][1] )  ;  <end>
<start> }else if ( column == 0x0B )  { <end>
<start> return ( keypad[row][2] )  ;  <end>
<start> }else{ <end>
<start> return ( keypad[row][3] )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void buzzerDetection (  ) { <end>
<start> if ( flagWrongPass == 0 ) { <end>
<start> while ( buzzerCounter > 0 ) { <end>
<start> PORTC ^= _BV ( 7 )  ;  <end>
<start> _delay_ms ( 125 )  ;  <end>
<start> buzzerCounter-- ;  <end>
<start> } <end>
<start> } else if ( flagWrongPass == 1 ) { <end>
<start> while ( 1 ) { <end>
<start> PORTC ^= _BV ( 7 )  | _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  ;  <end>
<start> PORTA ^= _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  ;  <end>
<start>  <end>
<start> _delay_ms ( 125 )  ;  <end>
<start>  <end>
<start> if ( ! ( PINB & _BV ( PB0 )  )  ) { <end>
<start> if (  ( PINB & _BV ( PB0 )  )  == 0 ) { <end>
<start> flagWrongPass = 0 ;  <end>
<start> wrongPassCounter = WRONG_PASS ;  <end>
<start> PORTC |= _BV ( 7 )  ;  <end>
<start>  <end>
<start> if ( doorOpen == 0 ) { <end>
<start> PORTC |= _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  ;   <end>
<start> PORTA &= ~ ( _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  )  ;   <end>
<start> } else { <end>
<start> PORTC &= ~ ( _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  )  ;   <end>
<start> PORTA |= _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  ;   <end>
<start> } <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void turnServo (  )  { <end>
<start> if ( doorOpen == 1 ) { <end>
<start> PORTD ^= _BV ( 5 )  ;  <end>
<start> OCR1A = 276 ;   <end>
<start> } else if ( doorOpen == 0 ) { <end>
<start> PORTD ^= _BV ( 5 )  ;  <end>
<start> OCR1A = 59 ;   <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void writeLCD ( uint16_t adc )  { <end>
<start> char adcStr[16] ;  <end>
<start> itoa ( round ( adc )  ,  adcStr ,  10 )  ;  <end>
<start>  <end>
<start> if ( flagPot == 0 ) { <end>
<start> lcd_clrscr (  )  ;  <end>
<start>  <end>
<start> lcd_gotoxy ( 6 , FIRST_ROW )  ;  <end>
<start> lcd_puts ( adcStr )  ;  <end>
<start> } else if ( flagPot == 1 ) { <end>
<start> lcd_clrscr (  )  ;  <end>
<start>  <end>
<start> lcd_gotoxy ( 6 , FIRST_ROW )  ;  <end>
<start> lcd_puts ( potChar )  ;  <end>
<start> lcd_gotoxy ( 6 , SECOND_ROW )  ;  <end>
<start> lcd_puts ( adcStr )  ;  <end>
<start> } <end>
<start>  <end>
<start> if ( pot1 == VALUE_POT && pot2 == VALUE_POT ) { <end>
<start> lcd_clrscr (  )  ;  <end>
<start> lcd_puts ( "Otvoren sef!" )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void readPotentiometer (  ) { <end>
<start> uint16_t adcConversion ;  <end>
<start>  <end>
<start> while ( 1 ) { <end>
<start>  <end>
<start> adcConversion = ADC/10 ;  <end>
<start>  <end>
<start> if (  ( adcConversion<= ADC_PLUS && adcConversion >= ADC_MINUS )  && flagPot == 0 ) { <end>
<start> if ( ! ( PINB & _BV ( PB0 )  )  ) { <end>
<start> if (  ( PINB & _BV ( PB0 )  )  == 0 ) { <end>
<start> ADMUX |= _BV ( MUX0 )  ;   <end>
<start> flagPot = 1 ;  <end>
<start> pot1 = VALUE_POT ;  <end>
<start> itoa ( pot1 ,  potChar ,  10 )  ;  <end>
<start>  <end>
<start> PORTC ^= _BV ( 0 )  ;  <end>
<start> PORTA ^= _BV ( 4 )  ;  <end>
<start>  <end>
<start> buzzerCounter = CONFIRM_SOUND ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start> } <end>
<start> } <end>
<start> } else if (  ( adcConversion <= ADC_PLUS && adcConversion >= ADC_MINUS )  && flagPot == 1 ) { <end>
<start> if ( ! ( PINB & _BV ( PB0 )  )  ) { <end>
<start> if (  ( PINB & _BV ( PB0 )  )  == 0 ) { <end>
<start> pot2 = VALUE_POT ;  <end>
<start>  <end>
<start> PORTC ^= _BV ( 1 )  ;  <end>
<start> PORTA ^= _BV ( 3 )  ;  <end>
<start>  <end>
<start> buzzerCounter = CONFIRM_SOUND ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start> ADCSRA |= _BV ( ADSC )  ;  <end>
<start>  <end>
<start> while  ( ! ( ADCSRA & _BV ( ADIF )  )  )  ;  <end>
<start>  <end>
<start> writeLCD ( adcConversion )  ;  <end>
<start>  <end>
<start> _delay_ms ( 150 )  ;  <end>
<start>  <end>
<start> if ( pot1 == VALUE_POT && pot2 == VALUE_POT ) { <end>
<start> doorOpen = 1 ;  <end>
<start> ADMUX &= ~_BV ( MUX0 )  ;   <end>
<start> turnServo (  )  ;  <end>
<start> break ;  <end>
<start> } <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void checkPassword (  ) { <end>
<start> if (  ( !strncmp ( output ,  passwordLock ,  PASS_LENGHT )  )  && doorOpen == 1 ) { <end>
<start> lcd_clrscr (  )  ;  <end>
<start> lcd_puts ( "Sef zatvoren!" )  ;  <end>
<start>  <end>
<start> doorOpen = 0 ;  <end>
<start> turnServo (  )  ;  <end>
<start> buzzerCounter = CONFIRM_SOUND ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start>  <end>
<start> PORTC ^= _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  ;  <end>
<start> PORTA ^= _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  ;  <end>
<start>  <end>
<start> pot1 = POT_ZERO ;  <end>
<start> pot2 = POT_ZERO ;  <end>
<start> memset ( potChar ,  0 ,  sizeof ( potChar )  )  ;  <end>
<start> flagPot = 0 ;  <end>
<start>  <end>
<start> } else if ( strncmp ( output ,  passwordCheck ,  PASS_LENGHT )  ) { <end>
<start> lcd_clrscr (  )  ;  <end>
<start> lcd_puts ( "Netocna lozinka!" )  ;  <end>
<start>  <end>
<start> buzzerCounter = ALARM_SOUND ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start> wrongPassCounter-- ;  <end>
<start>  <end>
<start> if ( wrongPassCounter == 0 ) { <end>
<start> flagWrongPass = 1 ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start> } <end>
<start> } else  { <end>
<start> lcd_clrscr (  )  ;  <end>
<start> lcd_puts ( "Tocna lozinka!" )  ;  <end>
<start>  <end>
<start> buzzerCounter = CONFIRM_SOUND ;  <end>
<start> buzzerDetection (  )  ;  <end>
<start>  <end>
<start> PORTC ^= _BV ( 6 )  ;  <end>
<start> PORTA ^= _BV ( 5 )  ;  <end>
<start>  <end>
<start> _delay_ms ( 1000 )  ;  <end>
<start> readPotentiometer (  )  ;  <end>
<start> } <end>
<start> _delay_ms ( 1500 )  ;  <end>
<start> memset ( output ,  '*' ,  sizeof ( output ) -1 )  ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void keyPassword (  ) { <end>
<start> uint8_t i ;  <end>
<start> char pass ;  <end>
<start>  <end>
<start> lcd_clrscr (  )  ;  <end>
<start> lcd_puts ( "Unesite lozinku!" )  ;  <end>
<start>  <end>
<start> for ( i = 0 ;  i < PASS_LENGHT ;  i++ ) { <end>
<start> char password = keyfind (  )  ;  <end>
<start>  <end>
<start> output[i] = password ;  <end>
<start> lcd_gotoxy ( i+MIDDLE_POSITION , SECOND_ROW )  ;  <end>
<start> lcd_puts ( &output[i] )  ;  <end>
<start> } <end>
<start> output[4] = '\0' ;  <end>
<start>  <end>
<start> pass = keyfind (  )  ;  <end>
<start> if ( pass == confirm ) { <end>
<start> checkPassword (  )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> ISR ( TIMER0_COMP_vect ) { <end>
<start> PORTA ^= _BV ( 6 )  ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> ISR ( TIMER1_COMPA_vect ) { <end>
<start> if ( doorOpen == 1 ) { <end>
<start> PORTD ^= _BV ( 5 )  ;  <end>
<start> } <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> void initMain (  ) { <end>
<start> DDRA |= _BV ( 6 )  ;   <end>
<start>  <end>
<start> DDRB = 0xff ;   <end>
<start> PORTB = 0x00 ;  <end>
<start>  <end>
<start> DDRC = _BV ( 7 )  ;   <end>
<start>  <end>
<start> DDRC |= _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  ;   <end>
<start> PORTC = _BV ( 7 )  | _BV ( 0 )  | _BV ( 1 )  | _BV ( 6 )  ;  <end>
<start>  <end>
<start> DDRA |= _BV ( 3 )  | _BV ( 4 )  | _BV ( 5 )  ;   <end>
<start>  <end>
<start> DDRD |= _BV ( 5 )  ;   <end>
<start> TCNT1 = 0 ;  <end>
<start> ICR1 = 2303 ;   <end>
<start> TCCR1A = _BV ( WGM11 )  | _BV ( COM1A1 )  ;   <end>
<start> TCCR1B = _BV ( WGM12 )  | _BV ( WGM13 )  | _BV ( CS10 )  | _BV ( CS11 )  ;  <end>
<start> OCR1A = 59 ;   <end>
<start> TIMSK = _BV ( OCIE1A )  ;  <end>
<start>  <end>
<start>  <end>
<start> TCCR0 = _BV ( WGM01 )  | _BV ( WGM00 )  | _BV ( COM01 )  | _BV ( CS00 )  ;   <end>
<start> OCR0 = 200 ;  <end>
<start> TIMSK = _BV ( OCIE0 )  ;  <end>
<start>  <end>
<start> sei (  )  ;  <end>
<start>  <end>
<start> ADMUX = _BV ( REFS0 )  ;  <end>
<start> ADCSRA = _BV ( ADEN )  | _BV ( ADPS2 )  | _BV ( ADPS1 )  ;  <end>
<start>  <end>
<start> lcd_init ( LCD_DISP_ON )  ;  <end>
<start> lcd_clrscr (  )  ;  <end>
<start>  <end>
<start> memset ( potChar ,  0 ,  sizeof ( potChar )  )  ;  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> int main ( void ) { <end>
<start> initMain (  )  ;  <end>
<start>  <end>
<start> while  ( 1 ) { <end>
<start> keyPassword (  )  ;  <end>
<start> } <end>
<start> } <end>
<start> /******************************************************************************/ <end>
<start> /******************************************************************************/ <end>
<start>  <end>
<start> /* Device header file */ <end>
<start> #if defined ( __XC16__ )  <end>
<start>     #include <xc.h> <end>
<start> #elif defined ( __C30__ )  <end>
<start>     #if defined ( __PIC24E__ )  <end>
<start>     #include <p24Exxxx.h> <end>
<start>     #elif defined  ( __PIC24F__ ) ||defined  ( __PIC24FK__ )  <end>
<start> #include <p24Fxxxx.h> <end>
<start>     #elif defined ( __PIC24H__ )  <end>
<start> #include <p24Hxxxx.h> <end>
<start>     #endif <end>
<start> #endif <end>
<start>  <end>
<start> #include <stdint.h>         <end>
<start> #include <stdbool.h>        <end>
<start> #include <stdlib.h> <end>
<start> #include <stdio.h> <end>
<start>  <end>
<start> #include "system.h"         <end>
<start> #include "user.h"           <end>
<start>  <end>
<start> #include "database.h" <end>
<start> #include "debug.h" <end>
<start> #include "event.h" <end>
<start> #include "fingerPrintReader.h" <end>
<start> #include "miscHardware.h" <end>
<start> #include "wifi.h" <end>
<start>  <end>
<start> char debug[20] ;  <end>
<start> uint8_t lockFlag = FALSE ;   <end>
<start>  <end>
<start> /******************************************************************************/ <end>
<start> /* Main Program                                                               */ <end>
<start> /******************************************************************************/ <end>
<start>  <end>
<start> int16_t main ( void )  <end>
<start> { <end>
<start>     InitApp (  )  ;   <end>
<start>     while ( 1 )  { <end>
<start>  <end>
<start>         if  ( switchIsOn (  )  ) { <end>
<start>             turnOnLED ( 3 )  ;  <end>
<start>             lockFlag = FALSE ;  <end>
<start>         } <end>
<start>         else{ <end>
<start>             turnOffLED ( 3 )  ;  <end>
<start>         } <end>
<start>  <end>
<start>         if  ( buttonIsPressed (  )  )  {  <end>
<start>             if  ( switchIsOn (  )  ) { <end>
<start>                 WifiStart ( SERVER_MODE )  ;  <end>
<start>             } <end>
<start>             else { <end>
<start>                 FPRStart (  )  ;  <end>
<start>                 action = IDENTIFY ;  <end>
<start>                 sendFPRCommand ( FPR_IS_PRESSED ,  ZERO )  ;  <end>
<start>                  <end>
<start>             } <end>
<start>         } <end>
<start>  <end>
<start>         switch  ( reqType )  { <end>
<start>             case GET_PAGE: <end>
<start>                 if  ( switchIsOn (  )  )  sendPage (  )  ;  <end>
<start>                 else sendResponse ( "Error: Door is closed." )  ;  <end>
<start>                 reqType = DEFAULT ;  <end>
<start>                 reqParseState = DEFAULT ;  <end>
<start>                 break ;  <end>
<start>             case POST_ENROLL: <end>
<start>                 reqType = DEFAULT ;  <end>
<start>                 action = ENROLL ;  <end>
<start>                 if  ( wifiEnrollProgress != 0 )  break ;  <end>
<start>                 pendingUserID = findEmptySpot (  )  ;  <end>
<start>                 FPRStart (  )  ;  <end>
<start>                 int newUser =  ( uint32_t ) pendingUserID ;  <end>
<start>                 sendFPRCommand ( FPR_ENROLL_START ,  newUser )  ;  <end>
<start>                 break ;  <end>
<start>             case POST_DELETE: <end>
<start>                 reqType = DEFAULT ;  <end>
<start>                 sendFPRCommand ( FPR_DELETE_ALL ,  ZERO )  ;  <end>
<start>                 deleteDatabase (  )  ;  <end>
<start>                 break ;  <end>
<start>             case POST_SET_WIFI: <end>
<start>                 saveWifiInfo (  )  ;  <end>
<start> delay ( 4000 )  ;  <end>
<start>                 WifiStart ( CLIENT_MODE )  ;  <end>
<start> delay ( 1000 )  ;  <end>
<start>                 sendUpdate (  )  ;  <end>
<start>                 updateFlag = TRUE ;  <end>
<start>                 reqType = DEFAULT ;  <end>
<start>                 break ;  <end>
<start>             default: <end>
<start>                 if ( lockFlag == FALSE ) { <end>
<start>                         if  ( !switchIsOn (  )  )  { <end>
<start>                             setTimeout ( 3 )  ;  <end>
<start>                             action = TIMEOUT_LOCK ;  <end>
<start>                             FPRState = PARSE_FPR_MSG ;  <end>
<start>                             lockFlag = TRUE ;  <end>
<start>                         } <end>
<start>                     } <end>
<start>                 if (  ( minute % 30 )  == 0 &&  ( updateFlag == FALSE )  ) { <end>
<start>                         WifiStart ( CLIENT_MODE )  ;  <end>
<start> delay ( 1000 )  ;  <end>
<start>                         sendUpdate (  )  ;  <end>
<start>                         updateFlag = TRUE ;  <end>
<start>                         delay ( 500 )  ;  <end>
<start>                         turnOnWifiChip ( FALSE )  ;  <end>
<start>                     } <end>
<start>                 break ;  <end>
<start>         } <end>
<start>  <end>
<start>  <end>
<start>         if  ( FPRState == PARSE_FPR_MSG )  {   <end>
<start>  <end>
<start>             int i = 0 ;  <end>
<start>             switch  ( action )  { <end>
<start>                 case DOOR_IS_OPENED: <end>
<start>                     if  ( !switchIsOn (  )  )  { <end>
<start>                         setTimeout ( 5 )  ;  <end>
<start>                         action = TIMEOUT_LOCK ;  <end>
<start>                     } <end>
<start>                     break ;  <end>
<start>                 case IDENTIFY: <end>
<start>                     identify (  )  ;  <end>
<start>                     break ;  <end>
<start>                 case ENROLL: <end>
<start>                     enroll (  )  ;  <end>
<start>                     break ;  <end>
<start>                 case DELETE: <end>
<start>                     sendFPRCommand ( FPR_DELETE_ALL ,  ZERO )  ;  <end>
<start>                     break ;  <end>
<start>                 case DELETE_USER: <end>
<start>                     while ( newDeleted[i] != 0xFF ) { <end>
<start>                         sendFPRCommand  ( FPR_DELETE_ID ,  newDeleted[i++] )  ;  <end>
<start>                         delay ( 200 )  ;  <end>
<start>                     } <end>
<start>                     action = DEFAULT ;  <end>
<start>                     break ;  <end>
<start>                 case OPEN_DOOR: <end>
<start>                     <end>
<start>                     turnAllLEDOff (  )  ;  <end>
<start>                     turnOnLED ( 1 )  ;  <end>
<start>                     setTimeout ( 5 )  ;  <end>
<start>                     action = TIMEOUT_LOCK ;  <end>
<start>                     lockDeadBolt ( FALSE )  ;  <end>
<start>                     lockFlag = FALSE ;  <end>
<start>                     break ;  <end>
<start>                 case TIMEOUT_LOCK: <end>
<start>                     if  ( switchIsOn (  )  )  { <end>
<start>                         action = DOOR_IS_OPENED ;  <end>
<start>                     } else if  ( isTimeout (  )  )  { <end>
<start>                         turnOnWifiChip ( FALSE )  ;  <end>
<start>                         lockDeadBolt ( TRUE )  ;  <end>
<start>                         lockFlag = TRUE ;  <end>
<start>                         action = DEFAULT ;  <end>
<start>                     } <end>
<start>                     break ;  <end>
<start>                 case FINGER_NOT_FOUND: <end>
<start>                     turnAllLEDOff (  )  ;  <end>
<start>                     turnOnLED ( 0 )  ;  <end>
<start>                     action = DEFAULT ;  <end>
<start>                     FPRState = DEFAULT ;  <end>
<start>                     break ;  <end>
<start>  <end>
<start>             } <end>
<start>         } <end>
<start>     } <end>
<start> } <end>
<start> #include "main.h" <end>
<start>  <end>
<start> #define DEBUG_MODE 0  <end>
<start>  <end>
<start> void RC522_System_Init ( void )  ;  <end>
<start> void genRandCode ( u8* Des )  ;  <end>
<start> void writeQRCodeBuffer (  )  ;  <end>
<start> unsigned char card1[5] = { 0x20 ,  0x25 ,  0x35 ,  0x55 ,  0x3F } ;   <end>
<start> unsigned char card2[4] = { 0xDE ,  0x8A ,  0xDF ,  0x2B } ;   <end>
<start>  <end>
<start> unsigned char snr ,  buf[16] = " " ,  bufr[16] ,  TagType[2] ,  SelectedSnr[4] ,  DefaultKey[6] = { 0xFF ,  0xFF ,  0xFF ,  0xFF ,  0xFF ,  0xFF } ;  <end>
<start> unsigned char Read_Data[16] ,  PassWd[6] ,  WriteData[16] ,  RevBuffer[30] ,  MLastSelectedSnr[4] ,  NewKey[16] ;  <end>
<start> char cardID[4] ;  <end>
<start> char status ;  <end>
<start>  <end>
<start> u8 securityCode[7] ;  <end>
<start>  <end>
<start> u8 modeFlag = 0 ;   <end>
<start>  <end>
<start> QRcode* qrcode ;  <end>
<start>  <end>
<start> int main ( void )  <end>
<start> { <end>
<start>     RC522_System_Init (  )  ;   <end>
<start>      <end>
<start>      <end>
<start>     OLED_Clear (  )  ;  <end>
<start>     OLED_ShowString ( 0 ,  0 ,  "Welcome!" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  16 ,  "RFID System" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  32 ,  "Powered by WRL" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  48 ,  "Version:0.01" ,  16 ,  1 )  ;  <end>
<start>     OLED_Refresh (  )  ;  <end>
<start>     rainbowCycle ( 1 )  ;  <end>
<start>     beepOneSecOn (  )  ;  <end>
<start>  <end>
<start>     if  ( Key_Scan ( GPIOB ,  GPIO_Pin_12 )  == KEY_ON )   <end>
<start>     { <end>
<start>         modeFlag = 1 ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>  <end>
<start>      <end>
<start>     char* ok = "OK" ;  <end>
<start>     char* at = "AT\r\n" ;  <end>
<start>     char* at_cwmode = "AT+CWMODE=1\r\n" ;  <end>
<start>     char* at_rst = "AT+RST\r\n" ;  <end>
<start>     char* at_cifsr = "AT+CIFSR\r\n" ;  <end>
<start>     char* at_cipmux = "AT+CIPMUX=0\r\n" ;  <end>
<start>     char* at_cipmode = "AT+CIPMODE=1\r\n" ;  <end>
<start>     char* at_cipstart = "AT+CIPSTART=\"TCP\" , \"192.168.1.110\" , 25500\r\n" ;  <end>
<start>     char* at_cipsend = "AT+CIPSEND\r\n" ;  <end>
<start>  <end>
<start>     char* WIFI_SSID = "624" ;   <end>
<start>     char* WIFI_KEY = "624624nbnb" ;   <end>
<start>  <end>
<start>     char at_cwjap[64] ;  <end>
<start>     memset ( at_cwjap ,  0 ,  sizeof ( at_cwjap )  )  ;  <end>
<start>     strcat ( at_cwjap ,  "AT+CWJAP=\"" )  ;  <end>
<start>     strcat ( at_cwjap ,  WIFI_SSID )  ;  <end>
<start>     strcat ( at_cwjap ,  "\" , \"" )  ;  <end>
<start>     strcat ( at_cwjap ,  WIFI_KEY )  ;  <end>
<start>     strcat ( at_cwjap ,  "\"\r\n" )  ;  <end>
<start>  <end>
<start>     OLED_Clear (  )  ;  <end>
<start>     OLED_ShowString ( 0 ,  0 ,  "Connect WIFI:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  16 ,   ( u8* ) WIFI_SSID ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  32 ,  "Password:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  48 ,   ( u8* ) WIFI_KEY ,  16 ,  1 )  ;  <end>
<start>     OLED_Refresh (  )  ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>     USART1_Send_Data ( "+++" ,  strlen ( "+++" )  )  ;  <end>
<start>     delay_ms ( 100 )  ;   <end>
<start>     USART1_Send_Data ( "+++" ,  strlen ( "+++" )  )  ;  <end>
<start>     delay_ms ( 100 )  ;   <end>
<start>  <end>
<start>     while  ( ESP8266_Send_Answer ( at ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_cwmode ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_rst ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_cwjap ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     OLED_Clear (  )  ;  <end>
<start>     OLED_ShowString ( 0 ,  0 ,  "Connect WIFI:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  16 ,  "State: OK" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  32 ,  "Ready TO:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  48 ,  "Server" ,  16 ,  1 )  ;  <end>
<start>     OLED_Refresh (  )  ;  <end>
<start>     while  ( ESP8266_Send_Answer ( at_cifsr ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_cipmux ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_cipmode ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     while  ( ESP8266_Send_Answer ( at_cipstart ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>     OLED_Clear (  )  ;  <end>
<start>     OLED_ShowString ( 0 ,  0 ,  "Connect Server:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  16 ,  "State: OK" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  32 ,  "Ready To:" ,  16 ,  1 )  ;  <end>
<start>     OLED_ShowString ( 0 ,  48 ,  "Communication" ,  16 ,  1 )  ;  <end>
<start>     OLED_Refresh (  )  ;  <end>
<start>     while  ( ESP8266_Send_Answer ( at_cipsend ,  ok )  )  { <end>
<start>         delay_ms ( 100 )  ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     char idCode[8] = "0000001" ;  <end>
<start>     USART1_Send_Data ( idCode ,  strlen ( idCode )  )  ;  <end>
<start>     delay_ms ( 100 )  ;  <end>
<start>  <end>
<start>     genRandCode ( securityCode )  ;  <end>
<start>  <end>
<start>     ws2812bSetAll ( YELLOW )  ;  <end>
<start>  <end>
<start>     beepOneSecOn (  )  ;  <end>
<start>  <end>
<start>     if  ( modeFlag == 0 )  { <end>
<start>         OLED_Clear (  )  ;  <end>
<start> writeQRCodeBuffer (  )  ;  <end>
<start>         OLED_ShowString ( 65 ,  0 ,  "Welcome!" ,  16 ,  1 )  ;  <end>
<start>         OLED_ShowString ( 65 ,  16 ,  "Security" ,  16 ,  1 )  ;  <end>
<start> OLED_ShowString ( 65 ,  32 ,  "Code:" ,  16 ,  1 )  ;  <end>
<start>         OLED_ShowString ( 65 ,  48 ,  securityCode ,  16 ,  1 )  ;  <end>
<start>         OLED_Refresh (  )  ;  <end>
<start>     } else if  ( modeFlag == 1 )  { <end>
<start>         OLED_Clear (  )  ;  <end>
<start>         OLED_ShowString ( 0 ,  0 ,  "Welcome!" ,  16 ,  0 )  ;  <end>
<start>         OLED_ShowString ( 0 ,  16 ,  "New Card Regist" ,  16 ,  1 )  ;  <end>
<start>         OLED_ShowString ( 0 ,  32 ,  "Waiting For Card" ,  16 ,  1 )  ;  <end>
<start>         OLED_ShowString ( 0 ,  48 ,  "......" ,  16 ,  1 )  ;  <end>
<start>         OLED_Refresh (  )  ;  <end>
<start>     } <end>
<start>  <end>
<start>     while  ( 1 )  { <end>
<start>         if  ( URecv_Index )  { <end>
<start>             if  ( strstr ( URecv ,  "mode1state:ok" )  != NULL )  { <end>
<start>                 ws2812bSetAll ( GREEN )  ;  <end>
<start>                 OLED_Clear (  )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Verify OK" ,  16 ,  0 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "Opening Now!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>  <end>
<start> #endif <end>
<start>                 OLED_Refresh (  )  ;  <end>
<start>                 beepOneSecOn (  )  ;  <end>
<start>  <end>
<start>                 relay_on (  )  ;   <end>
<start>                 delay_10ms ( 120 )  ;  <end>
<start>                 relay_off (  )  ;  <end>
<start>             } else if  ( strstr ( URecv ,  "mode0state:ok" )  != NULL )  { <end>
<start>                 ws2812bSetAll ( GREEN )  ;  <end>
<start>                 OLED_Clear (  )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Registing OK" ,  16 ,  0 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "Successfully!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>  <end>
<start> #endif <end>
<start>                 OLED_Refresh (  )  ;  <end>
<start>                 beepOneSecOn (  )  ;  <end>
<start>             } else if  ( URecv[0] == 'C' )  { <end>
<start>                 u8 codeFlag = 1 ,  i ;  <end>
<start>                 for  ( i = 0 ;  i < 6 ;  i++ )  { <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                     OLED_Clear (  )  ;  <end>
<start>                     OLED_ShowChar ( 0 ,  0 ,  URecv[2 + i] ,  16 ,  0 )  ;  <end>
<start>                     OLED_ShowChar ( 0 ,  16 ,  securityCode[i] ,  16 ,  1 )  ;  <end>
<start>                     OLED_Refresh (  )  ;  <end>
<start>                     delay_10ms ( 100 )  ;  <end>
<start> #endif <end>
<start>                     if  ( URecv[2 + i] != securityCode[i] )  { <end>
<start>                         codeFlag = 0 ;  <end>
<start>                         break ;  <end>
<start>                     } <end>
<start>                 } <end>
<start>  <end>
<start>                 if  ( codeFlag == 1 )  { <end>
<start>                     ws2812bSetAll ( GREEN )  ;  <end>
<start>                     OLED_Clear (  )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  0 ,  "Verify OK" ,  16 ,  0 )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  16 ,  "Opening Now!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                     OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>  <end>
<start> #endif <end>
<start>                     OLED_Refresh (  )  ;  <end>
<start>                     beepOneSecOn (  )  ;  <end>
<start>                     relay_on (  )  ;   <end>
<start>                     delay_10ms ( 200 )  ;  <end>
<start>                     relay_off (  )  ;  <end>
<start>                 } else if  ( codeFlag == 0 )  { <end>
<start>                     ws2812bSetAll ( RED )  ;  <end>
<start>                     OLED_Clear (  )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  0 ,  "Failed!" ,  16 ,  0 )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  16 ,  "Code is wrong!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                     OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start>                     OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>  <end>
<start> #endif <end>
<start>                     OLED_Refresh (  )  ;  <end>
<start>                     beepOneSecOn (  )  ;  <end>
<start>                     delay_ms ( 200 )  ;  <end>
<start>                     beepOneSecOn (  )  ;  <end>
<start>                 } <end>
<start>             } else { <end>
<start>                 ws2812bSetAll ( RED )  ;  <end>
<start>                 OLED_Clear (  )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Failed!" ,  16 ,  0 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "Unknow Error!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Server Return:" ,  16 ,  1 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  48 ,   ( u8* ) URecv ,  16 ,  1 )  ;  <end>
<start>  <end>
<start> #endif <end>
<start>                 OLED_Refresh (  )  ;  <end>
<start>                 beepOneSecOn (  )  ;  <end>
<start>                 delay_ms ( 200 )  ;  <end>
<start>                 beepOneSecOn (  )  ;  <end>
<start>             } <end>
<start>  <end>
<start>             ws2812bSetAll ( YELLOW )  ;  <end>
<start>             if  ( modeFlag == 0 )  { <end>
<start>                 genRandCode ( securityCode )  ;  <end>
<start> OLED_Clear (  )  ;  <end>
<start> writeQRCodeBuffer (  )  ;  <end>
<start> OLED_ShowString ( 65 ,  0 ,  "Welcome!" ,  16 ,  1 )  ;  <end>
<start> OLED_ShowString ( 65 ,  16 ,  "Security" ,  16 ,  1 )  ;  <end>
<start> OLED_ShowString ( 65 ,  32 ,  "Code:" ,  16 ,  1 )  ;  <end>
<start> OLED_ShowString ( 65 ,  48 ,  securityCode ,  16 ,  1 )  ;  <end>
<start> OLED_Refresh (  )  ;  <end>
<start>             } else if  ( modeFlag == 1 )  { <end>
<start>                 OLED_Clear (  )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  0 ,  "Welcome!" ,  16 ,  0 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  16 ,  "New Card Regist" ,  16 ,  1 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  32 ,  "Waiting For Card" ,  16 ,  1 )  ;  <end>
<start>                 OLED_ShowString ( 0 ,  48 ,  "......" ,  16 ,  1 )  ;  <end>
<start>                 OLED_Refresh (  )  ;  <end>
<start>             } <end>
<start>  <end>
<start>             URecv_Index = 0 ;  <end>
<start>             memset ( URecv ,  0 ,  sizeof ( URecv )  )  ;  <end>
<start>         } <end>
<start>  <end>
<start>         status = PcdRequest ( REQ_ALL ,  TagType )  ;  <end>
<start>         if  ( !status )  { <end>
<start>             status = PcdAnticoll ( SelectedSnr )  ;  <end>
<start>             if  ( !status )  { <end>
<start>                 status = PcdSelect ( SelectedSnr )  ;  <end>
<start>                 if  ( !status )  { <end>
<start>                     snr = 1 ;   <end>
<start>                     status = PcdAuthState ( KEYA ,   ( snr * 4 + 3 )  ,  DefaultKey ,  SelectedSnr )  ;   <end>
<start>                     { <end>
<start>                         if  ( !status )  { <end>
<start>                             status = PcdRead (  ( snr * 4 + 0 )  ,  buf )  ;   <end>
<start>                              <end>
<start>                              <end>
<start>                             if  ( !status )   <end>
<start>                             { <end>
<start>                                 u8 cardIDChar[9] ,  sendBuff[16] ;  <end>
<start>                                 memset ( cardIDChar ,  0 ,  sizeof ( cardIDChar )  )  ;  <end>
<start>                                 memset ( sendBuff ,  0 ,  sizeof ( sendBuff )  )  ;  <end>
<start>  <end>
<start>                                 HexToStr ( cardIDChar ,  9 ,  SelectedSnr ,  4 )  ;  <end>
<start>  <end>
<start>                                 if  ( modeFlag == 0 )  { <end>
<start>                                     sendBuff[0] = '0' ;   <end>
<start>                                     sendBuff[1] = 'D' ;   <end>
<start>                                     sendBuff[2] = 0 ;  <end>
<start>                                     strcat (  ( char* ) sendBuff ,   ( char* ) cardIDChar )  ;  <end>
<start>                                     USART1_Send_Data (  ( char* ) sendBuff ,  strlen (  ( char* ) sendBuff )  )  ;  <end>
<start>                                     delay_ms ( 100 )  ;  <end>
<start>  <end>
<start>                                     OLED_Clear (  )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  0 ,  "Verifying..." ,  16 ,  0 )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  16 ,  "Please Waiting!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                                     OLED_ShowString ( 0 ,  32 ,  "Card ID:" ,  16 ,  1 )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  48 ,  cardIDChar ,  16 ,  1 )  ;  <end>
<start> #endif <end>
<start>                                     OLED_Refresh (  )  ;  <end>
<start>  <end>
<start>                                 } else if  ( modeFlag == 1 )  { <end>
<start>                                     sendBuff[0] = '1' ;   <end>
<start>                                     sendBuff[1] = 'D' ;   <end>
<start>                                     sendBuff[2] = 0 ;  <end>
<start>                                     strcat (  ( char* ) sendBuff ,   ( char* ) cardIDChar )  ;  <end>
<start>                                     USART1_Send_Data (  ( char* ) sendBuff ,  strlen (  ( char* ) sendBuff )  )  ;  <end>
<start>                                     delay_ms ( 100 )  ;  <end>
<start>  <end>
<start>                                     OLED_Clear (  )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  0 ,  "Registing..." ,  16 ,  0 )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  16 ,  "Please Waiting!" ,  16 ,  1 )  ;  <end>
<start> #if DEBUG_MODE == 1 <end>
<start>                                     OLED_ShowString ( 0 ,  32 ,  "Card ID:" ,  16 ,  1 )  ;  <end>
<start>                                     OLED_ShowString ( 0 ,  48 ,  cardIDChar ,  16 ,  1 )  ;  <end>
<start> #endif <end>
<start>                                     OLED_Refresh (  )  ;  <end>
<start>                                 } <end>
<start>  <end>
<start>                                 LED_ON ;  <end>
<start>                                  <end>
<start>                                  <end>
<start>                                 WaitCardOff (  )  ;  <end>
<start>                             } <end>
<start>                         } <end>
<start>                     } <end>
<start>                 } <end>
<start>             } <end>
<start>         } <end>
<start>         LED_OFF ;  <end>
<start>     } <end>
<start> } <end>
<start>  <end>
<start> void RC522_System_Init ( void )  <end>
<start> { <end>
<start>     beepInit (  )  ;  <end>
<start>     RC522_Init (  )  ;  <end>
<start>     OLED_Init (  )  ;  <end>
<start>     OLED_ColorTurn ( 0 )  ;   <end>
<start>     OLED_DisplayTurn ( 0 )  ;   <end>
<start>     ESP8266_Init (  )  ;  <end>
<start>     ws2812bInit (  )  ;  <end>
<start>     buttonInit ( key1_GPIO_CLK ,  key1_GPIO_PORT ,  key1_pin )  ;  <end>
<start>     relay_init (  )  ;  <end>
<start>  <end>
<start>     LED_OFF ;  <end>
<start>     delay_10ms ( 10 )  ;  <end>
<start>     PcdReset (  )  ;  <end>
<start>     PcdAntennaOff (  )  ;  <end>
<start>     PcdAntennaOn (  )  ;  <end>
<start>     M500PcdConfigISOType ( 'A' )  ;  <end>
<start>     LED_ON ;  <end>
<start>     delay_10ms ( 10 )  ;  <end>
<start>     LED_OFF ;  <end>
<start>     delay_10ms ( 10 )  ;  <end>
<start>     LED_ON ;  <end>
<start>     delay_10ms ( 10 )  ;  <end>
<start>     LED_OFF ;  <end>
<start> } <end>
<start>  <end>
<start> void genRandCode ( u8* Des )  <end>
<start> { <end>
<start>      <end>
<start>     u8 temp[6] ,  tempint[13] ;  <end>
<start>     getRND ( temp ,  6 )  ;  <end>
<start>     HexToStr ( tempint ,  13 ,  temp ,  6 )  ;  <end>
<start>     int i ,  j = 0 ;  <end>
<start>     for  ( i = 0 ;  i < 6 ;  i++ )  { <end>
<start>         if  ( tempint[i * 2] >= 65 && tempint[i * 2] <= 70 )  { <end>
<start>             tempint[i * 2] -= 6 ;  <end>
<start>             j++ ;  <end>
<start>         } <end>
<start>         if  ( tempint[i * 2 + 1] >= 65 && tempint[i * 2 + 1] <= 70 )  { <end>
<start>             tempint[i * 2 + 1] -= 6 ;  <end>
<start>             j++ ;  <end>
<start>         } <end>
<start>         Des[i] =  ( tempint[i * 2] + tempint[i * 2 + 1] - 7 * j )  / 2 ;  <end>
<start>         j = 0 ;  <end>
<start>     } <end>
<start>      <end>
<start> QRcode_free ( qrcode )  ;  <end>
<start>     qrcode = QRcode_encodeString (  ( const char* ) Des ,  1 ,  QR_ECLEVEL_L ,  QR_MODE_8 ,  0 )  ;  <end>
<start> } <end>
<start>  <end>
<start> void writeQRCodeBuffer (  )  <end>
<start> { <end>
<start>     int x ,  y ,  offsetx = 0 ;  <end>
<start>     for  ( y = 0 ;  y < qrcode->width * 3 ;  y += 3 )  { <end>
<start>         for  ( x = 0 ;  x < qrcode->width * 3 ;  x += 3 )  { <end>
<start>             if  ( qrcode->data[y / 3 * qrcode->width + x / 3] & 0x01 )  { <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y + 1 ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y + 2 ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 1 ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 2 ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y + 1 ,  1 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y + 2 ,  1 )  ;  <end>
<start>             } <end>
<start>  <end>
<start>             else { <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y + 1 ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y + 2 ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 1 ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + offsetx ,  y + 2 ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 2 + offsetx ,  y + 1 ,  0 )  ;  <end>
<start>                 OLED_DrawPoint ( x + 1 + offsetx ,  y + 2 ,  0 )  ;  <end>
<start>             } <end>
<start>         } <end>
<start>     } <end>
<start> } <end>
<start>  <end>
<start> #include <string.h> <end>
<start> #include <time.h> <end>
<start> #include <unistd.h> <end>
<start>  <end>
<start> #include "freertos/FreeRTOS.h" <end>
<start> #include "freertos/event_groups.h" <end>
<start> #include "nvs_flash.h" <end>
<start> #include "esp_wifi.h" <end>
<start> #include "esp_smartconfig.h" <end>
<start> #include "esp_event_loop.h" <end>
<start> #include "esp_log.h" <end>
<start> #include "lwip/apps/sntp.h" <end>
<start>  <end>
<start> #include "qcloud_iot_export.h" <end>
<start> #include "qcloud_iot_demo.h" <end>
<start> #include "qcloud_wifi_config.h" <end>
<start> #include "board_ops.h" <end>
<start> #include "qrcode.h" <end>
<start>  <end>
<start> #include "../build/include/sdkconfig.h" <end>
<start>  <end>
<start> #ifndef CONFIG_WIFI_CONFIG_ENABLED <end>
<start> /* WiFi router SSID  */ <end>
<start> #define TEST_WIFI_SSID CONFIG_DEMO_WIFI_SSID <end>
<start> /* WiFi router password */ <end>
<start> #define TEST_WIFI_PASSWORD CONFIG_DEMO_WIFI_PASSWORD <end>
<start>  <end>
<start> static const int          CONNECTED_BIT = BIT0 ;  <end>
<start> static EventGroupHandle_t wifi_event_group ;  <end>
<start> bool                      wait_for_wifi_ready ( int event_bits ,  uint32_t wait_cnt ,  uint32_t BlinkTime )  <end>
<start> { <end>
<start>     EventBits_t uxBits ;  <end>
<start>     uint32_t    cnt       = 0 ;  <end>
<start>     uint8_t     blueValue = 0 ;  <end>
<start>  <end>
<start>     while  ( cnt++ < wait_cnt )  { <end>
<start>         uxBits = xEventGroupWaitBits ( wifi_event_group ,  event_bits ,  true ,  false ,  BlinkTime / portTICK_RATE_MS )  ;  <end>
<start>  <end>
<start>         if  ( uxBits & CONNECTED_BIT )  { <end>
<start>             Log_d ( "WiFi Connected to AP" )  ;  <end>
<start>             return true ;  <end>
<start>         } <end>
<start>  <end>
<start>         blueValue =  ( ~blueValue )  & 0x01 ;  <end>
<start>         set_wifi_led_state ( blueValue )  ;  <end>
<start>     } <end>
<start>  <end>
<start>     xEventGroupClearBits ( wifi_event_group ,  CONNECTED_BIT )  ;  <end>
<start>  <end>
<start>     return false ;  <end>
<start> } <end>
<start>  <end>
<start> static void wifi_connection ( void )  <end>
<start> { <end>
<start>     wifi_config_t wifi_config = { <end>
<start>         .sta = <end>
<start>             { <end>
<start>                 .ssid     = TEST_WIFI_SSID ,  <end>
<start>                 .password = TEST_WIFI_PASSWORD ,  <end>
<start>             } ,  <end>
<start>     } ;  <end>
<start>     Log_i ( "Setting WiFi configuration SSID %s..." ,  wifi_config.sta.ssid )  ;  <end>
<start>  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_set_config ( ESP_IF_WIFI_STA ,  &wifi_config )  )  ;  <end>
<start>  <end>
<start>     esp_wifi_connect (  )  ;  <end>
<start> } <end>
<start> static esp_err_t _esp_event_handler ( void* ctx ,  system_event_t* event )  <end>
<start> { <end>
<start>     Log_i ( "event = %d" ,  event->event_id )  ;  <end>
<start>  <end>
<start>     switch  ( event->event_id )  { <end>
<start>         case SYSTEM_EVENT_STA_START: <end>
<start>             Log_i ( "SYSTEM_EVENT_STA_START" )  ;  <end>
<start>             wifi_connection (  )  ;  <end>
<start>             break ;  <end>
<start>  <end>
<start>         case SYSTEM_EVENT_STA_GOT_IP: <end>
<start>             Log_i ( "Got IPv4[%s]" ,  ip4addr_ntoa ( &event->event_info.got_ip.ip_info.ip )  )  ;  <end>
<start>             xEventGroupSetBits ( wifi_event_group ,  CONNECTED_BIT )  ;  <end>
<start>  <end>
<start>             break ;  <end>
<start>  <end>
<start>         case SYSTEM_EVENT_STA_DISCONNECTED: <end>
<start>             Log_i ( "SYSTEM_EVENT_STA_DISCONNECTED" )  ;  <end>
<start>             xEventGroupClearBits ( wifi_event_group ,  CONNECTED_BIT )  ;  <end>
<start>             esp_wifi_connect (  )  ;  <end>
<start>             break ;  <end>
<start>  <end>
<start>         default: <end>
<start>             break ;  <end>
<start>     } <end>
<start>  <end>
<start>     return ESP_OK ;  <end>
<start> } <end>
<start>  <end>
<start> static void esp_wifi_initialise ( void )  <end>
<start> { <end>
<start>     tcpip_adapter_init (  )  ;  <end>
<start>  <end>
<start>     wifi_event_group = xEventGroupCreate (  )  ;  <end>
<start>     ESP_ERROR_CHECK ( esp_event_loop_init ( _esp_event_handler ,  NULL )  )  ;  <end>
<start>     wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT (  )  ;  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_init ( &cfg )  )  ;  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_set_storage ( WIFI_STORAGE_FLASH )  )  ;  <end>
<start>  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_set_mode ( WIFI_MODE_STA )  )  ;  <end>
<start>     ESP_ERROR_CHECK ( esp_wifi_start (  )  )  ;  <end>
<start> } <end>
<start> static void setup_sntp ( void )  <end>
<start> { <end>
<start>     sntp_setoperatingmode ( SNTP_OPMODE_POLL )  ;  <end>
<start>  <end>
<start>      <end>
<start>      <end>
<start>     sntp_setservername ( 0 ,  "time1.cloud.tencent.com" )  ;  <end>
<start>     sntp_setservername ( 1 ,  "cn.pool.ntp.org" )  ;  <end>
<start>     sntp_setservername ( 2 ,  "time-a.nist.gov" )  ;  <end>
<start>     sntp_setservername ( 3 ,  "cn.ntp.org.cn" )  ;  <end>
<start>  <end>
<start>     sntp_init (  )  ;  <end>
<start>  <end>
<start>      <end>
<start>     time_t    now         = 0 ;  <end>
<start>     struct tm timeinfo    = {0} ;  <end>
<start>     int       retry       = 0 ;  <end>
<start>     const int retry_count = 10 ;  <end>
<start>  <end>
<start>     while  ( timeinfo.tm_year <  ( 2019 - 1900 )  && ++retry < retry_count )  { <end>
<start>         Log_d ( "Waiting for system time to be set...  ( %d/%d ) " ,  retry ,  retry_count )  ;  <end>
<start>         sleep ( 1 )  ;  <end>
<start>         time ( &now )  ;  <end>
<start>         localtime_r ( &now ,  &timeinfo )  ;  <end>
<start>     } <end>
<start>  <end>
<start>      <end>
<start>     setenv ( "TZ" ,  "CST-8" ,  1 )  ;  <end>
<start>     tzset (  )  ;  <end>
<start> } <end>
<start>  <end>
<start> #endif   <end>
<start>  <end>
<start> void qcloud_demo_task ( void* parm )  <end>
<start> { <end>
<start>     bool wifi_connected = false ;  <end>
<start>     Log_i ( "qcloud_demo_task start" )  ;  <end>
<start> #ifndef CONFIG_WIFI_CONFIG_ENABLED <end>
<start>      <end>
<start>     board_init (  )  ;  <end>
<start>     esp_wifi_initialise (  )  ;  <end>
<start>      <end>
<start>     wifi_connected = wait_for_wifi_ready ( CONNECTED_BIT ,  20 ,  1000 )  ;  <end>
<start>     if  ( wifi_connected )  { <end>
<start>         setup_sntp (  )  ;  <end>
<start>         qcloud_iot_explorer_demo ( CONFIG_DEMO_EXAMPLE_SELECT )  ;  <end>
<start>     } else { <end>
<start>         Log_e ( "WiFi is not ready ,  please check configuration" )  ;  <end>
<start>     } <end>
<start> #else <end>
<start>     qcloud_iot_explorer_demo ( CONFIG_DEMO_EXAMPLE_SELECT )  ;  <end>
<start> #endif   <end>
<start>  <end>
<start>     Log_w ( "qcloud_demo_task quit" )  ;  <end>
<start>     vTaskDelete ( NULL )  ;  <end>
<start> } <end>
<start>  <end>
<start> void app_main (  )  <end>
<start> { <end>
<start>     ESP_ERROR_CHECK ( nvs_flash_init (  )  )  ;  <end>
<start>      <end>
<start>     IOT_Log_Set_Level ( eLOG_DEBUG )  ;  <end>
<start>     Log_i ( "FW built time %s %s" ,  __DATE__ ,  __TIME__ )  ;  <end>
<start>     board_init (  )  ;  <end>
<start>     xTaskCreate ( qcloud_demo_task ,  "qcloud_demo_task" ,  8196 ,  NULL ,  4 ,  NULL )  ;  <end>
<start> } <end>
<start>  <end>
<start> #include "cryptoauthlib.h" <end>
<start> #include "atcacert/atcacert_pem.h" <end>
<start> #include "host/atca_host.h" <end>
<start> #include "../../../assets/dependencies/common/common.h" <end>
<start> #include <stdio.h> <end>
<start> #include <stdlib.h> <end>
<start> #include <string.h> <end>
<start> #include "../../00_resource_generation/public_key_rotation.h" <end>
<start> #if defined ( __XC32__ )  <end>
<start> #include "definitions.h" <end>
<start> #endif <end>
<start>  <end>
<start> #if defined ( ATMEL_START )  <end>
<start> #include <atmel_start.h> <end>
<start> #endif <end>
<start>  <end>
<start> #if defined ( __XC32__ )  <end>
<start> #define TOGGLE_STATUS_LED GPIO_PA02_Toggle (  )  <end>
<start> #endif <end>
<start> #if defined ( ATMEL_START )  <end>
<start> #define TOGGLE_STATUS_LED gpio_toggle_pin_level ( GPIO ( GPIO_PORTA ,  2 )  )  ;  <end>
<start> #endif <end>
<start>  <end>
<start> #if defined ( __XC32__ )  <end>
<start> extern ATCAIfaceCfg atecc608_0_init_data ;  <end>
<start> #endif <end>
<start>  <end>
<start> uint16_t rotating_key_slot = 14 ;  <end>
<start> uint16_t authority_key_slot = 13 ;  <end>
<start>  <end>
<start> ATCA_STATUS publickey_validate ( bool validate )  <end>
<start> { <end>
<start>     ATCA_STATUS status ;  <end>
<start>     uint8_t sn[9] ;  <end>
<start>     uint8_t public_key[64] ;  <end>
<start>     bool is_verified = false ;  <end>
<start>     uint8_t rand_out[ATCA_KEY_SIZE] ;  <end>
<start>     atca_temp_key_t temp_key ;  <end>
<start>     atca_nonce_in_out_t nonce_params ;  <end>
<start>     uint8_t gen_key_other_data[3] ;  <end>
<start>     atca_gen_key_in_out_t gen_key_params ;  <end>
<start>     uint8_t verify_other_data[19] ;  <end>
<start>     uint8_t validation_msg[55] ;  <end>
<start>     uint8_t validation_digest[32] ;  <end>
<start>     atca_sign_internal_in_out_t sign_params ;  <end>
<start>     uint8_t nonce[32] , config[128] ;  <end>
<start>  <end>
<start>     do <end>
<start>     { <end>
<start>          <end>
<start>         if  (  ( status = atcab_read_serial_number ( sn )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>          <end>
<start>         if  (  ( status = atcab_read_config_zone ( config )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start> if  ( validate )  <end>
<start>             memcpy ( nonce ,  validated_nonce ,  32 )  ;  <end>
<start>         else <end>
<start>             memcpy ( nonce ,  invalidated_nonce ,  32 )  ;  <end>
<start>  <end>
<start>          <end>
<start>         memset ( &temp_key ,  0 ,  sizeof ( temp_key )  )  ;  <end>
<start>         memset ( &nonce_params ,  0 ,  sizeof ( nonce_params )  )  ;  <end>
<start>         nonce_params.mode = NONCE_MODE_PASSTHROUGH ;  <end>
<start>         nonce_params.zero = 0 ;  <end>
<start>         nonce_params.num_in = nonce ;  <end>
<start>         nonce_params.rand_out = rand_out ;  <end>
<start>         nonce_params.temp_key = &temp_key ;  <end>
<start>         if  (  ( status = atcab_nonce ( nonce_params.num_in )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         if  (  ( status = atcah_nonce ( &nonce_params )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>          <end>
<start>          <end>
<start>          <end>
<start>         if  (  ( status = atcab_read_pubkey ( rotating_key_slot ,  public_key )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         memset ( gen_key_other_data ,  0 ,  sizeof ( gen_key_other_data )  )  ;  <end>
<start>         gen_key_params.mode = GENKEY_MODE_PUBKEY_DIGEST ;  <end>
<start>         gen_key_params.key_id = rotating_key_slot ;  <end>
<start>         gen_key_params.public_key = public_key ;  <end>
<start>         gen_key_params.public_key_size = sizeof ( public_key )  ;  <end>
<start>         gen_key_params.other_data = gen_key_other_data ;  <end>
<start>         gen_key_params.sn = sn ;  <end>
<start>         gen_key_params.temp_key = &temp_key ;  <end>
<start>         if  (  ( status = atcah_gen_key_msg ( &gen_key_params )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         memset ( &sign_params ,  0 ,  sizeof ( sign_params )  )  ;  <end>
<start>         sign_params.sn = sn ;  <end>
<start>         sign_params.verify_other_data = verify_other_data ;  <end>
<start>         sign_params.key_id = authority_key_slot ;  <end>
<start>         sign_params.slot_config =  ( config[20 + rotating_key_slot * 2]   | config[21 + rotating_key_slot * 2] << 8 )  ;  <end>
<start>         sign_params.key_config =  ( config[96 + rotating_key_slot * 2] | config[97 + rotating_key_slot * 2] << 8 )  ;  <end>
<start>         sign_params.for_invalidate = !validate ;  <end>
<start>         sign_params.message = validation_msg ;  <end>
<start>         sign_params.digest = validation_digest ;  <end>
<start>         sign_params.temp_key = &temp_key ;  <end>
<start>         if  (  ( status = atcah_sign_internal_msg ( ATECC608A ,  &sign_params )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>          <end>
<start>         if  (  ( status = atcab_genkey_base ( gen_key_params.mode ,  gen_key_params.key_id ,  gen_key_params.other_data ,  NULL )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>          <end>
<start>         if  ( validate )  <end>
<start>         { <end>
<start>              <end>
<start>             if  (  ( status = atcab_verify_validate ( rotating_key_slot ,  validated_signature ,  verify_other_data ,  &is_verified )  )  != ATCA_SUCCESS )  <end>
<start>                 break ;  <end>
<start>         } <end>
<start>         else <end>
<start>         { <end>
<start>             if  (  ( status = atcab_verify_invalidate ( rotating_key_slot ,  invalidated_signature ,  verify_other_data ,  &is_verified )  )  != ATCA_SUCCESS )  <end>
<start>                 break ;  <end>
<start>         } <end>
<start>  <end>
<start>         if  ( is_verified == true )  <end>
<start>             status = ATCA_SUCCESS ;  <end>
<start>         else <end>
<start>             status = !ATCA_SUCCESS ;  <end>
<start>  <end>
<start>     } while  ( 0 )  ;  <end>
<start>  <end>
<start>     return status ;  <end>
<start>  <end>
<start> } <end>
<start>  <end>
<start>  <end>
<start> static ATCA_STATUS public_key_rotation ( ATCAIfaceCfg *cfg )  <end>
<start> { <end>
<start>     ATCA_STATUS status ;  <end>
<start>     uint8_t valid_buf[4] ;  <end>
<start>     bool is_verified = false ;  <end>
<start>     char displaystr[400] ;  <end>
<start>     size_t displaylen ;  <end>
<start>  <end>
<start>     do <end>
<start>     { <end>
<start>          <end>
<start>         if  (  ( status = atcab_init ( cfg )  )  != ATCA_SUCCESS )  <end>
<start>         { <end>
<start>             printf ( "atcab_init (  )  failed with ret=0x%08X\r\n" ,  status )  ;  <end>
<start>             break ;  <end>
<start>         } <end>
<start>  <end>
<start>          <end>
<start>          <end>
<start>          <end>
<start>          <end>
<start>         if  (  ( status = atcab_read_zone ( ATCA_ZONE_DATA ,  rotating_key_slot ,  0 ,  0 ,  valid_buf ,  4 )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>          <end>
<start>         if  ( valid_buf[0] >> 4 == 0x05 )  <end>
<start>         { <end>
<start>             if  (  ( status = publickey_validate ( false )  )  != ATCA_SUCCESS )  <end>
<start>                 break ;  <end>
<start>             printf ( "\nValidated public key is already in slot ,  invalidated the slot to update the new public key\r\n" )  ;  <end>
<start>  <end>
<start>         } <end>
<start>  <end>
<start>          <end>
<start>         if  (  ( status = atcab_write_pubkey ( rotating_key_slot ,  public_key )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         displaylen = sizeof ( displaystr )  ;  <end>
<start>         atcab_bin2hex ( public_key ,  ATCA_PUB_KEY_SIZE ,  displaystr ,  &displaylen )  ;  <end>
<start>         printf ( "\nNew Rotating Public key written to device:\r\n\r\n%s\r\n" ,  displaystr )  ;  <end>
<start>  <end>
<start>          <end>
<start>         if  (  ( status = publickey_validate ( true )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         printf ( "\nValidated the Rotating Public key in device\r\n" )  ;  <end>
<start>          <end>
<start>          <end>
<start>         if  (  ( status = atcab_verify_stored ( rotating_digest ,  rotating_signature ,  rotating_key_slot ,  &is_verified )  )  != ATCA_SUCCESS )  <end>
<start>             break ;  <end>
<start>  <end>
<start>         if  ( is_verified == true )  <end>
<start>         { <end>
<start>             status = ATCA_SUCCESS ;  <end>
<start>             printf ( "\nVerified the Rotating Public key in device is usable for verify operations \r\n" )  ;  <end>
<start>         } <end>
<start>         else{ <end>
<start>             status = !ATCA_SUCCESS ;  <end>
<start>             printf ( "\nRotating Public key verification failed\r\n" )  ;  <end>
<start>  <end>
<start>         } <end>
<start>  <end>
<start>     } while  ( 0 )  ;  <end>
<start>  <end>
<start>     return status ;  <end>
<start> } <end>
<start>  <end>
<start> int main ( void )  <end>
<start> { <end>
<start>     ATCAIfaceCfg *cfg ;  <end>
<start>     ATCA_STATUS status ;  <end>
<start>     uint16_t delay_ms ;  <end>
<start>  <end>
<start>     <end>
<start> #if defined ( __XC32__ )  <end>
<start>     cfg = &atecc608_0_init_data ;  <end>
<start>      <end>
<start>     SYS_Initialize  (  NULL  )  ;  <end>
<start> #endif <end>
<start> #if defined ( ATMEL_START )  <end>
<start>      <end>
<start>     atmel_start_init (  )  ;  <end>
<start>     gpio_set_pin_direction ( GPIO ( GPIO_PORTA ,  2 )  , GPIO_DIRECTION_OUT )  ;  <end>
<start>     cfg->atcai2c.bus=2 ;  <end>
<start> #endif <end>
<start>  <end>
<start>      <end>
<start>     if  ( ATCA_SUCCESS !=  ( status = check_device_type_in_cfg ( cfg ,  false )  )  )  <end>
<start>         printf ( "check_device_type_in_cfg (  )  failed with ret=0x%08X\r\n" ,  status )  ;  <end>
<start>     else <end>
<start>         status = public_key_rotation ( cfg )  ;  <end>
<start>  <end>
<start>     printf ( "\r\nExecution completed with status %02X\r\n" ,  status )  ;  <end>
<start>     delay_ms = status == ATCA_SUCCESS ? 500 : 50 ;  <end>
<start>  <end>
<start>     while ( 1 )  <end>
<start>     { <end>
<start>         TOGGLE_STATUS_LED ;  <end>
<start>         atca_delay_ms ( delay_ms )  ;  <end>
<start>     } <end>
<start> } <end>
