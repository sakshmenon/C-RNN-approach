

#include <Compiler.h>
#include <TimeDelay.h>
#include "HardwareProfile.h"
#include "Peripherals/Nand.h"
#include "Peripherals/Accel.h"
#ifdef USE_GYRO
#include "Peripherals/Gyro.h"
#endif
#include "Peripherals/Rtc.h"
#include "USB/USB.h"
#include "USB/usb_function_msd.h"
#include "USB/usb_function_cdc.h"
#include "MDD File System/FSIO.h"
#include "Usb/USB_CDC_MSD.h"
#include "Ftl/FsFtl.h"
#include "Utils/FsUtils.h"
#include "Utils/Fifo.h"
#include "Utils/Util.h"
#include "Peripherals/Analog.h"
#include "Settings.h"
#include "Logger.h"

#include "AX3 SelfTest.h"


void RunAttached(void);
void RunLogging(void);
void TimedTasks(void);
void LedTasks(void);
void RunTestSequence(void);

void __attribute__((interrupt,auto_psv)) _DefaultInterrupt(void)
{
 static unsigned int INTCON1val;
LED_SET(LED_MAGENTA);
INTCON1val = INTCON1;
Nop();
Nop();
Nop();
Nop();
INTCON1 = 0;
    Reset();
}

void __attribute__((interrupt,auto_psv)) _RTCCInterrupt(void)
{
    RtcSwwdtIncrement();    
    RtcTasks();
    
}

void __attribute__((interrupt,auto_psv)) _INT1Interrupt(void)
{
    LoggerAccelTasks();
}

void __attribute__((interrupt,auto_psv)) _INT2Interrupt(void)
{
    LoggerAccelTasks();
}

#ifdef USE_GYRO
void __attribute__((interrupt,auto_psv)) _INT3Interrupt(void)
{
    LoggerGyroTasks();
}

void __attribute__((interrupt,auto_psv)) _INT4Interrupt(void)
{
    LoggerGyroTasks();
}
#endif

void __attribute__((interrupt, shadow, auto_psv)) _T1Interrupt(void)
{
    if (RtcTimerTasks())
    {
        ; 
    }
}

void __attribute__((interrupt, shadow, auto_psv)) _CNInterrupt(void)
{
IFS1bits.CNIF = 0;
}

#include <p24FJ256GB106.h>


static unsigned char restart = 0;
static unsigned char inactive = 0;
static unsigned short lastTime = 0;



#if 0
#include "Utils/Util.h"
extern write_handler_t writeHandler;

static void UsbWrite(const void *buffer, unsigned int len)
{
if (usb_write_length(buffer, len) < len)
{
LED_SET(LED_OFF); DelayMs(50); 
LED_SET(LED_RED); DelayMs(50); 
LED_SET(LED_YELLOW); DelayMs(50); 
LED_SET(LED_OFF);
}
}
#endif


int main(void)
{
    
InitIO();
CLOCK_SOSCEN(); 
WaitForPrecharge();

    LED_SET(LED_BLUE);  
CLOCK_INTOSC();     
    
    RtcSwwdtReset();
    RtcStartup();
    RtcInterruptOn(0);  
    LED_SET(LED_BLUE);  
    
AdcInit();
    AdcSampleWait();    

    
    NandInitialize();
    NandVerifyDeviceId();
    AccelVerifyDeviceId();
#ifdef USE_GYRO
    GyroVerifyDeviceId();
#endif


RunTestSequence();

    
    if (!nandPresent)
    {
        int i;
        for (i = 0; i < 5 * 3; i++) { LED_SET(LED_MAGENTA); DelayMs(111); LED_SET(LED_CYAN); DelayMs(111); LED_SET(LED_YELLOW); DelayMs(111); }
        #ifdef IGNORE_UNRECOGNIZED_PERIPHERALS
        if (!USB_BUS_SENSE)      
        #endif
    Reset();                
    }
    if (!accelPresent)
    {
        int i;
        for (i = 0; i < 5 * 3; i++) { LED_SET(LED_RED); DelayMs(111); LED_SET(LED_GREEN); DelayMs(111); LED_SET(LED_BLUE); DelayMs(111); }
        #ifdef IGNORE_UNRECOGNIZED_PERIPHERALS
        if (!USB_BUS_SENSE)      
        #endif
    Reset();                
    }

    
    restart = 0;
    inactive = 0;
    SettingsInitialize();               

LED_SET(LED_WHITE);         
    FtlStartup();                       
if(FSInit()!=TRUE)                          
{
int i;
for (i = 0; i < 5 * 3; i++) { LED_SET(LED_RED); DelayMs(111); LED_SET(LED_GREEN); DelayMs(111); }
}
    SettingsReadFile(SETTINGS_FILE);    
    
    LoggerReadMetadata(DEFAULT_FILE);   

    
    if (USB_BUS_SENSE)
    {
        RunAttached();      
    }
    else
    {
        RunLogging();       
    }

Reset();                
return 0;
}


void RunAttached(void)
{
    
    LoggerClear();

    
    AccelStartup(settings.sampleRate);
    
#ifdef USE_GYRO
    GyroStartup();
    
#endif

#if 1
FtlFlush(0);    
#endif
    CLOCK_PLL();
    DelayMs(2); 

    fsftlUsbDiskMounted = status.diskMounted;
#if 1
FSInit();       
#endif
    MDD_MediaInitialize();  

    USBInitializeSystem(); 
    #ifdef USB_INTERRUPT
    USBDeviceAttach();
    #endif

    while (USB_BUS_SENSE && restart != 1)
    {
        fsftlUsbDiskMounted = status.diskMounted;

        
        #ifndef USB_INTERRUPT
        USBDeviceTasks(); 
        #endif
        USBProcessIO();
        if ((USBGetDeviceState() >= CONFIGURED_STATE) && (USBIsDeviceSuspended() == FALSE))
        {
            const char *line = _user_gets();
            status.attached = 1;
            if (line != NULL)
            {
                status.stream = 0;                  
                SettingsCommand(line, SETTINGS_USB);
            }

            
            if (status.stream)
            {
                #define STREAM_RATE 100
                #define STREAM_INTERVAL (0x10000UL / STREAM_RATE)
                static unsigned long lastSampleTicks = 0;
                unsigned long now = RtcTicks();
                if (lastSampleTicks == 0) { lastSampleTicks = now; }
                if (now - lastSampleTicks > STREAM_INTERVAL)
                {
                    accel_t accelSample;
                    lastSampleTicks += STREAM_INTERVAL;
                    if (now - lastSampleTicks > 2 * STREAM_INTERVAL) { lastSampleTicks = now; } 

                    AccelSingleSample(&accelSample);
#ifdef USE_GYRO
                    if (gyroPresent)
                    {
                        gyro_t gyroSample;
                        GyroSingleSample(&gyroSample);
                        printf("%d,%d,%d,%d,%d,%d\r\n", accelSample.x, accelSample.y, accelSample.z, gyroSample.x, gyroSample.y, gyroSample.z);
                    }
                    else
#endif
                    {
                        printf("%d,%d,%d\r\n", accelSample.x, accelSample.y, accelSample.z);
                    }
                    USBCDCWait();
                }

            }
        }
        else
        {
            status.attached = -1;
        }
        LedTasks();
        TimedTasks();


        
        #ifdef FSFTL_READ_PREFETCH
FsFtlPrefetch();
        #endif
    }
#if defined(USB_INTERRUPT)
    USBDeviceDetach();
#endif
    status.attached = -1;

    
    FtlShutdown();
    return;
}


void TimedTasks(void)
{
    
    if (lastTime != rtcTicksSeconds)
    {
        lastTime = rtcTicksSeconds;

        
        inactive = FtlIncrementInactivity();
        AdcSampleNow();
        if (adcResult.batt > BATT_CHARGE_FULL_USB && status.batteryFull < BATT_FULL_INTERVAL)
        {
            status.batteryFull++;
            if (status.batteryFull >= BATT_FULL_INTERVAL)
            {
                if (status.initialBattery != 0 && status.initialBattery < BATT_CHARGE_MID_USB)
                {
                    
                    SettingsIncrementLogValue(LOG_VALUE_BATTERY);
                }
            }
        }

        if (inactive > 3)
        {
            FtlFlush(1);
        }

        if (status.actionCountdown > 0)
        {
            status.actionCountdown--;
            if (status.actionCountdown == 0)
            {
                if (SettingsAction(status.actionFlags))
                {
                    restart = 1;
                }
            }
        }

        
        RtcSwwdtReset();
    }
    return;
}


void LedTasks(void)
{
    static unsigned int LEDTimer;
    static BOOL LEDtoggle;

    if (++LEDTimer == 0) { LEDtoggle = !LEDtoggle; }

    if (status.attached > 0)
    {
        if (status.actionCountdown)
        {
            if (((unsigned char)(LEDTimer)) < ((LEDTimer) >> 8)) { LED_SET(LEDtoggle ? LED_RED : LED_OFF); } else { LED_SET(LEDtoggle ? LED_RED : LED_OFF); }
        }
        else if (status.ledOverride >= 0)
        {
            LED_SET(status.ledOverride);
        }
        else
        {
            char c0, c1;

            if (inactive == 0)
            {
                if (status.batteryFull >= BATT_FULL_INTERVAL) { c0 = LED_OFF; c1 = LED_WHITE; }       
                else                    { c0 = LED_OFF; c1 = LED_YELLOW; }      
            }
            else
            {
                if (status.batteryFull >= BATT_FULL_INTERVAL) { c0 = LED_RED; c1 = LED_WHITE; }       
                else                    { c0 = LED_RED; c1 = LED_YELLOW; }      
            }
            if (((unsigned char)(LEDTimer)) < ((LEDTimer) >> 8)) { LED_SET(LEDtoggle ? c1 : c0); } else { LED_SET(LEDtoggle ? c0 : c1); }
        }
    }
    else
    {
        if (status.batteryFull) { LED_SET(LED_GREEN); }       
        else                    { LED_SET(LED_YELLOW); }      
    }
    return;
}


typedef enum
{ 
STOP_NONE                   = 0,    
STOP_INTERVAL               = 1,    
STOP_SAMPLE_LIMIT           = 2,    
STOP_DISK_FULL              = 2,    
NOT_STARTED_NO_INTERVAL     = 3,    
NOT_STARTED_AFTER_INTERVAL  = 4,    
NOT_STARTED_SAMPLE_LIMIT    = 5,    
NOT_STARTED_DISK_FULL       = 5,    
NOT_STARTED_WAIT_USB        = 6,    
STOP_USB                    = 7,    
NOT_STARTED_INITIAL_BATTERY = 8,    
NOT_STARTED_WAIT_BATTERY    = 9,    
STOP_BATTERY                = 10,   
NOT_STARTED_FILE_OPEN       = 11,   
STOP_LOGGING_WRITE_ERR      = 12,   
STOP_LOGGING_SAMPLE_ERR     = 13,   
} StopCondition;

const char *stopConditionString[] =
{
STOP_NONE,                   
STOP_INTERVAL,               
STOP_SAMPLE_LIMIT,           
NOT_STARTED_NO_INTERVAL,     
NOT_STARTED_AFTER_INTERVAL,  
NOT_STARTED_SAMPLE_LIMIT,    
NOT_STARTED_WAIT_USB,        
STOP_USB,                    
NOT_STARTED_INITIAL_BATTERY, 
NOT_STARTED_WAIT_BATTERY,    
STOP_BATTERY,                
NOT_STARTED_FILE_OPEN,       
STOP_LOGGING_WRITE_ERR,      
STOP_LOGGING_SAMPLE_ERR,     
};

const char stopFlashCode[] =
{
    0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45
};


void RunLogging(void)
{
    const char *filename = DEFAULT_FILE;
    StopCondition stopCondition = 0;

    AdcInit();
    AdcSampleWait();

    SettingsIncrementLogValue(LOG_VALUE_RESTART);   

    if (adcResult.batt < BATT_CHARGE_MIN_SAFE)
    {
        
        stopCondition = NOT_STARTED_INITIAL_BATTERY;
    }
    else if (settings.loggingStartTime >= settings.loggingEndTime)
    {
        
        stopCondition = NOT_STARTED_NO_INTERVAL;   
    }
    else if (settings.loggingEndTime > settings.loggingStartTime && RtcNow() >= settings.loggingEndTime)
    {
        
        stopCondition = NOT_STARTED_AFTER_INTERVAL;   
    }
    else
    {
        
        if (settings.loggingStartTime < settings.loggingEndTime && RtcNow() < settings.loggingStartTime)
        {
            
            status.debugFlashCount = 5;
            while (restart != 1 && !stopCondition)
            {
                unsigned int i;

                
                RtcSwwdtReset();

                
                for (i = 0; i < 5; i++)
                {
                    
                    if (USB_BUS_SENSE) { stopCondition = NOT_STARTED_WAIT_USB; restart = 1; break; }

                    if (settings.debuggingInfo >= 1 || status.debugFlashCount > 0) { LED_SET(LED_YELLOW); if (status.debugFlashCount > 0) status.debugFlashCount--; Delay10us(5); }
                    LED_SET(LED_OFF);

                    SystemPwrSave(WAKE_ON_WDT|WAKE_ON_USB|DONT_RESTORE_PERIPHERALS|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE);
                }
                if (stopCondition) { break; }

                
                AdcInit();
                AdcSampleNow();

                
                if (adcResult.batt < BATT_CHARGE_MIN_SAFE) { stopCondition = NOT_STARTED_WAIT_BATTERY; break; }

                
                if (RtcNow() >= settings.loggingStartTime) { break; }
            }
            LED_SET(LED_OFF);
        }

        
        if (restart != 1 && !stopCondition)
        {
            if (FSDiskFree() == 0)
            {
            stopCondition = NOT_STARTED_DISK_FULL;
            }
            else if (!LoggerStart(filename))
            {
            stopCondition = NOT_STARTED_FILE_OPEN;
            }
            else
            {
                
                if (settings.maximumSamples != 0 && status.sampleCount >= settings.maximumSamples)
                { 
                stopCondition = NOT_STARTED_SAMPLE_LIMIT; 
                }
                else
                {
                    int failCounter = 0;

#ifdef HIGH_SPEED_USES_PLL
#warning "HIGH_SPEED_USES_PLL not fully tested."
char isHighSpeed = 0;
if (ACCEL_FREQUENCY_FOR_RATE(settings.sampleRate) >= 1600) { isHighSpeed = 1; }
if (isHighSpeed) { CLOCK_PLL();}
#endif

                
                LoggerClear();

                
                AccelStartup(settings.sampleRate);
                AccelEnableInterrupts(ACCEL_INT_SOURCE_WATERMARK | ACCEL_INT_SOURCE_OVERRUN, 0x00);
#ifdef USE_GYRO
                    GyroStartupFifoInterrupts();
#endif

                
                while (restart != 1 && !stopCondition)
                {
                    unsigned short now;
                        short result;

                    
                    if (USB_BUS_SENSE) { stopCondition = STOP_USB; restart = 1; break; }

                    
                    now = RtcSeconds();

                    
                        result = LoggerWrite();
                    if (result)
                    {
                            
                            status.lastSampledTicks = now;

                            
                            if (result > 0)
                            {
                                status.lastWrittenTicks = now;

                                
                                RtcSwwdtReset();
                            }

                        
                        AdcInit(); AdcSampleNow(); 
                        if (adcResult.batt < BATT_CHARGE_MIN_SAFE)
                        {
                            
                            AdcInit(); AdcSampleNow();
                            if (adcResult.batt < BATT_CHARGE_MIN_SAFE) { stopCondition = STOP_BATTERY; break; }
                        }

                        
                        if (settings.maximumSamples != 0 && status.sampleCount >= settings.maximumSamples) { stopCondition = STOP_SAMPLE_LIMIT; break; }

                        
                        if (RtcNow() > settings.loggingEndTime) { stopCondition = STOP_INTERVAL; break; }
                    }

                    
                    if (status.lastSampledTicks == 0x0000) { status.lastSampledTicks = now; }
                    if (status.lastWrittenTicks == 0x0000) { status.lastWrittenTicks = now; }

                        if (now - status.lastSampledTicks > 15)
                        {
                            
                            failCounter++;
                            if (failCounter > 5)
                            {
                                stopCondition = STOP_LOGGING_SAMPLE_ERR;
                                restart = 1;
                                break;
                            }
                        }
                        else if (now - status.lastWrittenTicks > 30)
                        {
                            
                            failCounter++;
                            if (failCounter > 5)
                            {
                                
                                if (FSDiskFree() == 0)
                                {
                                stopCondition = STOP_DISK_FULL;
                                }
                                else
                                {
                                    stopCondition = STOP_LOGGING_WRITE_ERR;
                                    restart = 1;
                                }
                                break;
                            }
                        }
                        else { failCounter = 0; }

#ifdef HIGH_SPEED_USES_PLL
if (!isHighSpeed)
{
#endif

                    
#ifdef USE_GYRO
                    SystemPwrSave(WAKE_ON_RTC|WAKE_ON_WDT|WAKE_ON_USB|WAKE_ON_ADXL1|WAKE_ON_GYRO2|WAKE_ON_TIMER1|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE);
#else
                    SystemPwrSave(WAKE_ON_RTC|WAKE_ON_WDT|WAKE_ON_USB|WAKE_ON_ADXL1|WAKE_ON_TIMER1|ADC_POWER_DOWN|LOWER_PWR_SLOWER_WAKE|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE);
#endif
                    
                    
#ifdef HIGH_SPEED_USES_PLL
}
#endif
                    
                    
                }

#ifdef HIGH_SPEED_USES_PLL
if (isHighSpeed) { CLOCK_INTOSC();}
#endif

}

                LoggerStop();
            }
        }
    }

    
    LED_SET(LED_BLUE);

    
    AccelStandby();
#ifdef USE_GYRO
    GyroStandby();
#endif
    RtcInterruptOff();
    FtlShutdown();

    
    SettingsAddLogEntry(LOG_CATEGORY_STOP | (unsigned int)stopCondition, RtcNow(), stopConditionString[stopCondition]);

    
    LED_SET(LED_OFF);

    
    if (restart != 1)
    {
        unsigned char led, countReset, countdown;
        led = (stopFlashCode[stopCondition] >> 4);
        countReset = stopFlashCode[stopCondition] & 0x0f;
        countdown = countReset;
        if (settings.debuggingInfo == 0xff) { led = 0; }
        CLOCK_INTOSC(); 
        
        
        while (restart != 1)
        {
            if (USB_BUS_SENSE) { restart = 1; break; }

            
            RtcSwwdtReset();

            SystemPwrSave(WAKE_ON_WDT|LOWER_PWR_SLOWER_WAKE|WAKE_ON_USB|ADC_POWER_DOWN|ACCEL_POWER_DOWN|GYRO_POWER_DOWN|SAVE_INT_STATUS|ALLOW_VECTOR_ON_WAKE);
            

            if (led)
            {
                LED_SET(led);
                if (countdown > 0)
                {
                Delay10us(15);
                countdown--;
                }
                else
                {
                    Delay10us(3);
                    countdown = countReset;
                }
                LED_SET(LED_OFF);
            }
        }
    }

    return;
}/*
 * user_main.c
 *
 * Copyright 2015 DeviceHive
 *
 * Author: Nikolay Khabarov
 *
 * Description: DeviceHive firmware for ESP8266
 *
 */
#include "dhdebug.h"
#include "DH/uart.h"
#include "dhsender_queue.h"
#include "dhterminal.h"
#include "dhsettings.h"
#include "dhconnector.h"
#include "dhap.h"
#include "DH/gpio.h"
#include "webserver.h"
#include "irom.h"
#include "uploadable_page.h"
#include "dhzc_dnsd.h"
#include "dhzc_web.h"
#include "mdnsd.h"

#include <osapi.h>
#include <os_type.h>
#include <c_types.h>
#include <user_interface.h>
#include <gpio.h>
#include <ets_forward.h>

typedef struct {
unsigned int magic;
unsigned int resetCounter;
} RESET_COUNTER;
#define RESET_COUNTER_MAGIC 0x12345678
#define RESET_COUNTER_RTC_ADDRESS 64
#define RESET_NUM 3

LOCAL os_timer_t mResetTimer;
LOCAL unsigned int mSpecialMode = 0;

uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void) {
enum flash_size_map size_map = system_get_flash_size_map();
uint32 rf_cal_sec = 0;

switch (size_map) {
case FLASH_SIZE_4M_MAP_256_256:
rf_cal_sec = 128 - 8;
break;

case FLASH_SIZE_8M_MAP_512_512:
rf_cal_sec = 256 - 5;
break;

case FLASH_SIZE_16M_MAP_512_512:
case FLASH_SIZE_16M_MAP_1024_1024:
rf_cal_sec = 512 - 5;
break;

case FLASH_SIZE_32M_MAP_512_512:
case FLASH_SIZE_32M_MAP_1024_1024:
rf_cal_sec = 1024 - 5;
break;

default:
rf_cal_sec = 0;
break;
}

return rf_cal_sec;
}

//0 )) {

LOCAL void ICACHE_FLASH_ATTR reset_counter(void *arg) {
RESET_COUNTER counter;
counter.magic = RESET_COUNTER_MAGIC;
counter.resetCounter = 0;
system_rtc_mem_write(RESET_COUNTER_RTC_ADDRESS, &counter, sizeof(counter));
}

extern int rtc_mem_check(int f);

void user_rf_pre_init(void) {
RESET_COUNTER counter;
if(system_get_rst_info()->reason != REASON_EXT_SYS_RST) {
reset_counter(0);
} else {
system_rtc_mem_read(64, &counter, sizeof(counter));
if(counter.magic == RESET_COUNTER_MAGIC && counter.resetCounter <= RESET_NUM) {
counter.resetCounter++;
if(counter.resetCounter == RESET_NUM) {
reset_counter(0);
mSpecialMode = 1;
} else {
system_rtc_mem_write(RESET_COUNTER_RTC_ADDRESS, &counter, sizeof(counter));
os_timer_disarm(&mResetTimer);
os_timer_setfn(&mResetTimer, (os_timer_func_t *)reset_counter, NULL);
os_timer_arm(&mResetTimer, 1000, 0);
}
} else {
reset_counter(0);
}
}

system_restore();
rtc_mem_check(0);
}

void ICACHE_FLASH_ATTR system_init_done(void) {
if(dhsettings_get_wifi_mode() == WIFI_MODE_AP &&
dhsettings_get_devicehive_deviceid()[0] &&
mSpecialMode == 0) {
mdnsd_start(dhsettings_get_devicehive_deviceid(), dhap_get_ip_info()->ip.addr);
}
dhdebug("Initialization completed");
}

void user_init(void) {
int ever_saved;
gpio_output_set(0, 0, 0, DH_GPIO_SUITABLE_PINS);
dhsettings_init(&ever_saved);
if(ever_saved == 0) { 
uploadable_page_delete();
mSpecialMode = 1;
}
dhdebug("*****************************");
if(mSpecialMode) { 
dh_uart_leds(DH_UART_LEDS_ON);
dhdebug("Wi-Fi Zero Configuration Mode");
dhap_init(WIFI_CONFIGURATION_SSID, NULL);
dhzc_dnsd_init();
dhzc_web_init();
dhdebug("Zero configuration server is initialized");
} else {
if(dhsettings_get_wifi_mode() == WIFI_MODE_CLIENT) {
dhsender_queue_init();
dhconnector_init();
dh_gpio_init();
} else if(dhsettings_get_wifi_mode() == WIFI_MODE_AP) {
dhap_init(dhsettings_get_wifi_ssid(), dhsettings_get_wifi_password());
}
webserver_init();
}
system_init_done_cb(system_init_done);
dhterminal_init();
}/*
 * File      : i2c_core.c
 * This file is part of RT-Thread RTOS
 * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Change Logs:
 * Date           Author        Notes
 * 2012-04-25     weety         first version
 */

#include "hal/i2c/i2c.h"
#include "hal/i2c/i2c_bit_ops.h"
#include "hal/i2c/i2c_dev.h"
#include <firmament.h>

rt_err_t rt_i2c_bus_device_register(struct rt_i2c_bus* bus,
                                    const char* bus_name)
{
    rt_err_t res = RT_EOK;

    rt_mutex_init(&bus->lock, "i2c_bus_lock", RT_IPC_FLAG_FIFO);

    if (bus->timeout == 0)
        bus->timeout = RT_TICK_PER_SECOND;

    res = rt_i2c_bus_init(bus, bus_name);

    i2c_dbg("I2C bus [%s] registered\n", bus_name);

    return res;
}

rt_err_t rt_i2c_bus_attach_device(struct rt_i2c_device* device,
                                  const char* name,
                                  const char* bus_name,
                                  void* user_data)
{
    rt_err_t result;
    rt_device_t bus;

    
    bus = rt_device_find(bus_name);

    if (bus != RT_NULL && bus->type == RT_Device_Class_I2CBUS) {
        device->bus = (struct rt_i2c_bus*)bus;

        
        result = rt_i2c_device_init(device, name);
        if (result != RT_EOK)
            return result;

        device->parent.user_data = user_data;

        return RT_EOK;
    }

    
    return -RT_ERROR;
}

rt_size_t rt_i2c_transfer(struct rt_i2c_bus* bus,
                          rt_uint16_t addr,
                          struct rt_i2c_msg msgs[],
                          rt_uint32_t num)
{
    rt_size_t ret;

    if (bus->ops->master_xfer) {
#ifdef RT_I2C_DEBUG
        for (ret = 0; ret < num; ret++) {
            i2c_dbg("msgs[%d] %c, len=%d%s\n", ret, (msgs[ret].flags & RT_I2C_RD) ? 'R' : 'W', msgs[ret].len);
        }
#endif
        if (!(msgs[0].flags & RT_I2C_ADDR_10BIT)) {
            addr = addr << 1;
        }

        rt_mutex_take(&bus->lock, RT_WAITING_FOREVER);
        ret = bus->ops->master_xfer(bus, addr, msgs, num);
        rt_mutex_release(&bus->lock);

        return ret;
    } else {
        i2c_dbg("I2C bus operation not supported\n");

        return 0;
    }
}

rt_size_t rt_i2c_master_send(struct rt_i2c_bus* bus,
                             rt_uint16_t addr,
                             rt_uint16_t flags,
                             const rt_uint8_t* buf,
                             rt_uint32_t count)
{
    rt_size_t ret;
    struct rt_i2c_msg msg;
    RT_ASSERT(bus != RT_NULL);

    msg.flags = flags & RT_I2C_ADDR_10BIT;
    msg.len = count;
    msg.buf = (rt_uint8_t*)buf;

    ret = rt_i2c_transfer(bus, addr, &msg, 1);

    return ret == 1 ? count : 0;
}

rt_size_t rt_i2c_master_recv(struct rt_i2c_bus* bus,
                             rt_uint16_t addr,
                             rt_uint16_t flags,
                             rt_uint8_t* buf,
                             rt_uint32_t count)
{
    rt_size_t ret;
    struct rt_i2c_msg msg;
    RT_ASSERT(bus != RT_NULL);

    msg.flags = flags & RT_I2C_ADDR_10BIT;
    msg.flags |= RT_I2C_RD;
    msg.len = count;
    msg.buf = buf;

    ret = rt_i2c_transfer(bus, addr, &msg, 1);

    return ret == 1 ? count : 0;
}

rt_err_t i2c_read_reg(rt_device_t i2c_dev, uint8_t reg, uint8_t* buffer)
{
    rt_size_t ret;
    struct rt_i2c_msg msgs[2];
    struct rt_i2c_device* i2c_device = (struct rt_i2c_device*)i2c_dev;

    msgs[0].flags = RT_I2C_WR | i2c_device->flags;
    msgs[0].buf = &reg;
    msgs[0].len = 1;

    msgs[1].flags = RT_I2C_RD | i2c_device->flags;
    msgs[1].buf = buffer;
    msgs[1].len = 1;

    ret = rt_i2c_transfer(i2c_device->bus, i2c_device->slave_addr, msgs, 2);

    return ret == 2 ? RT_EOK : RT_ERROR;
}

rt_err_t i2c_write_reg(rt_device_t i2c_dev, uint8_t reg, uint8_t val)
{
    rt_size_t ret;
    rt_uint8_t buffer[2];
    struct rt_i2c_msg msgs;
    struct rt_i2c_device* i2c_device = (struct rt_i2c_device*)i2c_dev;

    buffer[0] = reg;
    buffer[1] = val;

    msgs.flags = RT_I2C_WR | i2c_device->flags;
    msgs.buf = buffer;
    msgs.len = 2;

    ret = rt_i2c_transfer(i2c_device->bus, i2c_device->slave_addr, &msgs, 1);

    return ret == 1 ? RT_EOK : RT_ERROR;
}

rt_err_t i2c_read_regs(rt_device_t i2c_dev, uint8_t reg, uint8_t* buffer, uint16_t count)
{
    rt_size_t ret;
    struct rt_i2c_msg msgs[2];
    struct rt_i2c_device* i2c_device = (struct rt_i2c_device*)i2c_dev;

    msgs[0].flags = RT_I2C_WR | i2c_device->flags;
    msgs[0].buf = &reg;
    msgs[0].len = 1;

    msgs[1].flags = RT_I2C_RD | i2c_device->flags;
    msgs[1].buf = buffer;
    msgs[1].len = count;

    ret = rt_i2c_transfer(i2c_device->bus, i2c_device->slave_addr, msgs, 2);

    return ret == 2 ? RT_EOK : RT_ERROR;
}

rt_err_t i2c_write_regs(rt_device_t i2c_dev, uint8_t reg, uint8_t* vals, uint16_t count)
{
    rt_size_t ret;
    struct rt_i2c_msg msgs[2];
    struct rt_i2c_device* i2c_device = (struct rt_i2c_device*)i2c_dev;

    msgs[0].flags = RT_I2C_WR | i2c_device->flags;
    msgs[0].buf = &reg;
    msgs[0].len = 1;

    msgs[1].flags = RT_I2C_WR | i2c_device->flags;
    msgs[1].buf = vals;
    msgs[1].len = count;

    ret = rt_i2c_transfer(i2c_device->bus, i2c_device->slave_addr, msgs, 2);

    return ret == 2 ? RT_EOK : RT_ERROR;
}/** \file xex.c
  *
  * \brief Implements XEX mode for encryption of a random-access block device.
  *
  * For details, see "Efficient Instantiations of Tweakable Blockciphers and
  * Refinements to Modes OCB and PMAC" (dated September 24, 2004) by Phillip
  * Rogaway, obtained from
  * http:
  * on 5-February-2012.
  * XEX mode combines the random-access ability of CTR mode with the
  * bit-flipping attack resistance of ECB mode.
  *
  * This uses AES (see aes.c) as the underlying block cipher. Using AES in XEX
  * mode, with ciphertext stealing and with independent keys is sometimes
  * called "XTS-AES". But as long as the length of a
  * wallet record (#WALLET_RECORD_LENGTH) is a multiple of 16 bytes,
  * ciphertext stealing is not necessary. Thus the use
  * of AES in XEX mode here is identical in operation to XTS-AES.
  * As in XTS-AES, independent "tweak" and "encryption" keys are used. This
  * means that the combined key is 256 bits in length. But since this 256 bit
  * key is composed of two 128 bit keys, the final cipher still only
  * has 128 bits of security.
  *
  * This file is licensed as described by the file LICENCE.
  */

#ifdef TEST_XEX
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "test_helpers.h"
#include "wallet.h"
#endif 

#include "common.h"
#include "aes.h"
#include "prandom.h"
#include "hwinterface.h"
#include "endian.h"

/** Primary encryption key. */
static uint8_t nv_storage_encrypt_key[16];
static uint8_t nv_storage_tweak_key[16];

static void doubleInGF(uint8_t *op1)
{
uint8_t i;
uint8_t last_bit;
uint8_t temp;

last_bit = 0;
for (i = 0; i < 16; i++)
{
temp = (uint8_t)(op1[i] & 0x80);
op1[i] = (uint8_t)(op1[i] << 1);
op1[i] |= last_bit;
last_bit = (uint8_t)(temp >> 7);
}
last_bit = (uint8_t)(-(int)last_bit);
op1[0] = (uint8_t)(op1[0] ^ (0x87 & last_bit));
}

static void xexEnDecrypt(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key, bool is_decrypt)
{
uint8_t expanded_key[EXPANDED_KEY_SIZE];
uint8_t delta[16];
uint8_t buffer[16];
uint8_t i;

aesExpandKey(expanded_key, tweak_key);
aesEncrypt(delta, n, expanded_key);
for (i = 0; i < seq; i++)
{
doubleInGF(delta);
}
memcpy(buffer, in, 16);
xor16Bytes(buffer, delta);
aesExpandKey(expanded_key, encrypt_key);
if (is_decrypt)
{
aesDecrypt(out, buffer, expanded_key);
}
else
{
aesEncrypt(out, buffer, expanded_key);
}
xor16Bytes(out, delta);
}

static void xexEncryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, false);
}

static void xexDecryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, true);
}

void xexEncrypt(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq)
{
xexEncryptInternal(out, in, n, seq, nv_storage_tweak_key, nv_storage_encrypt_key);
}

void xexDecrypt(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq)
{
xexDecryptInternal(out, in, n, seq, nv_storage_tweak_key, nv_storage_encrypt_key);
}

void setEncryptionKey(const uint8_t *in)
{
memcpy(nv_storage_encrypt_key, in, 16);
memcpy(nv_storage_tweak_key, &(in[16]), 16);
}

void getEncryptionKey(uint8_t *out)
{
memcpy(out, nv_storage_encrypt_key, 16);
memcpy(&(out[16]), nv_storage_tweak_key, 16);
}

bool isEncryptionKeyNonZero(void)
{
uint8_t r;
uint8_t i;

r = 0;
for (i = 0; i < 16; i++)
{
r |= nv_storage_encrypt_key[i];
r |= nv_storage_tweak_key[i];
}
if (r != 0)
{
return true;
}
else
{
return false;
}
}

void clearEncryptionKey(void)
{
memset(nv_storage_tweak_key, 0xff, 16);
memset(nv_storage_encrypt_key, 0xff, 16);
memset(nv_storage_tweak_key, 0, 16);
memset(nv_storage_encrypt_key, 0, 16);
}

NonVolatileReturn encryptedNonVolatileWrite(uint8_t *data, NVPartitions partition, uint32_t address, uint32_t length)
{
uint32_t block_start;
uint32_t block_end;
uint8_t block_offset;
uint8_t ciphertext[16];
uint8_t plaintext[16];
uint8_t n[16];
NonVolatileReturn r;

block_start = address & 0xfffffff0;
block_offset = (uint8_t)(address & 0x0000000f);
block_end = (address + length - 1) & 0xfffffff0;
if ((address + length) < address)
{
return NV_INVALID_ADDRESS;
}

memset(n, 0, 16);
for (; block_start <= block_end; block_start += 16)
{
r = nonVolatileRead(ciphertext, partition, block_start, 16);
if (r != NV_NO_ERROR)
{
return r;
}
writeU32LittleEndian(n, block_start);
xexDecrypt(plaintext, ciphertext, n, 1);
while (length && block_offset < 16)
{
plaintext[block_offset++] = *data++;
length--;
}
block_offset = 0;
xexEncrypt(ciphertext, plaintext, n, 1);
r = nonVolatileWrite(ciphertext, partition, block_start, 16);
if (r != NV_NO_ERROR)
{
return r;
}
}

return NV_NO_ERROR;
}

NonVolatileReturn encryptedNonVolatileRead(uint8_t *data, NVPartitions partition, uint32_t address, uint32_t length)
{
uint32_t block_start;
uint32_t block_end;
uint8_t block_offset;
uint8_t ciphertext[16];
uint8_t plaintext[16];
uint8_t n[16];
NonVolatileReturn r;

block_start = address & 0xfffffff0;
block_offset = (uint8_t)(address & 0x0000000f);
block_end = (address + length - 1) & 0xfffffff0;
if ((address + length) < address)
{
return NV_INVALID_ADDRESS;
}

memset(n, 0, 16);
for (; block_start <= block_end; block_start += 16)
{
r = nonVolatileRead(ciphertext, partition, block_start, 16);
if (r != NV_NO_ERROR)
{
return r;
}
writeU32LittleEndian(n, block_start);
xexDecrypt(plaintext, ciphertext, n, 1);
while (length && block_offset < 16)
{
*data++ = plaintext[block_offset++];
length--;
}
block_offset = 0;
}

return NV_NO_ERROR;
}

#ifdef TEST_XEX

static void scanTestVectors(char *filename, int is_data_unit_seq_number)
{
FILE *f;
int test_number;
unsigned int data_unit_length;
bool is_encrypt;
unsigned int i;
int j;
int value;
bool seen_count;
bool test_failed;
char buffer[100];
uint8_t tweak_key[16];
uint8_t encrypt_key[16];
uint8_t tweak_value[16];
uint8_t *plaintext;
uint8_t *ciphertext;
uint8_t *compare;

f = fopen(filename, "r");
if (f == NULL)
{
printf("Could not open %s, please get it \
(\"AES Known Answer Test (KAT) Vectors\") \
from http:
printf("There should be two versions: one with 128 bit hex strings as the tweak\n");
printf("value, and one with a \"data unit sequence number\" as the tweak value.\n");
printf("Rename the one with 128 bit hex string tweak values \"XTSGenAES128i.rsp\"\n");
printf("and rename the one with data unit sequence numbers \"XTSGenAES128d.rsp\".\n");
exit(1);
}

test_number = 1;
for (i = 0; i < 11; i++)
{
skipLine(f);
}
is_encrypt = true;
while (!feof(f))
{
skipWhiteSpace(f);
seen_count = false;
while (!seen_count)
{
fgets(buffer, 6, f);
skipLine(f);
skipWhiteSpace(f);
if (!strcmp(buffer, "[DECR"))
{
is_encrypt = false;
}
else if (!strcmp(buffer, "COUNT"))
{
seen_count = true;
}
else
{
printf("Expected \"COUNT\" or \"[DECR\"\n");
exit(1);
}
}

fgets(buffer, 15, f);
if (strcmp(buffer, "DataUnitLen = "))
{
printf("Parse error; expected \"DataUnitLen = \"\n");
exit(1);
}
fscanf(f, "%u", &data_unit_length);
if ((data_unit_length <= 0) || (data_unit_length > 10000000))
{
printf("Error: got absurd data unit length %u\n", data_unit_length);
exit(1);
}
skipWhiteSpace(f);

if ((data_unit_length & 0x7f) != 0)
{
for (i = 0; i < 6; i++)
{
skipLine(f);
}
}
else
{
data_unit_length >>= 3; 

fgets(buffer, 7, f);
if (strcmp(buffer, "Key = "))
{
printf("Parse error; expected \"Key = \"\n");
exit(1);
}
for (i = 0; i < 16; i++)
{
fscanf(f, "%02x", &value);
encrypt_key[i] = (uint8_t)value;
}
for (i = 0; i < 16; i++)
{
fscanf(f, "%02x", &value);
tweak_key[i] = (uint8_t)value;
}
skipWhiteSpace(f);

if (is_data_unit_seq_number)
{
int n;

fgets(buffer, 21, f);
if (strcmp(buffer, "DataUnitSeqNumber = "))
{
printf("Parse error; expected \"DataUnitSeqNumber = \"\n");
exit(1);
}
fscanf(f, "%d", &n);
memset(tweak_value, 0, 16);
tweak_value[0] = (uint8_t)n;
tweak_value[1] = (uint8_t)(n >> 8);
tweak_value[2] = (uint8_t)(n >> 16);
tweak_value[3] = (uint8_t)(n >> 24);
}
else
{
fgets(buffer, 5, f);
if (strcmp(buffer, "i = "))
{
printf("Parse error; expected \"i = \"\n");
exit(1);
}
for (i = 0; i < 16; i++)
{
fscanf(f, "%02x", &value);
tweak_value[i] = (uint8_t)value;
}
}
skipWhiteSpace(f);

plaintext = malloc(data_unit_length);
ciphertext = malloc(data_unit_length);
compare = malloc(data_unit_length);

for (j = 0; j < 2; j++)
{
if (((is_encrypt) && (j == 0))
|| ((!is_encrypt) && (j != 0)))
{
fgets(buffer, 6, f);
if (strcmp(buffer, "PT = "))
{
printf("Parse error; expected \"PT = \"\n");
exit(1);
}
for (i = 0; i < data_unit_length; i++)
{
fscanf(f, "%02x", &value);
plaintext[i] = (uint8_t)value;
}
}
else
{
fgets(buffer, 6, f);
if (strcmp(buffer, "CT = "))
{
printf("Parse error; expected \"CT = \"\n");
exit(1);
}
for (i = 0; i < data_unit_length; i++)
{
fscanf(f, "%02x", &value);
ciphertext[i] = (uint8_t)value;
}
}
skipWhiteSpace(f);
} 

test_failed = false;
if (is_encrypt)
{
for (i = 0; i < data_unit_length; i += 16)
{
xexEncryptInternal(&(compare[i]), &(plaintext[i]), tweak_value, (uint8_t)(i >> 4), tweak_key, encrypt_key);
if (memcmp(&(compare[i]), &(ciphertext[i]), 16))
{
test_failed = true;
break;
}
}
}
else
{
for (i = 0; i < data_unit_length; i += 16)
{
xexDecryptInternal(&(compare[i]), &(ciphertext[i]), tweak_value, (uint8_t)(i >> 4), tweak_key, encrypt_key);
if (memcmp(&(compare[i]), &(plaintext[i]), 16))
{
test_failed = true;
break;
}
}
}
if (!test_failed)
{
reportSuccess();
}
else
{
printf("Test %d failed\n", test_number);
printf("Key: ");
printBigEndian16(encrypt_key);
printBigEndian16(tweak_key);
printf("\nFirst 16 bytes of plaintext: ");
printBigEndian16(plaintext);
printf("\nFirst 16 bytes of ciphertext: ");
printBigEndian16(ciphertext);
printf("\n");
reportFailure();
}
test_number++;
free(plaintext);
free(ciphertext);
free(compare);
}
}
fclose(f);
}

#define MAX_ADDRESS 1024
/** Number of read/write tests to do. */
#define NUM_RW_TESTS 100000

int main(void)
{
uint8_t what_storage_should_be[MAX_ADDRESS];
uint8_t buffer[512];
uint8_t one_key[32];
unsigned int i;
unsigned int j;

initTests(__FILE__);

initWalletTest();
clearEncryptionKey();

scanTestVectors("XTSGenAES128i.rsp", 0);
scanTestVectors("XTSGenAES128d.rsp", 1);

for (i = 0; i < MAX_ADDRESS; i++)
{
what_storage_should_be[i] = (uint8_t)rand();
}
for (i = 0; i < MAX_ADDRESS; i += 128)
{
encryptedNonVolatileWrite(&(what_storage_should_be[i]), PARTITION_ACCOUNTS, i, 128);
}
for (i = 0; i < MAX_ADDRESS; i += 128)
{
encryptedNonVolatileRead(buffer, PARTITION_ACCOUNTS, i, 128);
if (memcmp(&(what_storage_should_be[i]), buffer, 128))
{
printf("Storage mismatch in encryptedNonVolatileRead()\n");
printf("Initial fill, address = 0x%08x, length = 128\n", i);
reportFailure();
}
else
{
reportSuccess();
}
}

for (i = 0; i < NUM_RW_TESTS; i++)
{
uint32_t address;
uint32_t length;

do
{
address = (uint32_t)(rand() & (MAX_ADDRESS - 1));
length = rand() % sizeof(buffer);
} while ((address + length) > MAX_ADDRESS);
if (rand() & 1)
{
for (j = 0; j < length; j++)
{
buffer[j] = (uint8_t)rand();
}
memcpy(&(what_storage_should_be[address]), buffer, length);
if (encryptedNonVolatileWrite(buffer, PARTITION_ACCOUNTS, address, length) != NV_NO_ERROR)
{
printf("encryptedNonVolatileWrite() failed\n");
printf("test number = %u, address = 0x%08x, length = %d\n", i, (int)address, (int)length);
reportFailure();
}
else
{
reportSuccess();
}
}
else
{
if (encryptedNonVolatileRead(buffer, PARTITION_ACCOUNTS, address, length) != NV_NO_ERROR)
{
printf("encryptedNonVolatileRead() failed\n");
printf("test number = %u, address = 0x%08x, length = %d\n", i, (int)address, (int)length);
reportFailure();
}
else
{
if (memcmp(&(what_storage_should_be[address]), buffer, length))
{
printf("Storage mismatch in encryptedNonVolatileRead()\n");
printf("test number = %u, address = 0x%08x, length = %d\n", i, (int)address, (int)length);
reportFailure();
}
else
{
reportSuccess();
}
}
}
}


memset(one_key, 0, 32);
one_key[16] = 1;
setEncryptionKey(one_key);
for (i = 0; i < MAX_ADDRESS; i += 128)
{
encryptedNonVolatileRead(buffer, PARTITION_ACCOUNTS, i, 128);
if (memcmp(&(what_storage_should_be[i]), buffer, 128))
{
reportSuccess();
}
else
{
printf("Storage match in encryptedNonVolatileRead() when using different tweak key\n");
printf("Final run, address = 0x%08x, length = 128\n", i);
reportFailure();
}
}

memset(one_key, 0, 32);
one_key[0] = 1;
setEncryptionKey(one_key);
for (i = 0; i < MAX_ADDRESS; i += 128)
{
encryptedNonVolatileRead(buffer, PARTITION_ACCOUNTS, i, 128);
if (memcmp(&(what_storage_should_be[i]), buffer, 128))
{
reportSuccess();
}
else
{
printf("Storage match in encryptedNonVolatileRead() when using different primary encryption key\n");
printf("Final run, address = 0x%08x, length = 128\n", i);
reportFailure();
}
}

clearEncryptionKey();
for (i = 0; i < MAX_ADDRESS; i += 128)
{
encryptedNonVolatileRead(buffer, PARTITION_ACCOUNTS, i, 128);
if (memcmp(&(what_storage_should_be[i]), buffer, 128))
{
printf("Storage mismatch in encryptedNonVolatileRead() when keys are okay\n");
printf("Final run, address = 0x%08x, length = 128\n", i);
reportFailure();
}
else
{
reportSuccess();
}
}

finishTests();
exit(0);
}

#endif // #ifdef TEST_XEX/*
 * Copyright (C) 2015-2018 Alibaba Group Holding Limited
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include "infra_httpc.h"
#include "infra_json_parser.h"
#include "infra_timer.h"
#include "infra_sha1.h"
#include "infra_report.h"
#include "http_debug.h"
#include "http_api.h"
#include "http_wrapper.h"



#ifdef INFRA_MEM_STATS
    #include "infra_mem_stats.h"
    #define HTTP_API_MALLOC(size)               LITE_malloc(size, MEM_MAGIC, "http.api")
    #define HTTP_API_FREE(ptr)                  LITE_free(ptr)
#else
    #define HTTP_API_MALLOC(size)               HAL_Malloc(size)
    #define HTTP_API_FREE(ptr)                  {HAL_Free((void *)ptr);ptr = NULL;}
#endif

#define HTTP_LITE_JSON_VALUE_OF(key, src)       LITE_json_value_of(key, src, 0x1234, "http.api")

#ifndef CONFIG_MID_HTTP_TIMEOUT
    #define CONFIG_MID_HTTP_TIMEOUT             (5 * 1000)
#endif

#ifndef CONFIG_HTTP_AUTH_TIMEOUT
    #define CONFIG_HTTP_AUTH_TIMEOUT            (5 * 1000)
#endif

#define IOTX_HTTP_SIGN_LENGTH       (41)
#define IOTX_HTTP_SIGN_SOURCE_LEN   (256)
#define IOTX_HTTP_AUTH_TOKEN_LEN    (192+1)
#define IOTX_HTTP_URL_LEN_MAX       (135)

#ifdef IOTX_HTTP_TIMESTAMP_OPTIONAL_ENABLE
#define IOTX_HTTP_SIGN_SRC_STR          "clientId%sdeviceName%sproductKey%stimestamp%s"
#define IOTX_HTTP_AUTH_DEVICENAME_STR   \
    "{" \
    "\"version\":\"%s\", \"clientId\":\"%s\"," \
    "\"signmethod\":\"%s\",\"sign\":\"%s\"," \
    "\"productKey\":\"%s\",\"deviceName\":\"%s\"," \
    "\"timestamp\":\"%s\"" \
    "}"
#else
#define IOTX_HTTP_SIGN_SRC_STR          "clientId%sdeviceName%sproductKey%s"
#define IOTX_HTTP_AUTH_DEVICENAME_STR   \
    "{" \
    "\"version\":\"%s\", \"clientId\":\"%s\"," \
    "\"signmethod\":\"%s\",\"sign\":\"%s\"," \
    "\"productKey\":\"%s\",\"deviceName\":\"%s\"" \
    "}"
#endif

#define IOTX_HTTP_AUTH_STR              "auth"
#define IOTX_HTTP_ONLINE_SERVER_URL     "https:
#define IOTX_HTTP_ONLINE_SERVER_PORT    443

#define IOTX_SHA_METHOD                 "hmacsha1"

#define IOTX_HTTP_HEADER_KEEPALIVE_STR  "Connection: Keep-Alive\r\n"
#define IOTX_HTTP_HEADER_PASSWORD_STR   "password:"
#define IOTX_HTTP_UPSTREAM_HEADER_STR   \
    IOTX_HTTP_HEADER_KEEPALIVE_STR \
    IOTX_HTTP_HEADER_PASSWORD_STR \
    "%s" \
    IOTX_HTTP_HEADER_END_STR
#define IOTX_HTTP_HEADER_END_STR "\r\n"

#define HTTP_AUTH_RESP_MAX_LEN      (256)

static iotx_http_t *iotx_http_context_bak = NULL;



static int iotx_calc_sign(const char *p_device_secret, const char *p_msg, char *sign)
{
    http_info("| method: %s", IOTX_SHA_METHOD);
    utils_hmac_sha1(p_msg, strlen(p_msg), sign, p_device_secret, strlen(p_device_secret));
    return SUCCESS_RETURN;
}

static int calc_snprintf_string_length(char *fmt, ...)
{
    va_list args;
    int     rc = 0;
    char *p = NULL;
    char *sval = NULL;

    if (NULL == fmt) {
        return -1;
    }

    va_start(args, fmt);

    for (p = fmt; *p; p++) {
        if (*p != '%') {
            rc++;
            continue;
        }
        switch (*++p) {
            case 's':
                for (sval = va_arg(args, char *); *sval; sval++) {
                    rc++;
                }
                break;
            default:
                rc++;
                break;
        }
    }

    va_end(args);

    return rc;
}

static int construct_full_http_authenticate_url(char *buf)
{
    LITE_snprintf(buf, IOTX_HTTP_URL_LEN_MAX,
                  "%s/%s", IOTX_HTTP_ONLINE_SERVER_URL, IOTX_HTTP_AUTH_STR);
    http_info("get_http_authenticate_url is %s", buf);
    return 0;
}

static int construct_full_http_upstream_url(char *buf, const char *topic_path)
{
    LITE_snprintf(buf, IOTX_HTTP_URL_LEN_MAX,
                  "%s%s", IOTX_HTTP_ONLINE_SERVER_URL, topic_path);
    http_info("construct_full_http_upstream_url is %s", buf);
    return 0;
}

static int http_report_func(void *handle, const char *topic_name, int req_ack, void *data, int len)
{
    iotx_http_message_param_t   msg_param;
    char                        request_buf[1024];
    char                        topic_path[100];

    if (handle == NULL || topic_name == NULL || data == NULL) {
        http_err("params err");
        return -1;
    }

    HAL_Snprintf(topic_path, sizeof(topic_path), "/topic%s", topic_name);

    memset(&msg_param, 0, sizeof(iotx_http_message_param_t));
    msg_param.request_payload = (char *)data;
    msg_param.response_payload = request_buf;
    msg_param.timeout_ms = CONFIG_MID_HTTP_TIMEOUT;
    msg_param.request_payload_len = len;
    msg_param.response_payload_len = 1024;
    msg_param.topic_path = topic_path;

    return IOT_HTTP_SendMessage(handle, &msg_param);
}

static void *verify_iotx_http_context(void *handle)
{
    iotx_http_t *iotx_http_context = (iotx_http_t *)handle;

    if (NULL == iotx_http_context ||
        NULL == iotx_http_context_bak ||
        iotx_http_context_bak != iotx_http_context) {
        http_err("iotx_http_context not valid pointer!");

        iotx_http_context =  NULL;
    }

    return iotx_http_context;
}

void *IOT_HTTP_Init(iotx_http_param_t *pInitParams)
{
    iotx_device_info_t *p_devinfo;
    iotx_http_t        *iotx_http_context;

    
    if (NULL != iotx_http_context_bak) {
        http_err("Init twice not allowed, please deinit first");
        return NULL;
    }

    if (NULL == pInitParams || NULL == pInitParams->device_info) {
        http_err("Invalid argument: pInitParams or device_info = NULL");
        return NULL;
    }

    p_devinfo = pInitParams->device_info;


    iotx_http_context = (iotx_http_t *)HTTP_API_MALLOC(sizeof(iotx_http_t));

    if (NULL == iotx_http_context) {
        http_err("Allocate memory for iotx_http_context failed");
        return NULL;
    }

    memset(iotx_http_context, 0x00, sizeof(iotx_http_t));

    iotx_http_context->keep_alive = pInitParams->keep_alive;
    iotx_http_context->timeout_ms = pInitParams->timeout_ms;
    iotx_http_context->p_auth_token = HTTP_API_MALLOC(IOTX_HTTP_AUTH_TOKEN_LEN);
    if (NULL == iotx_http_context->p_auth_token) {
        http_err("Allocate memory for auth token failed");
        goto err;
    }
    memset(iotx_http_context->p_auth_token, 0x00, IOTX_HTTP_AUTH_TOKEN_LEN);
    iotx_http_context->is_authed = 0;
    iotx_http_context->auth_token_len = IOTX_HTTP_AUTH_TOKEN_LEN;

    
    iotx_http_context->p_devinfo = (iotx_device_info_t *)HTTP_API_MALLOC(sizeof(iotx_device_info_t));
    if (NULL == iotx_http_context->p_devinfo) {
        http_err("Allocate memory for iotx_http_context->p_devinfo failed");
        goto err;
    }
    memset(iotx_http_context->p_devinfo, 0x00, sizeof(iotx_device_info_t));

    
    memset(iotx_http_context->p_devinfo, 0x00, sizeof(iotx_device_info_t));
    strncpy(iotx_http_context->p_devinfo->device_id,     p_devinfo->device_id,     strlen(p_devinfo->device_id));
    strncpy(iotx_http_context->p_devinfo->product_key,   p_devinfo->product_key,   strlen(p_devinfo->product_key));
    strncpy(iotx_http_context->p_devinfo->device_secret, p_devinfo->device_secret, strlen(p_devinfo->device_secret));
    strncpy(iotx_http_context->p_devinfo->device_name,   p_devinfo->device_name,   strlen(p_devinfo->device_name));

    iotx_http_context->httpc = HTTP_API_MALLOC(sizeof(httpclient_t));
    if (NULL == iotx_http_context->httpc) {
        http_err("Allocate memory for iotx_http_context->httpc failed");
        goto err;
    }
    memset(iotx_http_context->httpc, 0x00, sizeof(httpclient_t));

    iotx_http_context_bak = iotx_http_context;

    return iotx_http_context;
err:
    
    if (NULL != iotx_http_context) {
        if (NULL != iotx_http_context->p_devinfo) {
            HTTP_API_FREE(iotx_http_context->p_devinfo);
        }
        if (NULL != iotx_http_context->p_auth_token) {
            HTTP_API_FREE(iotx_http_context->p_auth_token);
        }

        iotx_http_context->auth_token_len = 0;
        HTTP_API_FREE(iotx_http_context);
    }
    return NULL;
}

void IOT_HTTP_DeInit(void **handle)
{
    iotx_http_t *iotx_http_context;
    if (NULL == handle) {
        http_err("handle is NULL pointer");
        return;
    }
    if (NULL == (iotx_http_context = verify_iotx_http_context(*handle))) {
        return;
    }

    if (NULL != iotx_http_context->p_devinfo) {
        HTTP_API_FREE(iotx_http_context->p_devinfo);
    }
    if (NULL != iotx_http_context->p_auth_token) {
        HTTP_API_FREE(iotx_http_context->p_auth_token);
    }
    if (NULL != iotx_http_context->httpc) {
        HTTP_API_FREE(iotx_http_context->httpc);
    }

    iotx_http_context->auth_token_len = 0;
    HTTP_API_FREE(iotx_http_context);
    iotx_http_context_bak = NULL;
}

int IOT_HTTP_DeviceNameAuth(void *handle)
{
    int                 ret = -1;
    int                 ret_code = 0;
    char               *pvalue = NULL;
    char               *response_message = NULL;
    char                sign[IOTX_HTTP_SIGN_LENGTH]   = {0};
    char                http_url[IOTX_HTTP_URL_LEN_MAX] = {0};
    char                timestamp[14] = {0};
    httpclient_t       *httpc;
    httpclient_data_t   httpc_data = {0};
    char               *req_payload = NULL;
    char               *rsp_payload = NULL;
    int                 len = 0;
    char                p_msg_unsign[IOTX_HTTP_SIGN_SOURCE_LEN] = {0};
    iotx_time_t         timer;
    iotx_http_t        *iotx_http_context;
    const char          *pub_key = NULL;
    
    
    
    
    
    
    
    
    
    
    

    if (NULL == (iotx_http_context = verify_iotx_http_context(handle))) {
        goto do_exit;
    }
    iotx_http_context->is_authed = 0;

    
    /*
    if(!utils_get_epoch_time_from_ntp(timestamp, sizeof(timestamp)))
    {
            http_info("http time response: \r\n\r\n%s", timestamp);
            goto do_exit;
    }
    */

    
    LITE_snprintf(p_msg_unsign, IOTX_HTTP_SIGN_SOURCE_LEN,
                  IOTX_HTTP_SIGN_SRC_STR,
                  iotx_http_context->p_devinfo->device_id,
                  iotx_http_context->p_devinfo->device_name,
                  iotx_http_context->p_devinfo->product_key
#ifdef IOTX_HTTP_TIMESTAMP_OPTIONAL_ENABLE
                  , timestamp
#endif
                 );

    iotx_calc_sign(iotx_http_context->p_devinfo->device_secret, p_msg_unsign, sign);

    
    len = calc_snprintf_string_length(IOTX_HTTP_AUTH_DEVICENAME_STR,
                                      "default",
                                      iotx_http_context->p_devinfo->device_id,
                                      IOTX_SHA_METHOD,
                                      sign,
                                      iotx_http_context->p_devinfo->product_key,
                                      iotx_http_context->p_devinfo->device_name,
                                      timestamp
                                     );

    if (len < 0) {
        goto do_exit;
    }

    req_payload = (char *)HTTP_API_MALLOC(len + 1);
    memset(req_payload, 0, len + 1);

    http_debug("allocate req_payload: len = %d", len);

    len = HAL_Snprintf(req_payload, len + 1,
                       IOTX_HTTP_AUTH_DEVICENAME_STR,
                       "default",
                       iotx_http_context->p_devinfo->device_id,
                       IOTX_SHA_METHOD,
                       sign,
                       iotx_http_context->p_devinfo->product_key,
                       iotx_http_context->p_devinfo->device_name,
                       timestamp
                      );
    http_debug("len = %d, req_payload: \r\n%s", len, req_payload);

    
    rsp_payload = (char *)HTTP_API_MALLOC(HTTP_AUTH_RESP_MAX_LEN);
    if (NULL == rsp_payload) {
        http_err("Allocate HTTP rsp_payload buf failed!");
        goto do_exit;
    }
    memset(rsp_payload, 0, HTTP_AUTH_RESP_MAX_LEN);

    
    construct_full_http_authenticate_url(http_url);

    
    httpc = (httpclient_t *)iotx_http_context->httpc;

    httpc_data.post_content_type = "application/json";
    httpc_data.post_buf = req_payload;
    httpc_data.post_buf_len = len;
    httpc_data.response_buf = rsp_payload;
    httpc_data.response_buf_len = HTTP_AUTH_RESP_MAX_LEN;

    httpc->header = "Connection: Keep-Alive\r\n";

    /*
    Test Code
    iotx_http_context->p_auth_token = "eyJ0eXBlIjoiSldUIiwiYWxnIjoiaG1hY3NoYTEifQ.eyJleHBpcmUiOjE1MDQ3ODE4MzQ5MDAsInRva2VuIjoiM2EyZTRmYzMyNjk5NDE0Y2E3MDFjNzIzNzI1YjIyNDgifQ.e87AFhkvNKiqF5xdgm1P47f9DwY";
    iotx_http_context->is_authed = 1;
    ret = 0;
    goto do_exit;
    Test Code
    */

    {
        extern const char *iotx_ca_crt;
        pub_key = iotx_ca_crt;
    }

    
    if (0 != iotx_post(httpc,
                       http_url,
                       IOTX_HTTP_ONLINE_SERVER_PORT,
                       pub_key,
                       &httpc_data)) {
        goto do_exit;
    }

    iotx_time_init(&timer);
    utils_time_countdown_ms(&timer, CONFIG_HTTP_AUTH_TIMEOUT);


    ret = httpclient_recv_response(httpc, iotx_time_left(&timer), &httpc_data);
    if (ret < 0) {
        http_err("httpclient_recv_response error, ret = %d", ret);
        httpclient_close(httpc);
        return ret;
    }
    if (0 == iotx_http_context->keep_alive) {
        http_info("http not keepalive");
        httpclient_close(httpc);
    }
    /*
    body:
    {
      "code": 0,
      "message": "success",
      "info": {
        "token": "eyJ0eXBlIjoiSldUIiwiYWxnIjoiaG1hY3NoYTEifQ.eyJleHBpcmUiOjE1MDI1MzE1MDc0NzcsInRva2VuIjoiODA0ZmFjYTBiZTE3NGUxNjliZjY0ODVlNWNiNDg3MTkifQ.OjMwu29F0CY2YR_6oOyiOLXz0c8"
      }
    }
    */
    http_info("http response: \r\n\r\n%s\r\n", httpc_data.response_buf);

    pvalue = HTTP_LITE_JSON_VALUE_OF("code", httpc_data.response_buf);
    if (!pvalue) {
        goto do_exit;
    }
    ret_code = atoi(pvalue);
    http_info("ret_code = %d", ret_code);
    HTTP_API_FREE(pvalue);
    pvalue = NULL;

    pvalue = HTTP_LITE_JSON_VALUE_OF("message", httpc_data.response_buf);
    if (NULL == pvalue) {
        goto do_exit;
    }
    response_message = pvalue;
    http_info("response_message: %s", response_message);
    (void)response_message;
    HTTP_API_FREE(pvalue);
    pvalue = NULL;

    switch (ret_code) {
        case IOTX_HTTP_SUCCESS:
            break;
        case IOTX_HTTP_COMMON_ERROR:
        case IOTX_HTTP_PARAM_ERROR:
        case IOTX_HTTP_AUTH_CHECK_ERROR:
        case IOTX_HTTP_UPDATE_SESSION_ERROR:
        case IOTX_HTTP_REQUEST_TOO_MANY_ERROR:
        default:
            ret = FAIL_RETURN;
            goto do_exit;
    }

    pvalue = HTTP_LITE_JSON_VALUE_OF("info.token", httpc_data.response_buf);
    if (NULL == pvalue) {
        http_err("can't get token from json, Abort!");
        goto do_exit;
    }

    if(strlen(pvalue) > IOTX_HTTP_AUTH_TOKEN_LEN - 1) {
        http_err("token is out of size");
        goto do_exit;
    }

    strcpy(iotx_http_context->p_auth_token, pvalue);
    iotx_http_context->is_authed = 1;
    HTTP_API_FREE(pvalue);
    pvalue = NULL;


    iotx_set_report_func(http_report_func);
    
    ret = iotx_report_mid(iotx_http_context);
    if (SUCCESS_RETURN != ret) {
        http_err("Send ModuleId message to server(Http) failed, ret = %d", ret);
        goto do_exit;
    }
    
    ret = iotx_report_devinfo(iotx_http_context);
    if (SUCCESS_RETURN != ret) {
        http_err("Send devinfo message to server(Http) failed, ret = %d", ret);
        goto do_exit;
    }
    
    ret = iotx_report_firmware_version(iotx_http_context);
    if (SUCCESS_RETURN != ret) {
        http_err("Send firmware message to server(Http) failed, ret = %d", ret);
        goto do_exit;
    }

    ret = 0;

do_exit:
    if (pvalue) {
        HTTP_API_FREE(pvalue);
        pvalue = NULL;
    }
    if (req_payload) {
        HTTP_API_FREE(req_payload);
        req_payload = NULL;
    }
    if (rsp_payload) {
        HTTP_API_FREE(rsp_payload);
        rsp_payload = NULL;
    }

    return ret;
}

int IOT_HTTP_SendMessage(void *handle, iotx_http_message_param_t *msg_param)
{
    int                 ret = -1;
    int                 response_code = 0;
    char               *pvalue = NULL;
    char                http_url[IOTX_HTTP_URL_LEN_MAX] = {0};
    httpclient_t       *httpc = NULL;
    httpclient_data_t   httpc_data = {0};
    char               *messageId = NULL;
    char               *user_data = NULL;
    int                 len = 0;
    uint32_t            payload_len = 0;
    iotx_time_t         timer;
    iotx_http_t        *iotx_http_context;
    const char         *pub_key = NULL;
    /*
        POST /topic/${topic} HTTP/1.1
        Host: iot-as-http.cn-shanghai.aliyuncs.com
        password:${token}
        Content-Type: application/octet-stream
        body: ${your_data}
    */
    if (NULL == (iotx_http_context = verify_iotx_http_context(handle))) {
        goto do_exit;
    }

    if (NULL == msg_param) {
        http_err("iotx_http_context or msg_param NULL pointer!");
        goto do_exit;
    }

    httpc = (httpclient_t *)iotx_http_context->httpc;

    if (NULL == httpc) {
        http_err("httpc null pointer");
        goto do_exit;
    }

    if (0 == iotx_http_context->is_authed) {
        http_err("Device is not authed");
        goto do_exit;
    }

    if (NULL == msg_param->request_payload) {
        http_err("IOT_HTTP_SendMessage request_payload NULL!");
        goto do_exit;
    }

    if (NULL == msg_param->response_payload) {
        http_err("IOT_HTTP_SendMessage response_payload NULL!");
        goto do_exit;
    }

    if (NULL == msg_param->topic_path) {
        http_err("IOT_HTTP_SendMessage topic_path NULL!");
        goto do_exit;
    }

    payload_len = strlen(msg_param->request_payload) + 1;
    msg_param->request_payload_len = msg_param->request_payload_len > payload_len \
                                     ? payload_len : msg_param->request_payload_len;

    
    construct_full_http_upstream_url(http_url, msg_param->topic_path);

    len = strlen(IOTX_HTTP_HEADER_PASSWORD_STR) + strlen(iotx_http_context->p_auth_token) + strlen(
                      IOTX_HTTP_HEADER_KEEPALIVE_STR) + strlen(IOTX_HTTP_HEADER_END_STR);
    httpc->header = HTTP_API_MALLOC(len + 1);
    if (NULL == httpc->header) {
        http_err("Allocate memory for httpc->header failed");
        goto do_exit;
    }
    LITE_snprintf(httpc->header, len + 1,
                  IOTX_HTTP_UPSTREAM_HEADER_STR, iotx_http_context->p_auth_token);
    http_info("httpc->header = %s", httpc->header);

    httpc_data.post_content_type = "application/octet-stream";
    httpc_data.post_buf = msg_param->request_payload;
    httpc_data.post_buf_len = msg_param->request_payload_len;
    httpc_data.response_buf = msg_param->response_payload;
    httpc_data.response_buf_len = msg_param->response_payload_len;

    http_info("request_payload: \r\n\r\n%s\r\n", httpc_data.post_buf);

    {
        extern const char *iotx_ca_crt;
        pub_key = iotx_ca_crt;
    }

    
    if (iotx_post(httpc,
                  http_url,
                  IOTX_HTTP_ONLINE_SERVER_PORT,
                  pub_key,
                  &httpc_data)) {
        goto do_exit_pre;
    }
    iotx_time_init(&timer);
    utils_time_countdown_ms(&timer, msg_param->timeout_ms);

    ret = httpclient_recv_response(httpc, iotx_time_left(&timer), &httpc_data);
    if (ret < 0) {
        http_err("httpclient_recv_response error, ret = %d", ret);
        httpclient_close(httpc);
        goto do_exit_pre;
    }

    if (0 == iotx_http_context->keep_alive) {
        httpclient_close(httpc);
    }

    /*
        body:
        {
          "code": 0,
          "message": "success",
          "info": {
            "messageId": 892687627916247040,
            "data": byte[]
          }
        }
    */
    http_info("http response: \r\n\r\n%s\r\n", httpc_data.response_buf);

    pvalue = HTTP_LITE_JSON_VALUE_OF("code", httpc_data.response_buf);
    if (!pvalue) {
        goto do_exit_pre;
    }

    response_code = atoi(pvalue);
    HTTP_API_FREE(pvalue);
    pvalue = NULL;
    http_info("response code: %d", response_code);

    pvalue = HTTP_LITE_JSON_VALUE_OF("message", httpc_data.response_buf);
    if (NULL == pvalue) {
        goto do_exit_pre;
    }
    http_info("response_message: %s", pvalue);
    HTTP_API_FREE(pvalue);
    pvalue = NULL;

    switch (response_code) {
        case IOTX_HTTP_SUCCESS:
            break;
        case IOTX_HTTP_TOKEN_EXPIRED_ERROR:
            iotx_http_context->is_authed = IOT_FALSE;
            IOT_HTTP_DeviceNameAuth((iotx_http_t *)iotx_http_context);
        case IOTX_HTTP_COMMON_ERROR:
        case IOTX_HTTP_PARAM_ERROR:
        case IOTX_HTTP_AUTH_CHECK_ERROR:
        case IOTX_HTTP_TOKEN_NULL_ERROR:
        case IOTX_HTTP_TOKEN_CHECK_ERROR:
        case IOTX_HTTP_UPDATE_SESSION_ERROR:
        case IOTX_HTTP_PUBLISH_MESSAGE_ERROR:
        case IOTX_HTTP_REQUEST_TOO_MANY_ERROR:
        default:
            goto do_exit_pre;
    }

    
    pvalue = HTTP_LITE_JSON_VALUE_OF("info.messageId", httpc_data.response_buf);
    if (NULL == pvalue) {
        http_err("messageId: NULL");
        goto do_exit_pre;
    }
    messageId = pvalue;
    http_info("messageId: %s", messageId);
    (void)messageId;
    HTTP_API_FREE(pvalue);
    pvalue = NULL;

    
    pvalue = HTTP_LITE_JSON_VALUE_OF("info.data", httpc_data.response_buf);
    user_data = pvalue;

    
    if (user_data) {
        http_info("user_data: %s", user_data);
    } else {
        http_info("user_data: %p", user_data);
    }
    if (NULL != pvalue) {
        HTTP_API_FREE(pvalue);
    }
    pvalue = NULL;

    ret = 0;

do_exit_pre:

    if (pvalue) {
        HTTP_API_FREE(pvalue);
    }

    if (httpc != NULL && httpc->header) {
        HTTP_API_FREE(httpc->header);
    }

do_exit:

    return ret;
}

void IOT_HTTP_Disconnect(void *handle)
{
    iotx_http_t *iotx_http_context;
    if (NULL != (iotx_http_context = verify_iotx_http_context(handle))) {
        httpclient_close(iotx_http_context->httpc);
    }
}
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <TFT_ILI9163C.h>
#include <Adafruit_Fingerprint.h>
#include <SoftwareSerial.h>

#define BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0  
#define WHITE   0xFFFF

#define __CS 10
#define __DC 9
static const uint8_t icon [] PROGMEM = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x3f,0xc0,0x0,0x0,0x0,
0x0,0x0,0x3,0xff,0xf8,0x0,0x0,0x0,
0x0,0x0,0x7,0xff,0xfe,0x0,0x0,0x0,
0x0,0x0,0x1f,0xc0,0x7f,0x80,0x0,0x0,
0x0,0x0,0x3e,0x0,0x7,0xc0,0x0,0x0,
0x0,0x0,0x7c,0x0,0x3,0xe0,0x0,0x0,
0x0,0x0,0xfd,0xff,0x81,0xf0,0x0,0x0,
0x0,0x0,0xff,0xff,0xe0,0xf0,0x0,0x0,
0x0,0x1,0xff,0xff,0xf8,0x78,0x0,0x0,
0x0,0x1,0xff,0x80,0x7c,0x38,0x0,0x0,
0x0,0x3,0xfc,0x0,0xe,0x3c,0x0,0x0,
0x0,0x3,0xf0,0x0,0x7,0x1c,0x0,0x0,
0x0,0x7,0xc0,0x7f,0x83,0x8e,0x0,0x0,
0x0,0x7,0x83,0xff,0xe0,0xe,0x0,0x0,
0x0,0x7,0xf,0xff,0xf8,0xf,0x0,0x0,
0x0,0x6,0x1f,0x80,0xfc,0x7,0x0,0x0,
0x0,0x4,0x7e,0x0,0x3f,0x7,0x0,0x0,
0x0,0x0,0xf8,0x0,0xf,0x7,0x0,0x0,
0x0,0x0,0xf0,0x3e,0x7,0x87,0x0,0x0,
0x0,0x1,0xe1,0xff,0x83,0x83,0x80,0x0,
0x0,0x3,0xc3,0xff,0xc3,0xc3,0x80,0x0,
0x0,0x3,0xc7,0xc3,0xe1,0xc3,0x80,0x0,
0x0,0x3,0x8f,0x0,0xf1,0xe3,0x80,0x0,
0x0,0x7,0x1e,0x0,0x78,0xe3,0x80,0x0,
0x0,0x7,0x1e,0x3c,0x38,0xe3,0x80,0x0,
0x0,0x7,0x1c,0x7e,0x38,0xe3,0x80,0x0,
0x0,0xf,0x1c,0x7f,0x38,0xe3,0x80,0x0,
0x0,0xe,0x3c,0xf7,0x38,0x71,0x80,0x0,
0x0,0xe,0x38,0xe7,0x38,0x71,0xc0,0x0,
0x0,0xe,0x38,0xe7,0x38,0x71,0xc0,0x0,
0x0,0xe,0x38,0xe7,0x38,0x73,0xc0,0x0,
0x0,0xe,0x38,0xe3,0x98,0xe3,0xc0,0x0,
0x0,0xe,0x38,0xe3,0xb8,0xe3,0x80,0x0,
0x0,0x0,0x38,0xe3,0xf8,0xe3,0x80,0x0,
0x0,0x0,0x38,0xe3,0xf8,0xe3,0x80,0x0,
0x0,0x0,0x3c,0xf1,0xf1,0xe3,0x80,0x0,
0x0,0x6,0x1c,0x70,0x1,0xc7,0x80,0x0,
0x0,0xe,0x1c,0x78,0x3,0xc7,0x80,0x0,
0x0,0xf,0x1c,0x3e,0x7,0x87,0x0,0x0,
0x0,0xf,0x1e,0x3f,0xff,0x8f,0x0,0x0,
0x0,0xf,0x1e,0x1f,0xff,0x1f,0x0,0x0,
0x0,0xf,0xf,0x7,0xfc,0x3e,0x0,0x0,
0x0,0x7,0x87,0x80,0x0,0x7c,0x0,0x0,
0x0,0x7,0x87,0xe0,0x0,0xfc,0x0,0x0,
0x0,0x3,0xc3,0xf8,0x7,0xf8,0x0,0x0,
0x0,0x3,0xe1,0xff,0xff,0xe1,0x0,0x0,
0x0,0x1,0xe0,0x7f,0xff,0x83,0x0,0x0,
0x0,0x1,0xf8,0xf,0xfe,0x7,0x0,0x0,
0x0,0x0,0xfc,0x0,0x0,0xe,0x0,0x0,
0x0,0x0,0x3f,0x0,0x0,0x3c,0x0,0x0,
0x0,0x0,0x1f,0xe0,0x1,0xf8,0x0,0x0,
0x0,0x0,0x7,0xff,0xff,0xf0,0x0,0x0,
0x0,0x0,0x1,0xff,0xff,0xc0,0x0,0x0,
0x0,0x0,0x0,0x1f,0xfc,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};


TFT_ILI9163C display = TFT_ILI9163C(__CS,8, __DC);
SoftwareSerial mySerial(2, 3);
Adafruit_Fingerprint finger = Adafruit_Fingerprint(&mySerial);
int fingerprintID = 0;

void setup(void) {

  startFingerprintSensor();
  display.begin();
  displayLockScreen(); 
}

void loop() {

  fingerprintID = getFingerprintID();
  delay(50);
  if(fingerprintID == 1)
  {
    display.drawBitmap(30,35,icon,60,60,GREEN);
    delay(2000);
    displayUnlockedScreen();
    displayIoanna();
    delay(5000);
    display.fillScreen(BLACK);
    displayLockScreen();
  }

   if(fingerprintID == 2)
  {
    display.drawBitmap(30,35,icon,60,60,GREEN);
    delay(2000);
    displayUnlockedScreen();
    displayNick();
    delay(5000);
    display.fillScreen(BLACK);
    displayLockScreen();
  }
}


void displayUnlockedScreen()
{
   display.fillScreen(BLACK);
   display.drawRect(0,0,128,128,WHITE);
   display.setCursor(18,10);
   display.setTextColor(GREEN); 
   display.setTextSize(2);
   display.print("UNLOCKED");

   display.setCursor(20,50);
   display.setTextColor(WHITE); 
   display.setTextSize(2);
   display.print("WELCOME");
}
void displayNick()
{
  display.setCursor(35,75);
  display.setTextColor(WHITE); 
  display.setTextSize(2);
  display.print("NICK!");
}

void displayIoanna()
{
  display.setCursor(25,75);
  display.setTextColor(WHITE); 
  display.setTextSize(2);
  display.print("IOANNA!");
}

void displayLockScreen()
{
  display.drawRect(0,0,128,128,WHITE);
  display.setCursor(30,10);
  display.setTextColor(RED); 
  display.setTextSize(2);
  display.print("LOCKED");

  display.setCursor(10,100);
  display.setTextColor(WHITE); 
  display.setTextSize(1);
  display.print("Waiting for valid \n    fingerprint.");

  display.drawBitmap(30,35,icon,60,60,WHITE);
}
void startFingerprintSensor()
{
  Serial.begin(9600);
  finger.begin(57600);
  
  if (finger.verifyPassword()) {
    Serial.println("Found fingerprint sensor!");
  } else {
    Serial.println("Did not find fingerprint sensor");
  }
  Serial.println("Waiting for valid finger...");
}

int getFingerprintID() {
  uint8_t p = finger.getImage();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.image2Tz();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.fingerFastSearch();
  if (p != FINGERPRINT_OK)  return -1;
  
  
  Serial.print("Found ID #"); Serial.print(finger.fingerID); 
  Serial.print(" with confidence of "); Serial.println(finger.confidence);
  return finger.fingerID; 
}
#include "MDB.h"
#include "USART.h"
#include <Arduino.h> 

VMC_Config_t vmc_config = {0, 0, 0, 0};
VMC_Prices_t vmc_prices = {0, 0};

 
uint16_t user_funds  = 0x0000;
uint16_t item_cost   = 0x0000;
uint16_t vend_amount = 0x0000;
uint8_t csh_error_code = 0;
uint16_t csh_poll_state = CSH_JUST_RESET;
uint8_t csh_state = CSH_S_INACTIVE;
CSH_Config_t csh_config = {
    0x01, 
    /*
     * Russia's country code is 810 or 643,
     * which translates into 0x18, 0x10
     *                    or 0x16, 0x43
     */  
    
    
    0x00,
    0x00,
    /*
     * The VMC I work with accepts only 2 decimal places,
     * which is reasonable, considering 1 RUB = 100 Kopecks.
     * But actually there are no kopecks
     * in any item prices, rubles only.
     * As a coin acceptor handles coins with minimum value of 1 RUB,
     * I chose scaling factor 0d100 (0x64),
     * which makes calculations easier to understand.
     * Example: Funds available   -- 1600.00 RUB
     *          Scale factor      -- 100
     *          Decimal places    -- 2
     * This makes internal funds value 1600, or 0x0640 in HEX
     * which divides into 0x06 and 0x40
     * for two uint8_t internal variables
     */
    0x64, 
    0x02, 
    FUNDS_TIMEOUT, 
    0b00001001  
};


void MDB_Init(void)
{
    USART_Init(9600);
}
void MDB_CommandHandler(void)
{
    uint16_t command = 0;
    
    
    do {
        MDB_Read(&command);
    } while ((command < VMC_RESET) || (command > VMC_EXPANSION));

    
    
    
    
    
    
    
    
    
    

    switch (command)
    {        
        case VMC_RESET     :  MDB_ResetHandler();     break;
        case VMC_SETUP     :  MDB_SetupHandler();     break;
        case VMC_POLL      :  MDB_PollHandler();      break;
        case VMC_VEND      :  MDB_VendHandler();      break;
        case VMC_READER    :  MDB_ReaderHandler();    break;
        case VMC_EXPANSION :  MDB_ExpansionHandler(); break;
        default : break;
    }
    switch (csh_state)
    {
        case CSH_S_INACTIVE :  break;
        case CSH_S_DISABLED :  break;
        case CSH_S_ENABLED  : PORTC = 0; PORTC |= (1 << 2); break;
        case CSH_S_SESSION_IDLE : PORTC = 0; PORTC |= (1 << 3); break;
        case CSH_S_VEND     : PORTC = 0; PORTC |= (1 << 4); break;
        default : break;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
                
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    
}
void MDB_ResetHandler(void)
{
    Reset();
}
void MDB_SetupHandler(void)
{
    uint8_t i; 
    uint8_t checksum = VMC_SETUP;
    uint16_t vmc_temp;
    uint8_t vmc_data[6];
    /*
     * wait for the whole frame
     * frame structure:
     * 1 subcommand + 4 vmc_config fields + 1 Checksum byte
     * 6 elements total
     */
    while (1)
        if (MDB_DataCount() > 5)
            break;
    
    for (i = 0; i < 6; ++i)
    {
        MDB_Read(&vmc_temp);
        vmc_data[i] = (uint8_t)(vmc_temp & 0x00FF); 
    }
    
    
    checksum += calc_checksum(vmc_data, 5);
    
    if (checksum != vmc_data[5])
    {
        MDB_Send(CSH_NAK);
        return; 
    }
    
    switch(vmc_data[0])
    {
        case VMC_CONFIG_DATA : {            
            
            vmc_config.featureLevel   = vmc_data[1];
            vmc_config.displayColumns = vmc_data[2];
            vmc_config.displayRows    = vmc_data[3];
            vmc_config.displayInfo    = vmc_data[4];
            ConfigInfo();
        }; break;

        case VMC_MAX_MIN_PRICES : {
            
            vmc_prices.maxPrice = ((uint16_t)vmc_data[1] << 8) | vmc_data[2];
            vmc_prices.minPrice = ((uint16_t)vmc_data[3] << 8) | vmc_data[4];
            
            MDB_Send(CSH_ACK);
            
            csh_state = CSH_S_DISABLED;
        }; break;

        default : break;
    }
}
void MDB_PollHandler(void)
{
    switch(csh_poll_state)
    {
        case CSH_ACK                    : MDB_Send(CSH_ACK);      break; 
        case CSH_SILENCE                :                         break;
        case CSH_JUST_RESET             : JustReset();            break;
        case CSH_READER_CONFIG_INFO     : ConfigInfo();           break;
        case CSH_DISPLAY_REQUEST        : DisplayRequest();       break; 
        case CSH_BEGIN_SESSION          : BeginSession();         break; 
        case CSH_SESSION_CANCEL_REQUEST : SessionCancelRequest(); break;
        case CSH_VEND_APPROVED          : VendApproved();         break;
        case CSH_VEND_DENIED            : VendDenied();           break;
        case CSH_END_SESSION            : EndSession();           break;
        case CSH_CANCELLED              : Cancelled();            break;
        case CSH_PERIPHERAL_ID          : PeripheralID();         break;
        case CSH_MALFUNCTION_ERROR      : MalfunctionError();     break;
        case CSH_CMD_OUT_OF_SEQUENCE    : CmdOutOfSequence();     break;
        case CSH_DIAGNOSTIC_RESPONSE    : DiagnosticResponse();   break;
        default : break;
    }
}
void MDB_VendHandler(void)
{
    uint16_t subcomm_temp;
    uint8_t subcomm;

    
    while (1)
        if (MDB_DataCount() > 0)
            break;
    
    MDB_Read(&subcomm_temp);
    subcomm = (uint8_t)(subcomm_temp & 0x00FF); 
    
    switch(subcomm)
    {
        case VMC_VEND_REQUEST : VendRequest();         break;
        case VMC_VEND_CANCEL  : VendDenied();          break;
        case VMC_VEND_SUCCESS : VendSuccessHandler();  break;
        case VMC_VEND_FAILURE : VendFailureHandler();  break;
        case VMC_VEND_SESSION_COMPLETE : VendSessionComplete(); break;
        case VMC_VEND_CASH_SALE : VendCashSale();      break;
        default : break;
    }
}
void MDB_ReaderHandler(void)
{
    uint8_t i; 
    uint8_t checksum = VMC_READER;
    uint16_t reader_temp;
    uint8_t reader_data[2];
    
    while (1)
        if (MDB_DataCount() > 1)
            break;
    
    for (i = 0; i < 2; ++i)
    {
        MDB_Read(&reader_temp);
        reader_data[i] = (uint8_t)(reader_temp & 0x00FF); 
    }
    
    checksum += calc_checksum(reader_data, 1);
    
    if (checksum != reader_data[1])
    {
        MDB_Send(CSH_NAK);
        return; 
    }
    
    switch(reader_data[0])
    {
        case VMC_READER_DISABLE : Disable();   break;
        case VMC_READER_ENABLE  : Enable();    break;
        case VMC_READER_CANCEL  : Cancelled(); break;
        default : break;
    }
}
void MDB_ExpansionHandler(void)
{
    uint16_t readCmd;

    MDB_Read(&readCmd);
    switch(readCmd)
    {
        case VMC_EXPANSION_REQUEST_ID  : ExpansionRequestID(); break;
        case VMC_EXPANSION_DIAGNOSTICS : ExpansionDiagnostics(); break;
        
        default : break;
    }
    
}
void MDB_Send(uint16_t data)
{
    USART_TXBuf_Write(data);
}
void MDB_Read(uint16_t *data)
{
    USART_RXBuf_Read(data);
}
void MDB_Peek(uint16_t *data)
{
    USART_RXBuf_Peek(data);
}

uint8_t MDB_DataCount (void)
{
    return USART_RXBuf_Count();
}

void Reset(void)
{
    
    vmc_config.featureLevel   = 0;
    vmc_config.displayColumns = 0;
    vmc_config.displayRows    = 0;
    vmc_config.displayInfo    = 0;

    vmc_prices.maxPrice = 0;
    vmc_prices.minPrice = 0;

    csh_error_code = 0;
    
    csh_state = CSH_S_INACTIVE;
    csh_poll_state = CSH_JUST_RESET;
    MDB_Send(CSH_ACK);

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void JustReset(void)
{
    MDB_Send(CSH_JUST_RESET);
    Reset();

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void ConfigInfo(void)
{
    uint8_t checksum = 0;
    
    checksum = ( CSH_READER_CONFIG_INFO
               + csh_config.featureLevel
               + csh_config.countryCodeH
               + csh_config.countryCodeL
               + csh_config.scaleFactor
               + csh_config.decimalPlaces
               + csh_config.maxResponseTime
               + csh_config.miscOptions );
    MDB_Send(CSH_READER_CONFIG_INFO);
    MDB_Send(csh_config.featureLevel);
    MDB_Send(csh_config.countryCodeH);
    MDB_Send(csh_config.countryCodeL);
    MDB_Send(csh_config.scaleFactor);
    MDB_Send(csh_config.decimalPlaces);
    MDB_Send(csh_config.maxResponseTime);
    MDB_Send(csh_config.miscOptions);
    MDB_Send(checksum | CSH_ACK);

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void DisplayRequest(void)
{
    
    
    
    
    
    
    
    

    
    //  /* Here you need to copy the message into allocated memory
     

    
    
    
    
    
    
    

    
    
    
}

void BeginSession(void) 
{
    /*
     * I need this variable because my VMC doesn't want to send a
     * VMC_VEND command (0x113) after I answer it with a single BEGIN SESSION Poll Reply
     * So I decided to try it several times, that is what this counter for
     */
    static uint8_t begin_session_counter = 0;
    
    uint8_t checksum = 0;
    uint16_t funds = CSH_GetUserFunds();
    uint8_t user_funds_H = (uint8_t)(funds >> 8);
    uint8_t user_funds_L = (uint8_t)(funds &  0x00FF);

    
    begin_session_counter++;
    if (begin_session_counter >= 50)
    {
        csh_poll_state = CSH_ACK;
        csh_state = CSH_S_SESSION_IDLE;
        begin_session_counter = 0;
        return;
    }

    
    checksum = ( CSH_BEGIN_SESSION
               + user_funds_H
               + user_funds_L );
    
    MDB_Send(CSH_BEGIN_SESSION);
    MDB_Send(user_funds_H);      
    MDB_Send(user_funds_L);      
    MDB_Send(checksum | CSH_ACK);   
    
    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
        
        
        
    
    
    
    
}

void SessionCancelRequest(void)
{
    MDB_Send(CSH_SESSION_CANCEL_REQUEST);
    MDB_Send(CSH_SESSION_CANCEL_REQUEST | CSH_ACK); 

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void VendApproved(void)
{
    static uint8_t vend_approved_counter = 0;
    uint8_t checksum = 0;
    uint8_t vend_amount_H = (uint8_t)(vend_amount >> 8);
    uint8_t vend_amount_L = (uint8_t)(vend_amount &  0x00FF);
    
    vend_approved_counter++;
    if (vend_approved_counter >= 50)
    {
        csh_poll_state = CSH_END_SESSION;
        vend_approved_counter = 0;
        return;
    }
    
    checksum = ( CSH_VEND_APPROVED
               + vend_amount_H
               + vend_amount_L );
    MDB_Send(CSH_VEND_APPROVED);
    MDB_Send(vend_amount_H);       
    MDB_Send(vend_amount_L);       
    MDB_Send(checksum | CSH_ACK);  
     
    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void VendDenied(void)
{
    MDB_Send(CSH_VEND_DENIED);
    MDB_Send(CSH_VEND_DENIED | CSH_ACK); 

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
    csh_poll_state = CSH_END_SESSION;
    
    
    
}

void EndSession(void)
{
    MDB_Send(CSH_END_SESSION);
    MDB_Send(CSH_END_SESSION | CSH_ACK); 

    
    
    
    CSH_SetUserFunds(0);
    CSH_SetItemCost(0);
    CSH_SetVendAmount(0);   
    CSH_SetPollState(CSH_JUST_RESET);
    CSH_SetDeviceState(CSH_S_ENABLED); 
}

void Cancelled(void)
{
    if (csh_state != CSH_S_ENABLED)
        return;
    MDB_Send(CSH_CANCELLED);
    MDB_Send(CSH_CANCELLED | CSH_ACK); 
    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void PeripheralID(void)
{
    
    
    uint8_t i; 
    uint8_t checksum = 0;
    uint8_t periph_id[31];
    uint8_t a_char = 0x41;
    periph_id[0] = CSH_PERIPHERAL_ID;
    periph_id[1] = 'U'; periph_id[2] = 'N'; periph_id[3] = 'I'; 
    
    
    for (i = 4; i < 15; ++i)
        periph_id[i] = 0;

    periph_id[15] = 1;

    
    
    for (i = 16; i < 28; ++i)
        periph_id[i] = a_char + i;
    
    periph_id[28] = 1;
    periph_id[29] = 0;
    periph_id[30] = calc_checksum(periph_id, 29);
    
    for (i = 0; i < 30; ++i)
        MDB_Send(periph_id[i]);

    MDB_Send(periph_id[30] | CSH_ACK);

    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void MalfunctionError(void)
{
    uint8_t i;
    uint8_t malf_err[2];
    malf_err[0] = CSH_MALFUNCTION_ERROR;
    malf_err[1] = csh_error_code;
    
    malf_err[2] = calc_checksum(malf_err, 2) | CSH_ACK;
    for (i = 0; i < 3; ++i)
        MDB_Send(malf_err[i]);
}

void CmdOutOfSequence(void)
{
    MDB_Send(CSH_CMD_OUT_OF_SEQUENCE);
    MDB_Send(CSH_CMD_OUT_OF_SEQUENCE | CSH_ACK);
}

void DiagnosticResponse(void)
{

}

void VendRequest(void)
{
    uint8_t i; 
    uint8_t checksum = VMC_VEND + VMC_VEND_REQUEST;
    uint8_t vend_data[5];
    uint16_t vend_temp;
    
    
    while (1)
        if (MDB_DataCount() > 4)
            break;
    
    for (i = 0; i < 5; ++i)
    {
        MDB_Read(&vend_temp);
        vend_data[i] = (uint8_t)(vend_temp & 0x00FF); 
    }
    
    checksum += calc_checksum(vend_data, 4);
    
    if (checksum != vend_data[4])
    {
        MDB_Send(CSH_NAK);
        return; 
    }
    CSH_SetItemCost((vend_data[0] << 8) | vend_data[1]);
    CSH_SetVendAmount((vend_data[2] << 8) | vend_data[3]);
    
    MDB_Send(CSH_ACK);
    
    csh_state = CSH_S_VEND;
    /*
     * ===================================
     * HERE GOES THE CODE FOR RFID/HTTP Handlers
     * if enough payment media, tell server to subtract sum
     * wait for server reply, then CSH_VEND_APPROVED
     * Otherwise, CSH_VEND_DENIED
     * ===================================
    */
}

void VendSuccessHandler(void)
{
    uint8_t i; 
    uint8_t checksum = VMC_VEND + VMC_VEND_SUCCESS;
    uint8_t vend_data[3];
    uint16_t vend_temp;

    
    
    while (1)
        if (MDB_DataCount() > 2)
            break;

    for (i = 0; i < 3; ++i)
    {
        MDB_Read(&vend_temp);
        vend_data[i] = (uint8_t)(vend_temp & 0x00FF); 
    }
    
    MDB_Send(CSH_ACK);

    
    csh_state = CSH_S_SESSION_IDLE;

    
    
    
    
    
    
}

void VendFailureHandler(void)
{
    uint8_t checksum = VMC_VEND + VMC_VEND_FAILURE;
    uint8_t incoming_checksum;
    uint16_t temp;
    
    
    while (1)
        if (MDB_DataCount() > 0)
            break;
    MDB_Read(&temp);
    incoming_checksum = (uint8_t)(temp & 0x00FF); 
    if (checksum != incoming_checksum)
    {
        MDB_Send(CSH_NAK);
        return; 
    }
    

    MDB_Send(CSH_ACK); 
    
    
    csh_state = CSH_S_SESSION_IDLE;
}

void VendSessionComplete(void)
{
    MDB_Send(CSH_ACK);
    CSH_SetPollState(CSH_END_SESSION);
}

void VendCashSale(void)
{
    uint8_t i; 
    uint8_t checksum = VMC_VEND + VMC_VEND_CASH_SALE;
    uint8_t vend_data[5];
    uint16_t vend_temp;
    
    
    while (1)
        if (MDB_DataCount() > 4)
            break;
    for (i = 0; i < 5; ++i)
    {
        MDB_Read(&vend_temp);
        vend_data[i] = (uint8_t)(vend_temp & 0x00FF); 
    }
    checksum += calc_checksum(vend_data, 4);
    if (checksum != vend_data[4])
    {
        MDB_Send(CSH_NAK);
        return; 
    }

    

    MDB_Send(CSH_ACK);
}
void Disable(void)
{
    csh_state = CSH_S_DISABLED;
    MDB_Send(CSH_ACK);
}

void Enable(void)
{
    if (csh_state != CSH_S_DISABLED)
        return;
    csh_state = CSH_S_ENABLED;
    csh_poll_state = CSH_ACK;
    MDB_Send(CSH_ACK);
}
void ExpansionRequestID(void)
{
    uint16_t i; 
    uint8_t checksum = VMC_EXPANSION + VMC_EXPANSION_REQUEST_ID;
    uint16_t temp;
    uint8_t data[30];
    /*
     * Wait for incoming 29 data elements + 1 checksum (30 total)
     * Store the data by the following indexes:
     *  0,  1,  2 -- Manufacturer Code (3 elements)
     *  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14 -- Serial Number (12 elements)
     * 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 -- Model  Number (12 elements)
     * 27, 28 -- Software Version (2 elements)
     * 29 -- Checksum (1 element)
     */
    while (1)
        if (MDB_DataCount() > 29)
            break;
    
    for (i = 0; i < 30; ++i)
    {
        MDB_Read(&temp);
        data[i] = (uint8_t)(temp & 0x00FF); 
    }

    
    checksum += calc_checksum(data, 29);
    
    if (checksum != data[29])
    {
        MDB_Send(CSH_NAK);
        return; 
    }
    
    PeripheralID();
    while ( ! (USART_TXBuf_IsEmpty()) )
        ;
}

void ExpansionDiagnostics(void)
{
    uint8_t checksum = VMC_EXPANSION + VMC_EXPANSION_DIAGNOSTICS;
    MDB_Send(CSH_ACK);
    
    
}
uint8_t CSH_GetPollState(void)
{
    return csh_poll_state;
}
uint8_t CSH_GetDeviceState(void)
{
    return csh_state;
}
uint16_t CSH_GetUserFunds(void)
{
    return user_funds;
}
uint16_t CSH_GetItemCost(void)
{
    return item_cost;
}
uint16_t CSH_GetVendAmount(void)
{
    return vend_amount;
}
void CSH_SetPollState(uint8_t new_poll_state)
{
    csh_poll_state = new_poll_state;
}
void CSH_SetDeviceState(uint8_t new_device_state)
{
    csh_state = new_device_state;
}
void CSH_SetUserFunds(uint16_t new_funds)
{
    user_funds = new_funds;
}
void CSH_SetItemCost(uint16_t new_item_cost)
{
    item_cost = new_item_cost;
}
void CSH_SetVendAmount(uint16_t new_vend_amount)
{
    vend_amount = new_vend_amount;
}


 /*
  * calc_checksum()
  * Calculates checksum of *array from 0 to arr_size
  * Use with caution (because of pointer arithmetics)
  */
uint8_t calc_checksum(uint8_t *array, uint8_t arr_size)
{
    uint8_t ret_val = 0x00;
    uint8_t i;
    for (i = 0; i < arr_size; ++i)
        ret_val += *(array + i);
    return ret_val;
}/*
 * Micro_Bros-Smart-Home.c
 *
 * Created: 4/24/2022 2:37:59 AM
 * Author : Micro_Bros
 */

#include "main.h"

static unsigned char password[4]="0000";
static int curr_temp = 255; 
static int last_temp = 255; 
uint8_t get_temp();
void Button_Led_initialize()
{DDRD  |= (1<<0); 
DDRD  |= (1<<6); 
DDRD  |= (1<<2); 
DDRA  |= (1<<2); 
MCUCR |= (1 << ISC01);
GICR  |= (1 << INT0);
}

void enter_the_door()
{
PORTD |=  (1<<2);
PORTD &= ~(1<<2);
}

int main(void)
{
LCD_initialize();
PIR_initialize();
Temp_initialize();
buzzer_initialize();
Button_Led_initialize();
sei();
uint8_t requierd_temp=28;

LCD_display_text("Welcome Home , ",700);
_delay_ms(200);
LCD_set_Cursor(1,0);
LCD_display_text("Mr. abdelrhman",700);

enter_the_door(); 
_delay_ms(500);


while (1)
  {
PIR_DETECT_MOTION(); 
last_temp = curr_temp;
curr_temp = Temp_GetInput();
Temp_warning(curr_temp ,(int)requierd_temp);
if(last_temp == 255 || (curr_temp-last_temp) )
{ 
Temp_display(curr_temp);
}

  }
 }

ISR(INT0_vect)
{
_delay_ms(500);
unsigned int  counter = 0;
unsigned char entered_password[4]={' '};

while( 1 )
{
LCD_clear();
LCD_display_text("enter password:",700);
LCD_set_Cursor(1,0);
for(int i =0 ; i<4 ; i++)
{
entered_password[i]=Get_Key_pressed();
LCD_display_char(entered_password[i]); 
_delay_ms(500);
}
_delay_ms(500);
if( (memcmp(entered_password, password, sizeof(entered_password)) != 0) )
{
counter++;
PORTD|=(1<<0); 
LCD_clear();
LCD_display_text("Wrong password",700);
LCD_set_Cursor(1,0);
LCD_display_text("You have ",700);
LCD_display_char( 3-counter+'0' );
LCD_display_text(" left",700);
_delay_ms(500);
PORTD&=~(1<<0); 

if(counter == 3)
{
LCD_clear();
LCD_set_Cursor(1,3);
LCD_display_text("a Thief !! ",700);
LCD_set_Cursor(1,2);
LCD_display_text("  go away !! ",700);
buzzer_turn_on(10000); 
counter = 0; 
break;
}
}

else
{
LCD_clear();
PORTA  |=  (1<<2);
opendoor();
_delay_ms(500);
PORTA  &= ~(1<<2);  
counter = 0;
last_temp = 255;
break;
}
}
}

//}/**********************************************************************************
* FourQlib: a high-performance crypto library based on the elliptic curve FourQ
*
*    Copyright (c) Microsoft Corporation. All rights reserved.
*
* Abstract: digital signature SchnorrQ
************************************************************************************/

#include "FourQ_internal.h"
#include "FourQ_params.h"
#include "random/random.h" 
#include "blake2b/blake.h" 
#include <stdlib.h>
#include <string.h>


ECCRYPTO_STATUS SchnorrQ_KeyGeneration(const unsigned char* SecretKey, unsigned char* PublicKey)
{ 
  
  
  
  
    point_t P;
    unsigned char k[64];
    ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN;
  
    if (CryptoHashFunction(SecretKey, 32, k) != 0) {   
        Status = ECCRYPTO_ERROR;
        goto cleanup;
    }
    
    ecc_mul_fixed((digit_t*)k, P);          
    encode(P, PublicKey);               

    return ECCRYPTO_SUCCESS;

cleanup:
    clear_words((unsigned int*)k, 512/(sizeof(unsigned int)*8));
    clear_words((unsigned int*)PublicKey, 256/(sizeof(unsigned int)*8));

    return Status;
}


ECCRYPTO_STATUS SchnorrQ_FullKeyGeneration(unsigned char* SecretKey, unsigned char* PublicKey)
{ 
  
  
  
    ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN;

    Status = RandomBytesFunction(SecretKey, 32);
    if (Status != ECCRYPTO_SUCCESS) {
        goto cleanup;
    }
  
    Status = SchnorrQ_KeyGeneration(SecretKey, PublicKey);   
    if (Status != ECCRYPTO_SUCCESS) {
        goto cleanup;
    }

    return ECCRYPTO_SUCCESS;

cleanup:
    clear_words((unsigned int*)SecretKey, 256/(sizeof(unsigned int)*8));
    clear_words((unsigned int*)PublicKey, 256/(sizeof(unsigned int)*8));

    return Status;
}


ECCRYPTO_STATUS SchnorrQ_Sign(const unsigned char* SecretKey, const unsigned char* PublicKey, const unsigned char* Message, const unsigned int SizeMessage, unsigned char* Signature)
{ 
  
  
  
    point_t R;
    unsigned char k[64], r[64], h[64], *temp = NULL;
    digit_t* H = (digit_t*)h;
    digit_t* S = (digit_t*)(Signature+32);
    ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN;
      
    if (CryptoHashFunction(SecretKey, 32, k) != 0) {   
        Status = ECCRYPTO_ERROR;
        goto cleanup;
    }
    
    temp = (unsigned char*)calloc(1, SizeMessage+64);
    if (temp == NULL) {
Status = ECCRYPTO_ERROR_NO_MEMORY;
        goto cleanup;
    }
    
    memmove(temp+32, k+32, 32);
    memmove(temp+64, Message, SizeMessage);
  
    if (CryptoHashFunction(temp+32, SizeMessage+32, r) != 0) {   
        Status = ECCRYPTO_ERROR;
        goto cleanup;
    }
    
    ecc_mul_fixed((digit_t*)r, R); 
    encode(R, Signature);                   
    memmove(temp, Signature, 32);
    memmove(temp+32, PublicKey, 32);
  
    if (CryptoHashFunction(temp, SizeMessage+64, h) != 0) {   
        Status = ECCRYPTO_ERROR;
        goto cleanup;
    }

    modulo_order((digit_t*)r, (digit_t*)r);
    modulo_order(H, H);
    to_Montgomery((digit_t*)k, S);          
    to_Montgomery(H, H);                    
    Montgomery_multiply_mod_order(S, H, S);
    from_Montgomery(S, S);                  
    subtract_mod_order((digit_t*)r, S, S);
    Status = ECCRYPTO_SUCCESS;
    
cleanup:
    if (temp != NULL)
        free(temp);
    clear_words((unsigned int*)k, 512/(sizeof(unsigned int)*8));
    clear_words((unsigned int*)r, 512/(sizeof(unsigned int)*8));
    
    return Status;
}


ECCRYPTO_STATUS SchnorrQ_Verify(const unsigned char* PublicKey, const unsigned char* Message, const unsigned int SizeMessage, const unsigned char* Signature, unsigned int* valid)
{ 
  
  
  
    point_t A;
    unsigned char *temp, h[64];
    unsigned int i;
    ECCRYPTO_STATUS Status = ECCRYPTO_ERROR_UNKNOWN;  

    *valid = false;

    temp = (unsigned char*)calloc(1, SizeMessage+64);
    if (temp == NULL) {
        Status = ECCRYPTO_ERROR_NO_MEMORY;
        goto cleanup;
    }

    if (((PublicKey[15] & 0x80) != 0) || ((Signature[15] & 0x80) != 0) || (Signature[63] != 0) || ((Signature[62] & 0xC0) != 0)) {  
        Status = ECCRYPTO_ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    Status = decode(PublicKey, A);    
    if (Status != ECCRYPTO_SUCCESS) {
        goto cleanup;                            
    }

    memmove(temp, Signature, 32);
    memmove(temp+32, PublicKey, 32);
    memmove(temp+64, Message, SizeMessage);
  
    if (CryptoHashFunction(temp, SizeMessage+64, h) != 0) {   
        Status = ECCRYPTO_ERROR;
        goto cleanup;
    }

    Status = ecc_mul_double((digit_t*)(Signature+32), A, (digit_t*)h, A);      
    if (Status != ECCRYPTO_SUCCESS) {                                                
        goto cleanup;
    }

    encode(A, (unsigned char*)A);

    for (i = 0; i < NWORDS_ORDER; i++) {
        if (((digit_t*)A)[i] != ((digit_t*)Signature)[i]) {
            goto cleanup;   
        }
    }
    *valid = true;

cleanup:
    if (temp != NULL)
        free(temp);
    
    return Status;
}#include <errno.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <openssl/evp.h>

#include "crypt.h"
#include "utils.h"

#define ENC_SEC_SIZE4096

GQuark r_crypt_error_quark(void)
{
return g_quark_from_static_string("r_crypt_error_quark");
}

G_DEFINE_AUTOPTR_CLEANUP_FUNC(EVP_CIPHER_CTX, EVP_CIPHER_CTX_free);

static void iv_plain64(guint8 *iv, guint iv_size, guint64 sector)
{
guint64 iv_val;
g_return_if_fail(iv);

memset(iv, 0, iv_size);
iv_val = GUINT64_TO_LE(sector * ENC_SEC_SIZE / 512);
memcpy(iv, &iv_val, sizeof(guint64));
}

static gboolean encrypt_or_decrypt(FILE *fd, FILE *out, const uint8_t *key, gboolean encrypt, goffset maxsize, GError **error)
{
/* Allow enough space in output buffer for additional block */
unsigned char inbuf[ENC_SEC_SIZE], outbuf[ENC_SEC_SIZE];
g_autoptr(EVP_CIPHER_CTX) ctx = NULL;
int ret;
const EVP_CIPHER *cipher = EVP_aes_256_cbc();
guint64 sector_count = 0;
guint8 iv[16];
goffset donesize = 0;

g_return_val_if_fail(fd != NULL, FALSE);
g_return_val_if_fail(out != NULL, FALSE);

/* Don't set key or IV right away; we want to check lengths */
ctx = EVP_CIPHER_CTX_new();
ret = EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, encrypt ? 1 : 0);
if (!ret)
g_error("Error setting cipher");

/* disable padding as we expect to have only matching blocks*/
EVP_CIPHER_CTX_set_padding(ctx, 0);

/* assert expected input key and iv size */
g_assert(EVP_CIPHER_CTX_key_length(ctx) == 32);
g_assert(EVP_CIPHER_CTX_iv_length(ctx) == 16);

/* encrypt/decrypt in 4096 byte sectors */
for (;;) { 
int inlen, outlen;

/* plain64 iv mode */
iv_plain64(iv, 16, sector_count++);

/* set up with key and iv for encryption/decryption */
ret = EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, encrypt ? 1 : 0);
if (!ret)
g_error("Error setting key and iv");

inlen = fread(inbuf, 1, ENC_SEC_SIZE, fd);
donesize += inlen;
/* image size must be multiple of 4096 */
if (inlen <= 0)
break;
if (inlen < ENC_SEC_SIZE) {
g_set_error(error, R_CRYPT_ERROR, R_CRYPT_ERROR_FAILED, "Incomplete read: Input size must be multiple of %d (got only %d bytes)", ENC_SEC_SIZE, inlen);
return FALSE;
}

/* limit decrypt size to maxsize if set */
if (maxsize && donesize > maxsize) {
return TRUE;
}

if (!EVP_CipherUpdate(ctx, outbuf, &outlen, inbuf, ENC_SEC_SIZE)) {
g_set_error(error, R_CRYPT_ERROR, R_CRYPT_ERROR_FAILED, "EVP_CipherUpdate() failed");
return FALSE;
}

fwrite(outbuf, 1, outlen, out);

if (!EVP_CipherFinal_ex(ctx, outbuf, &outlen)) {
g_set_error(error, R_CRYPT_ERROR, R_CRYPT_ERROR_FAILED, "EVP_CipherFinal_ex() failed");
return FALSE;
}
}

return TRUE;
}

static gboolean r_crypt_encrypt_or_decrypt(const gchar *inpath, const gchar *outpath, const uint8_t *key, gboolean encrypt, goffset maxsize, GError **error)
{
FILE *infile = NULL, *outfile = NULL;
GError *ierror = NULL;
gboolean res = FALSE;

g_return_val_if_fail(inpath, FALSE);
g_return_val_if_fail(outpath, FALSE);
g_return_val_if_fail(key, FALSE);
g_return_val_if_fail(error == NULL || *error == NULL, FALSE);

infile = g_fopen(inpath, "r");
if (!infile) {
int err = errno;
g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(err),
"Failed opening %s for reading: %s", inpath, g_strerror(err));
res = FALSE;
goto out;
}

outfile = g_fopen(outpath, "w");
if (!outfile) {
int err = errno;
g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(err),
"Failed opening temporary file %s for writing: %s", outpath, g_strerror(err));
res = FALSE;
goto out;
}

res = encrypt_or_decrypt(infile, outfile, key, encrypt, maxsize, &ierror);
if (!res) {
g_propagate_prefixed_error(error, ierror,
"Failed to %s image: ", encrypt ? "encrypt" : "decrypt");
goto out;
}

res = TRUE;
out:
if (infile)
fclose(infile);
if (outfile)
fclose(outfile);
return res;
}

gboolean r_crypt_encrypt(const gchar *in, const gchar *out, const guint8 *key, GError **error)
{
return r_crypt_encrypt_or_decrypt(in, out, key, TRUE, 0, error);
}

gboolean r_crypt_decrypt(const gchar *in, const gchar *out, const guint8 *key, goffset maxsize, GError **error)
{
return r_crypt_encrypt_or_decrypt(in, out, key, FALSE, maxsize, error);
}#define F_CPU 7372800UL
#include <avr/io.h>
#include <stdlib.h>
#include <util/delay.h>
#include <stdio.h>
#include <string.h>
#include <avr/interrupt.h>

#include "lcd.h"

#define KEY_PRTPORTB
#define KEY_DDRDDRB
#define KEY_PINPINB

#define VALUE_POT 50
#define POT_ZERO 0
#define CONFIRM_SOUND 2
#define ALARM_SOUND 6
#define WRONG_PASS 3
#define ADC_PLUS 51
#define ADC_MINUS 49
#define PASS_LENGHT 4
#define FIRST_ROW 0
#define SECOND_ROW 1
#define THIRD_ROW 2
#define FOURTH_ROW 3
#define MIDDLE_POSITION 5

unsigned char keypad[4][4] = {{'1','4','7','*'},{'2','5','8','0'},{'3','6','9','#'},{'A','B','C','D'}};
static char output[5] = {'*','*','*','*'};
static int buzzerCounter;
static int doorOpen = 0;
static int flagPot = 0;
static int pot1;
static int pot2;
static char potChar[16];
static int flagWrongPass = 0;
static int wrongPassCounter = 3;
const char *passwordCheck = "1598";
const char *passwordLock = "####";
const char confirm = 'A';
unsigned char column, row;


char keyfind(){
while(1){
KEY_DDR = 0xF0;          
KEY_PRT = 0xFF;

do{
KEY_PRT &= 0x0F;     
asm("NOP");
column = (KEY_PIN & 0x0F); 
}while(column != 0x0F);

do{
do{
_delay_ms(20);             
column = (KEY_PIN & 0x0F); 
}while(column == 0x0F);       

_delay_ms (40);            
column = (KEY_PIN & 0x0F);
}while(column == 0x0F);

KEY_PRT = 0xEF;           
asm("NOP");
column = (KEY_PIN & 0x0F);

if(column != 0x0F){
row = FIRST_ROW;
break;
}

KEY_PRT = 0xDF;
asm("NOP");
column = (KEY_PIN & 0x0F);

if(column != 0x0F){
row = SECOND_ROW;
break;
}

KEY_PRT = 0xBF;
asm("NOP");
column = (KEY_PIN & 0x0F);

if(column != 0x0F){
row = THIRD_ROW;
break;
}

KEY_PRT = 0x7F;
asm("NOP");
column = (KEY_PIN & 0x0F);

if(column != 0x0F){
row = FOURTH_ROW;
break;
}
}

if(column == 0x0E){
return(keypad[row][0]);
}else if(column == 0x0D){
return(keypad[row][1]);
}else if(column == 0x0B) {
return(keypad[row][2]);
}else{
return(keypad[row][3]);
}
}


void buzzerDetection(){
if(flagWrongPass == 0){
while(buzzerCounter > 0){
PORTC ^= _BV(7);
_delay_ms(125);
buzzerCounter--;
}
} else if(flagWrongPass == 1){
while(1){
PORTC ^= _BV(7) | _BV(0) | _BV(1) | _BV(6);
PORTA ^= _BV(3) | _BV(4) | _BV(5);

_delay_ms(125);

if(!(PINB & _BV(PB0))){
if((PINB & _BV(PB0)) == 0){
flagWrongPass = 0;
wrongPassCounter = WRONG_PASS;
PORTC |= _BV(7);

if(doorOpen == 0){
PORTC |= _BV(0) | _BV(1) | _BV(6); 
PORTA &= ~(_BV(3) | _BV(4) | _BV(5)); 
} else {
PORTC &= ~(_BV(0) | _BV(1) | _BV(6)); 
PORTA |= _BV(3) | _BV(4) | _BV(5); 
}
break;
}
}
}
}
}


void turnServo() {
if(doorOpen == 1){
PORTD ^= _BV(5);
OCR1A = 276; 
} else if(doorOpen == 0){
PORTD ^= _BV(5);
OCR1A = 59; 
}
}


void writeLCD(uint16_t adc) {
char adcStr[16];
itoa(round(adc), adcStr, 10);

if(flagPot == 0){
lcd_clrscr();

lcd_gotoxy(6,FIRST_ROW);
lcd_puts(adcStr);
} else if(flagPot == 1){
lcd_clrscr();

lcd_gotoxy(6,FIRST_ROW);
lcd_puts(potChar);
lcd_gotoxy(6,SECOND_ROW);
lcd_puts(adcStr);
}

if(pot1 == VALUE_POT && pot2 == VALUE_POT){
lcd_clrscr();
lcd_puts("Otvoren sef!");
}
}


void readPotentiometer(){
uint16_t adcConversion;

while(1){

adcConversion = ADC/10;

if((adcConversion<= ADC_PLUS && adcConversion >= ADC_MINUS) && flagPot == 0){
if(!(PINB & _BV(PB0))){
if((PINB & _BV(PB0)) == 0){
ADMUX |= _BV(MUX0); 
flagPot = 1;
pot1 = VALUE_POT;
itoa(pot1, potChar, 10);

PORTC ^= _BV(0);
PORTA ^= _BV(4);

buzzerCounter = CONFIRM_SOUND;
buzzerDetection();
}
}
} else if((adcConversion <= ADC_PLUS && adcConversion >= ADC_MINUS) && flagPot == 1){
if(!(PINB & _BV(PB0))){
if((PINB & _BV(PB0)) == 0){
pot2 = VALUE_POT;

PORTC ^= _BV(1);
PORTA ^= _BV(3);

buzzerCounter = CONFIRM_SOUND;
buzzerDetection();
}
}
}
ADCSRA |= _BV(ADSC);

while (!(ADCSRA & _BV(ADIF)));

writeLCD(adcConversion);

_delay_ms(150);

if(pot1 == VALUE_POT && pot2 == VALUE_POT){
doorOpen = 1;
ADMUX &= ~_BV(MUX0); 
turnServo();
break;
}
}
}


void checkPassword(){
if((!strncmp(output, passwordLock, PASS_LENGHT)) && doorOpen == 1){
lcd_clrscr();
lcd_puts("Sef zatvoren!");

doorOpen = 0;
turnServo();
buzzerCounter = CONFIRM_SOUND;
buzzerDetection();

PORTC ^= _BV(0) | _BV(1) | _BV(6);
PORTA ^= _BV(3) | _BV(4) | _BV(5);

pot1 = POT_ZERO;
pot2 = POT_ZERO;
memset(potChar, 0, sizeof(potChar));
flagPot = 0;

} else if(strncmp(output, passwordCheck, PASS_LENGHT)){
lcd_clrscr();
lcd_puts("Netocna lozinka!");

buzzerCounter = ALARM_SOUND;
buzzerDetection();
wrongPassCounter--;

if(wrongPassCounter == 0){
flagWrongPass = 1;
buzzerDetection();
}
} else  {
lcd_clrscr();
lcd_puts("Tocna lozinka!");

buzzerCounter = CONFIRM_SOUND;
buzzerDetection();

PORTC ^= _BV(6);
PORTA ^= _BV(5);

_delay_ms(1000);
readPotentiometer();
}
_delay_ms(1500);
memset(output, '*', sizeof(output)-1);
}


void keyPassword(){
uint8_t i;
char pass;

lcd_clrscr();
lcd_puts("Unesite lozinku!");

for(i = 0; i < PASS_LENGHT; i++){
char password = keyfind();

output[i] = password;
lcd_gotoxy(i+MIDDLE_POSITION,SECOND_ROW);
lcd_puts(&output[i]);
}
output[4] = '\0';

pass = keyfind();
if(pass == confirm){
checkPassword();
}
}


ISR(TIMER0_COMP_vect){
PORTA ^= _BV(6);
}


ISR(TIMER1_COMPA_vect){
if(doorOpen == 1){
PORTD ^= _BV(5);
}
}


void initMain(){
DDRA |= _BV(6); 

DDRB = 0xff; 
PORTB = 0x00;

DDRC = _BV(7); 

DDRC |= _BV(0) | _BV(1) | _BV(6); 
PORTC = _BV(7) | _BV(0) | _BV(1) | _BV(6);

DDRA |= _BV(3) | _BV(4) | _BV(5); 

DDRD |= _BV(5); 
TCNT1 = 0;
ICR1 = 2303; 
TCCR1A = _BV(WGM11) | _BV(COM1A1); 
TCCR1B = _BV(WGM12) | _BV(WGM13) | _BV(CS10) | _BV(CS11);
OCR1A = 59; 
TIMSK = _BV(OCIE1A);


TCCR0 = _BV(WGM01) | _BV(WGM00) | _BV(COM01) | _BV(CS00); 
OCR0 = 200;
TIMSK = _BV(OCIE0);

sei();

ADMUX = _BV(REFS0);
ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1);

lcd_init(LCD_DISP_ON);
lcd_clrscr();

memset(potChar, 0, sizeof(potChar));
}


int main(void){
initMain();

while (1){
keyPassword();
}
}
/******************************************************************************/

/* Device header file */
#if defined(__XC16__)
    #include <xc.h>
#elif defined(__C30__)
    #if defined(__PIC24E__)
    #include <p24Exxxx.h>
    #elif defined (__PIC24F__)||defined (__PIC24FK__)
#include <p24Fxxxx.h>
    #elif defined(__PIC24H__)
#include <p24Hxxxx.h>
    #endif
#endif

#include <stdint.h>        
#include <stdbool.h>       
#include <stdlib.h>
#include <stdio.h>

#include "system.h"        
#include "user.h"          

#include "database.h"
#include "debug.h"
#include "event.h"
#include "fingerPrintReader.h"
#include "miscHardware.h"
#include "wifi.h"

char debug[20];
uint8_t lockFlag = FALSE; 

/******************************************************************************/
/* Main Program                                                               */
/******************************************************************************/

int16_t main(void)
{
    InitApp(); 
    while(1) {

        if (switchIsOn()){
            turnOnLED(3);
            lockFlag = FALSE;
        }
        else{
            turnOffLED(3);
        }

        if (buttonIsPressed()) { 
            if (switchIsOn()){
                WifiStart(SERVER_MODE);
            }
            else {
                FPRStart();
                action = IDENTIFY;
                sendFPRCommand(FPR_IS_PRESSED, ZERO);
                
            }
        }

        switch (reqType) {
            case GET_PAGE:
                if (switchIsOn()) sendPage();
                else sendResponse("Error: Door is closed.");
                reqType = DEFAULT;
                reqParseState = DEFAULT;
                break;
            case POST_ENROLL:
                reqType = DEFAULT;
                action = ENROLL;
                if (wifiEnrollProgress != 0) break;
                pendingUserID = findEmptySpot();
                FPRStart();
                int newUser = (uint32_t)pendingUserID;
                sendFPRCommand(FPR_ENROLL_START, newUser);
                break;
            case POST_DELETE:
                reqType = DEFAULT;
                sendFPRCommand(FPR_DELETE_ALL, ZERO);
                deleteDatabase();
                break;
            case POST_SET_WIFI:
                saveWifiInfo();
delay(4000);
                WifiStart(CLIENT_MODE);
delay(1000);
                sendUpdate();
                updateFlag = TRUE;
                reqType = DEFAULT;
                break;
            default:
                if(lockFlag == FALSE){
                        if (!switchIsOn()) {
                            setTimeout(3);
                            action = TIMEOUT_LOCK;
                            FPRState = PARSE_FPR_MSG;
                            lockFlag = TRUE;
                        }
                    }
                if((minute % 30) == 0 && (updateFlag == FALSE)){
                        WifiStart(CLIENT_MODE);
delay(1000);
                        sendUpdate();
                        updateFlag = TRUE;
                        delay(500);
                        turnOnWifiChip(FALSE);
                    }
                break;
        }


        if (FPRState == PARSE_FPR_MSG) {  

            int i = 0;
            switch (action) {
                case DOOR_IS_OPENED:
                    if (!switchIsOn()) {
                        setTimeout(5);
                        action = TIMEOUT_LOCK;
                    }
                    break;
                case IDENTIFY:
                    identify();
                    break;
                case ENROLL:
                    enroll();
                    break;
                case DELETE:
                    sendFPRCommand(FPR_DELETE_ALL, ZERO);
                    break;
                case DELETE_USER:
                    while(newDeleted[i] != 0xFF){
                        sendFPRCommand (FPR_DELETE_ID, newDeleted[i++]);
                        delay(200);
                    }
                    action = DEFAULT;
                    break;
                case OPEN_DOOR:
                   
                    turnAllLEDOff();
                    turnOnLED(1);
                    setTimeout(5);
                    action = TIMEOUT_LOCK;
                    lockDeadBolt(FALSE);
                    lockFlag = FALSE;
                    break;
                case TIMEOUT_LOCK:
                    if (switchIsOn()) {
                        action = DOOR_IS_OPENED;
                    } else if (isTimeout()) {
                        turnOnWifiChip(FALSE);
                        lockDeadBolt(TRUE);
                        lockFlag = TRUE;
                        action = DEFAULT;
                    }
                    break;
                case FINGER_NOT_FOUND:
                    turnAllLEDOff();
                    turnOnLED(0);
                    action = DEFAULT;
                    FPRState = DEFAULT;
                    break;

            }
        }
    }
}/****************************************************************
****************************************************************/
#include "main.h"

#define DEBUG_MODE 0 

void RC522_System_Init(void);
void genRandCode(u8* Des);
void writeQRCodeBuffer();
unsigned char card1[5] = { 0x20, 0x25, 0x35, 0x55, 0x3F }; 
unsigned char card2[4] = { 0xDE, 0x8A, 0xDF, 0x2B }; 

unsigned char snr, buf[16] = " ", bufr[16], TagType[2], SelectedSnr[4], DefaultKey[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
unsigned char Read_Data[16], PassWd[6], WriteData[16], RevBuffer[30], MLastSelectedSnr[4], NewKey[16];
char cardID[4];
char status;

u8 securityCode[7];

u8 modeFlag = 0; 

QRcode* qrcode;

int main(void)
{
    RC522_System_Init(); 
    
    
    OLED_Clear();
    OLED_ShowString(0, 0, "Welcome!", 16, 1);
    OLED_ShowString(0, 16, "RFID System", 16, 1);
    OLED_ShowString(0, 32, "Powered by WRL", 16, 1);
    OLED_ShowString(0, 48, "Version:0.01", 16, 1);
    OLED_Refresh();
    rainbowCycle(1);
    beepOneSecOn();

    if (Key_Scan(GPIOB, GPIO_Pin_12) == KEY_ON) 
    {
        modeFlag = 1;
    }

    

    
    char* ok = "OK";
    char* at = "AT\r\n";
    char* at_cwmode = "AT+CWMODE=1\r\n";
    char* at_rst = "AT+RST\r\n";
    char* at_cifsr = "AT+CIFSR\r\n";
    char* at_cipmux = "AT+CIPMUX=0\r\n";
    char* at_cipmode = "AT+CIPMODE=1\r\n";
    char* at_cipstart = "AT+CIPSTART=\"TCP\",\"192.168.1.110\",25500\r\n";
    char* at_cipsend = "AT+CIPSEND\r\n";

    char* WIFI_SSID = "624"; 
    char* WIFI_KEY = "624624nbnb"; 

    char at_cwjap[64];
    memset(at_cwjap, 0, sizeof(at_cwjap));
    strcat(at_cwjap, "AT+CWJAP=\"");
    strcat(at_cwjap, WIFI_SSID);
    strcat(at_cwjap, "\",\"");
    strcat(at_cwjap, WIFI_KEY);
    strcat(at_cwjap, "\"\r\n");

    OLED_Clear();
    OLED_ShowString(0, 0, "Connect WIFI:", 16, 1);
    OLED_ShowString(0, 16, (u8*)WIFI_SSID, 16, 1);
    OLED_ShowString(0, 32, "Password:", 16, 1);
    OLED_ShowString(0, 48, (u8*)WIFI_KEY, 16, 1);
    OLED_Refresh();

    
    
    USART1_Send_Data("+++", strlen("+++"));
    delay_ms(100); 
    USART1_Send_Data("+++", strlen("+++"));
    delay_ms(100); 

    while (ESP8266_Send_Answer(at, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_cwmode, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_rst, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_cwjap, ok)) {
        delay_ms(100);
    }
    OLED_Clear();
    OLED_ShowString(0, 0, "Connect WIFI:", 16, 1);
    OLED_ShowString(0, 16, "State: OK", 16, 1);
    OLED_ShowString(0, 32, "Ready TO:", 16, 1);
    OLED_ShowString(0, 48, "Server", 16, 1);
    OLED_Refresh();
    while (ESP8266_Send_Answer(at_cifsr, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_cipmux, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_cipmode, ok)) {
        delay_ms(100);
    }
    while (ESP8266_Send_Answer(at_cipstart, ok)) {
        delay_ms(100);
    }
    OLED_Clear();
    OLED_ShowString(0, 0, "Connect Server:", 16, 1);
    OLED_ShowString(0, 16, "State: OK", 16, 1);
    OLED_ShowString(0, 32, "Ready To:", 16, 1);
    OLED_ShowString(0, 48, "Communication", 16, 1);
    OLED_Refresh();
    while (ESP8266_Send_Answer(at_cipsend, ok)) {
        delay_ms(100);
    }

    
    char idCode[8] = "0000001";
    USART1_Send_Data(idCode, strlen(idCode));
    delay_ms(100);

    genRandCode(securityCode);

    ws2812bSetAll(YELLOW);

    beepOneSecOn();

    if (modeFlag == 0) {
        OLED_Clear();
writeQRCodeBuffer();
        OLED_ShowString(65, 0, "Welcome!", 16, 1);
        OLED_ShowString(65, 16, "Security", 16, 1);
OLED_ShowString(65, 32, "Code:", 16, 1);
        OLED_ShowString(65, 48, securityCode, 16, 1);
        OLED_Refresh();
    } else if (modeFlag == 1) {
        OLED_Clear();
        OLED_ShowString(0, 0, "Welcome!", 16, 0);
        OLED_ShowString(0, 16, "New Card Regist", 16, 1);
        OLED_ShowString(0, 32, "Waiting For Card", 16, 1);
        OLED_ShowString(0, 48, "......", 16, 1);
        OLED_Refresh();
    }

    while (1) {
        if (URecv_Index) {
            if (strstr(URecv, "mode1state:ok") != NULL) {
                ws2812bSetAll(GREEN);
                OLED_Clear();
                OLED_ShowString(0, 0, "Verify OK", 16, 0);
                OLED_ShowString(0, 16, "Opening Now!", 16, 1);
#if DEBUG_MODE == 1
                OLED_ShowString(0, 32, "Server Return:", 16, 1);
                OLED_ShowString(0, 48, (u8*)URecv, 16, 1);

#endif
                OLED_Refresh();
                beepOneSecOn();

                relay_on(); 
                delay_10ms(120);
                relay_off();
            } else if (strstr(URecv, "mode0state:ok") != NULL) {
                ws2812bSetAll(GREEN);
                OLED_Clear();
                OLED_ShowString(0, 0, "Registing OK", 16, 0);
                OLED_ShowString(0, 16, "Successfully!", 16, 1);
#if DEBUG_MODE == 1
                OLED_ShowString(0, 32, "Server Return:", 16, 1);
                OLED_ShowString(0, 48, (u8*)URecv, 16, 1);

#endif
                OLED_Refresh();
                beepOneSecOn();
            } else if (URecv[0] == 'C') {
                u8 codeFlag = 1, i;
                for (i = 0; i < 6; i++) {
#if DEBUG_MODE == 1
                    OLED_Clear();
                    OLED_ShowChar(0, 0, URecv[2 + i], 16, 0);
                    OLED_ShowChar(0, 16, securityCode[i], 16, 1);
                    OLED_Refresh();
                    delay_10ms(100);
#endif
                    if (URecv[2 + i] != securityCode[i]) {
                        codeFlag = 0;
                        break;
                    }
                }

                if (codeFlag == 1) {
                    ws2812bSetAll(GREEN);
                    OLED_Clear();
                    OLED_ShowString(0, 0, "Verify OK", 16, 0);
                    OLED_ShowString(0, 16, "Opening Now!", 16, 1);
#if DEBUG_MODE == 1
                    OLED_ShowString(0, 32, "Server Return:", 16, 1);
                    OLED_ShowString(0, 48, (u8*)URecv, 16, 1);

#endif
                    OLED_Refresh();
                    beepOneSecOn();
                    relay_on(); 
                    delay_10ms(200);
                    relay_off();
                } else if (codeFlag == 0) {
                    ws2812bSetAll(RED);
                    OLED_Clear();
                    OLED_ShowString(0, 0, "Failed!", 16, 0);
                    OLED_ShowString(0, 16, "Code is wrong!", 16, 1);
#if DEBUG_MODE == 1
                    OLED_ShowString(0, 32, "Server Return:", 16, 1);
                    OLED_ShowString(0, 48, (u8*)URecv, 16, 1);

#endif
                    OLED_Refresh();
                    beepOneSecOn();
                    delay_ms(200);
                    beepOneSecOn();
                }
            } else {
                ws2812bSetAll(RED);
                OLED_Clear();
                OLED_ShowString(0, 0, "Failed!", 16, 0);
                OLED_ShowString(0, 16, "Unknow Error!", 16, 1);
#if DEBUG_MODE == 1
                OLED_ShowString(0, 32, "Server Return:", 16, 1);
                OLED_ShowString(0, 48, (u8*)URecv, 16, 1);

#endif
                OLED_Refresh();
                beepOneSecOn();
                delay_ms(200);
                beepOneSecOn();
            }

            ws2812bSetAll(YELLOW);
            if (modeFlag == 0) {
                genRandCode(securityCode);
OLED_Clear();
writeQRCodeBuffer();
OLED_ShowString(65, 0, "Welcome!", 16, 1);
OLED_ShowString(65, 16, "Security", 16, 1);
OLED_ShowString(65, 32, "Code:", 16, 1);
OLED_ShowString(65, 48, securityCode, 16, 1);
OLED_Refresh();
            } else if (modeFlag == 1) {
                OLED_Clear();
                OLED_ShowString(0, 0, "Welcome!", 16, 0);
                OLED_ShowString(0, 16, "New Card Regist", 16, 1);
                OLED_ShowString(0, 32, "Waiting For Card", 16, 1);
                OLED_ShowString(0, 48, "......", 16, 1);
                OLED_Refresh();
            }

            URecv_Index = 0;
            memset(URecv, 0, sizeof(URecv));
        }

        status = PcdRequest(REQ_ALL, TagType);
        if (!status) {
            status = PcdAnticoll(SelectedSnr);
            if (!status) {
                status = PcdSelect(SelectedSnr);
                if (!status) {
                    snr = 1; 
                    status = PcdAuthState(KEYA, (snr * 4 + 3), DefaultKey, SelectedSnr); 
                    {
                        if (!status) {
                            status = PcdRead((snr * 4 + 0), buf); 
                            
                            
                            if (!status) 
                            {
                                u8 cardIDChar[9], sendBuff[16];
                                memset(cardIDChar, 0, sizeof(cardIDChar));
                                memset(sendBuff, 0, sizeof(sendBuff));

                                HexToStr(cardIDChar, 9, SelectedSnr, 4);

                                if (modeFlag == 0) {
                                    sendBuff[0] = '0'; 
                                    sendBuff[1] = 'D'; 
                                    sendBuff[2] = 0;
                                    strcat((char*)sendBuff, (char*)cardIDChar);
                                    USART1_Send_Data((char*)sendBuff, strlen((char*)sendBuff));
                                    delay_ms(100);

                                    OLED_Clear();
                                    OLED_ShowString(0, 0, "Verifying...", 16, 0);
                                    OLED_ShowString(0, 16, "Please Waiting!", 16, 1);
#if DEBUG_MODE == 1
                                    OLED_ShowString(0, 32, "Card ID:", 16, 1);
                                    OLED_ShowString(0, 48, cardIDChar, 16, 1);
#endif
                                    OLED_Refresh();

                                } else if (modeFlag == 1) {
                                    sendBuff[0] = '1'; 
                                    sendBuff[1] = 'D'; 
                                    sendBuff[2] = 0;
                                    strcat((char*)sendBuff, (char*)cardIDChar);
                                    USART1_Send_Data((char*)sendBuff, strlen((char*)sendBuff));
                                    delay_ms(100);

                                    OLED_Clear();
                                    OLED_ShowString(0, 0, "Registing...", 16, 0);
                                    OLED_ShowString(0, 16, "Please Waiting!", 16, 1);
#if DEBUG_MODE == 1
                                    OLED_ShowString(0, 32, "Card ID:", 16, 1);
                                    OLED_ShowString(0, 48, cardIDChar, 16, 1);
#endif
                                    OLED_Refresh();
                                }

                                LED_ON;
                                
                                
                                WaitCardOff();
                            }
                        }
                    }
                }
            }
        }
        LED_OFF;
    }
}

void RC522_System_Init(void)
{
    beepInit();
    RC522_Init();
    OLED_Init();
    OLED_ColorTurn(0); 
    OLED_DisplayTurn(0); 
    ESP8266_Init();
    ws2812bInit();
    buttonInit(key1_GPIO_CLK, key1_GPIO_PORT, key1_pin);
    relay_init();

    LED_OFF;
    delay_10ms(10);
    PcdReset();
    PcdAntennaOff();
    PcdAntennaOn();
    M500PcdConfigISOType('A');
    LED_ON;
    delay_10ms(10);
    LED_OFF;
    delay_10ms(10);
    LED_ON;
    delay_10ms(10);
    LED_OFF;
}

void genRandCode(u8* Des)
{
    
    u8 temp[6], tempint[13];
    getRND(temp, 6);
    HexToStr(tempint, 13, temp, 6);
    int i, j = 0;
    for (i = 0; i < 6; i++) {
        if (tempint[i * 2] >= 65 && tempint[i * 2] <= 70) {
            tempint[i * 2] -= 6;
            j++;
        }
        if (tempint[i * 2 + 1] >= 65 && tempint[i * 2 + 1] <= 70) {
            tempint[i * 2 + 1] -= 6;
            j++;
        }
        Des[i] = (tempint[i * 2] + tempint[i * 2 + 1] - 7 * j) / 2;
        j = 0;
    }
    
QRcode_free(qrcode);
    qrcode = QRcode_encodeString((const char*)Des, 1, QR_ECLEVEL_L, QR_MODE_8, 0);
}

void writeQRCodeBuffer()
{
    int x, y, offsetx = 0;
    for (y = 0; y < qrcode->width * 3; y += 3) {
        for (x = 0; x < qrcode->width * 3; x += 3) {
            if (qrcode->data[y / 3 * qrcode->width + x / 3] & 0x01) {
                OLED_DrawPoint(x + offsetx, y, 1);
                OLED_DrawPoint(x + 1 + offsetx, y + 1, 1);
                OLED_DrawPoint(x + 2 + offsetx, y + 2, 1);
                OLED_DrawPoint(x + 1 + offsetx, y, 1);
                OLED_DrawPoint(x + 2 + offsetx, y, 1);
                OLED_DrawPoint(x + offsetx, y + 1, 1);
                OLED_DrawPoint(x + offsetx, y + 2, 1);
                OLED_DrawPoint(x + 2 + offsetx, y + 1, 1);
                OLED_DrawPoint(x + 1 + offsetx, y + 2, 1);
            }

            else {
                OLED_DrawPoint(x + offsetx, y, 0);
                OLED_DrawPoint(x + 1 + offsetx, y + 1, 0);
                OLED_DrawPoint(x + 2 + offsetx, y + 2, 0);
                OLED_DrawPoint(x + 1 + offsetx, y, 0);
                OLED_DrawPoint(x + 2 + offsetx, y, 0);
                OLED_DrawPoint(x + offsetx, y + 1, 0);
                OLED_DrawPoint(x + offsetx, y + 2, 0);
                OLED_DrawPoint(x + 2 + offsetx, y + 1, 0);
                OLED_DrawPoint(x + 1 + offsetx, y + 2, 0);
            }
        }
    }
}/*
 * Copyright (c) 2020 Tencent Cloud. All rights reserved.

 * Licensed under the MIT License (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http:

 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <string.h>
#include <time.h>
#include <unistd.h>

#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "nvs_flash.h"
#include "esp_wifi.h"
#include "esp_smartconfig.h"
#include "esp_event_loop.h"
#include "esp_log.h"
#include "lwip/apps/sntp.h"

#include "qcloud_iot_export.h"
#include "qcloud_iot_demo.h"
#include "qcloud_wifi_config.h"
#include "board_ops.h"
#include "qrcode.h"

#include "../build/include/sdkconfig.h"

#ifndef CONFIG_WIFI_CONFIG_ENABLED
/* WiFi router SSID  */
#define TEST_WIFI_SSID CONFIG_DEMO_WIFI_SSID
/* WiFi router password */
#define TEST_WIFI_PASSWORD CONFIG_DEMO_WIFI_PASSWORD

static const int          CONNECTED_BIT = BIT0;
static EventGroupHandle_t wifi_event_group;
bool                      wait_for_wifi_ready(int event_bits, uint32_t wait_cnt, uint32_t BlinkTime)
{
    EventBits_t uxBits;
    uint32_t    cnt       = 0;
    uint8_t     blueValue = 0;

    while (cnt++ < wait_cnt) {
        uxBits = xEventGroupWaitBits(wifi_event_group, event_bits, true, false, BlinkTime / portTICK_RATE_MS);

        if (uxBits & CONNECTED_BIT) {
            Log_d("WiFi Connected to AP");
            return true;
        }

        blueValue = (~blueValue) & 0x01;
        set_wifi_led_state(blueValue);
    }

    xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);

    return false;
}

static void wifi_connection(void)
{
    wifi_config_t wifi_config = {
        .sta =
            {
                .ssid     = TEST_WIFI_SSID,
                .password = TEST_WIFI_PASSWORD,
            },
    };
    Log_i("Setting WiFi configuration SSID %s...", wifi_config.sta.ssid);

    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));

    esp_wifi_connect();
}
static esp_err_t _esp_event_handler(void* ctx, system_event_t* event)
{
    Log_i("event = %d", event->event_id);

    switch (event->event_id) {
        case SYSTEM_EVENT_STA_START:
            Log_i("SYSTEM_EVENT_STA_START");
            wifi_connection();
            break;

        case SYSTEM_EVENT_STA_GOT_IP:
            Log_i("Got IPv4[%s]", ip4addr_ntoa(&event->event_info.got_ip.ip_info.ip));
            xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);

            break;

        case SYSTEM_EVENT_STA_DISCONNECTED:
            Log_i("SYSTEM_EVENT_STA_DISCONNECTED");
            xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
            esp_wifi_connect();
            break;

        default:
            break;
    }

    return ESP_OK;
}

static void esp_wifi_initialise(void)
{
    tcpip_adapter_init();

    wifi_event_group = xEventGroupCreate();
    ESP_ERROR_CHECK(esp_event_loop_init(_esp_event_handler, NULL));
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_start());
}
static void setup_sntp(void)
{
    sntp_setoperatingmode(SNTP_OPMODE_POLL);

    
    
    sntp_setservername(0, "time1.cloud.tencent.com");
    sntp_setservername(1, "cn.pool.ntp.org");
    sntp_setservername(2, "time-a.nist.gov");
    sntp_setservername(3, "cn.ntp.org.cn");

    sntp_init();

    
    time_t    now         = 0;
    struct tm timeinfo    = {0};
    int       retry       = 0;
    const int retry_count = 10;

    while (timeinfo.tm_year < (2019 - 1900) && ++retry < retry_count) {
        Log_d("Waiting for system time to be set... (%d/%d)", retry, retry_count);
        sleep(1);
        time(&now);
        localtime_r(&now, &timeinfo);
    }

    
    setenv("TZ", "CST-8", 1);
    tzset();
}

#endif  

void qcloud_demo_task(void* parm)
{
    bool wifi_connected = false;
    Log_i("qcloud_demo_task start");
#ifndef CONFIG_WIFI_CONFIG_ENABLED
    
    board_init();
    esp_wifi_initialise();
    
    wifi_connected = wait_for_wifi_ready(CONNECTED_BIT, 20, 1000);
    if (wifi_connected) {
        setup_sntp();
        qcloud_iot_explorer_demo(CONFIG_DEMO_EXAMPLE_SELECT);
    } else {
        Log_e("WiFi is not ready, please check configuration");
    }
#else
    qcloud_iot_explorer_demo(CONFIG_DEMO_EXAMPLE_SELECT);
#endif  

    Log_w("qcloud_demo_task quit");
    vTaskDelete(NULL);
}

void app_main()
{
    ESP_ERROR_CHECK(nvs_flash_init());
    
    IOT_Log_Set_Level(eLOG_DEBUG);
    Log_i("FW built time %s %s", __DATE__, __TIME__);
    board_init();
    xTaskCreate(qcloud_demo_task, "qcloud_demo_task", 8196, NULL, 4, NULL);
}/** \file
 * \brief Public Key Rotation
 *
 * \copyright (c) 2015-2018 Microchip Technology Inc. and its subsidiaries.
 *
 * \page License
 *
 * Subject to your compliance with these terms, you may use Microchip software
 * and any derivatives exclusively with Microchip products. It is your
 * responsibility to comply with third party license terms applicable to your
 * use of third party software (including open source software) that may
 * accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
 * PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT,
 * SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE
 * OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
 * FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
 * THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
 * THIS SOFTWARE.
 */

#include "cryptoauthlib.h"
#include "atcacert/atcacert_pem.h"
#include "host/atca_host.h"
#include "../../../assets/dependencies/common/common.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../../00_resource_generation/public_key_rotation.h"
#if defined(__XC32__)
#include "definitions.h"
#endif

#if defined(ATMEL_START)
#include <atmel_start.h>
#endif

#if defined(__XC32__)
#define TOGGLE_STATUS_LED GPIO_PA02_Toggle()
#endif
#if defined(ATMEL_START)
#define TOGGLE_STATUS_LED gpio_toggle_pin_level(GPIO(GPIO_PORTA, 2));
#endif

#if defined(__XC32__)
extern ATCAIfaceCfg atecc608_0_init_data;
#endif

uint16_t rotating_key_slot = 14;
uint16_t authority_key_slot = 13;

ATCA_STATUS publickey_validate(bool validate)
{
    ATCA_STATUS status;
    uint8_t sn[9];
    uint8_t public_key[64];
    bool is_verified = false;
    uint8_t rand_out[ATCA_KEY_SIZE];
    atca_temp_key_t temp_key;
    atca_nonce_in_out_t nonce_params;
    uint8_t gen_key_other_data[3];
    atca_gen_key_in_out_t gen_key_params;
    uint8_t verify_other_data[19];
    uint8_t validation_msg[55];
    uint8_t validation_digest[32];
    atca_sign_internal_in_out_t sign_params;
    uint8_t nonce[32],config[128];

    do
    {
        
        if ((status = atcab_read_serial_number(sn)) != ATCA_SUCCESS)
            break;

        
        if ((status = atcab_read_config_zone(config)) != ATCA_SUCCESS)
            break;

if (validate)
            memcpy(nonce, validated_nonce, 32);
        else
            memcpy(nonce, invalidated_nonce, 32);

        
        memset(&temp_key, 0, sizeof(temp_key));
        memset(&nonce_params, 0, sizeof(nonce_params));
        nonce_params.mode = NONCE_MODE_PASSTHROUGH;
        nonce_params.zero = 0;
        nonce_params.num_in = nonce;
        nonce_params.rand_out = rand_out;
        nonce_params.temp_key = &temp_key;
        if ((status = atcab_nonce(nonce_params.num_in)) != ATCA_SUCCESS)
            break;

        if ((status = atcah_nonce(&nonce_params)) != ATCA_SUCCESS)
            break;

        
        
        
        if ((status = atcab_read_pubkey(rotating_key_slot, public_key)) != ATCA_SUCCESS)
            break;

        memset(gen_key_other_data, 0, sizeof(gen_key_other_data));
        gen_key_params.mode = GENKEY_MODE_PUBKEY_DIGEST;
        gen_key_params.key_id = rotating_key_slot;
        gen_key_params.public_key = public_key;
        gen_key_params.public_key_size = sizeof(public_key);
        gen_key_params.other_data = gen_key_other_data;
        gen_key_params.sn = sn;
        gen_key_params.temp_key = &temp_key;
        if ((status = atcah_gen_key_msg(&gen_key_params)) != ATCA_SUCCESS)
            break;

        memset(&sign_params, 0, sizeof(sign_params));
        sign_params.sn = sn;
        sign_params.verify_other_data = verify_other_data;
        sign_params.key_id = authority_key_slot;
        sign_params.slot_config = (config[20 + rotating_key_slot * 2]   | config[21 + rotating_key_slot * 2] << 8);
        sign_params.key_config = (config[96 + rotating_key_slot * 2] | config[97 + rotating_key_slot * 2] << 8);
        sign_params.for_invalidate = !validate;
        sign_params.message = validation_msg;
        sign_params.digest = validation_digest;
        sign_params.temp_key = &temp_key;
        if ((status = atcah_sign_internal_msg(ATECC608A, &sign_params)) != ATCA_SUCCESS)
            break;

        
        if ((status = atcab_genkey_base(gen_key_params.mode, gen_key_params.key_id, gen_key_params.other_data, NULL)) != ATCA_SUCCESS)
            break;

        
        if (validate)
        {
            
            if ((status = atcab_verify_validate(rotating_key_slot, validated_signature, verify_other_data, &is_verified)) != ATCA_SUCCESS)
                break;
        }
        else
        {
            if ((status = atcab_verify_invalidate(rotating_key_slot, invalidated_signature, verify_other_data, &is_verified)) != ATCA_SUCCESS)
                break;
        }

        if (is_verified == true)
            status = ATCA_SUCCESS;